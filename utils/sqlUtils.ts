/**
 * SQL Utilities
 *
 * Utilities for parsing and generating SQL schemas.
 * Extracted from DBStudio.tsx for better modularity.
 */

import type { Edge } from '@xyflow/react';

export interface Column {
  name: string;
  type: string;
  isPrimaryKey?: boolean;
  isForeignKey?: boolean;
  isNullable?: boolean;
  defaultValue?: string;
  references?: { table: string; column: string };
}

export interface TableSchema {
  name: string;
  columns: Column[];
}

export interface SQLParseResult {
  tables: TableSchema[];
  relationships: { from: string; to: string }[];
}

/**
 * Parse SQL to extract table schemas
 */
export function parseSQLToSchema(sql: string): SQLParseResult {
  const tables: TableSchema[] = [];
  const relationships: { from: string; to: string }[] = [];

  // Match CREATE TABLE statements
  const tableRegex = /CREATE TABLE\s+(\w+)\s*\(([\s\S]*?)\);/gi;
  let match;

  while ((match = tableRegex.exec(sql)) !== null) {
    const tableName = match[1];
    const columnsStr = match[2];
    const columns: Column[] = [];

    // Parse each column
    const lines = columnsStr
      .split(',')
      .map(l => l.trim())
      .filter(l => l && !l.startsWith('CONSTRAINT') && !l.startsWith('FOREIGN KEY') && !l.startsWith('PRIMARY KEY'));

    for (const line of lines) {
      const colMatch = line.match(/^(\w+)\s+(\w+(?:\(\d+(?:,\d+)?\))?)/i);
      if (colMatch) {
        const col: Column = {
          name: colMatch[1],
          type: colMatch[2].toUpperCase()
        };
        if (/PRIMARY\s+KEY/i.test(line)) col.isPrimaryKey = true;
        if (/NOT\s+NULL/i.test(line)) col.isNullable = false;
        if (/REFERENCES/i.test(line)) col.isForeignKey = true;
        columns.push(col);
      }
    }

    if (columns.length > 0) {
      tables.push({ name: tableName, columns });
    }
  }

  // Parse ALTER TABLE for foreign keys
  const fkRegex = /ALTER TABLE\s+(\w+)\s+ADD CONSTRAINT.*?FOREIGN KEY\s*\((\w+)\)\s*REFERENCES\s+(\w+)\s*\((\w+)\)/gi;
  while ((match = fkRegex.exec(sql)) !== null) {
    relationships.push({
      from: `${match[1]}.${match[2]}`,
      to: `${match[3]}.${match[4]}`
    });
  }

  return { tables, relationships };
}

/**
 * Generate SQL from schema
 */
export function generateSQL(tables: TableSchema[], edges: Edge[]): string {
  if (tables.length === 0) return '-- No tables defined yet\n';

  let sql = '-- Generated by FluidFlow DB Studio\n';
  sql += `-- Generated at: ${new Date().toISOString()}\n\n`;

  for (const table of tables) {
    sql += `CREATE TABLE ${table.name} (\n`;
    const columnDefs = table.columns.map(col => {
      let def = `  ${col.name} ${col.type}`;
      if (col.isPrimaryKey) def += ' PRIMARY KEY';
      if (col.isNullable === false && !col.isPrimaryKey) def += ' NOT NULL';
      if (col.defaultValue) def += ` DEFAULT ${col.defaultValue}`;
      return def;
    });
    sql += columnDefs.join(',\n');
    sql += '\n);\n\n';
  }

  for (const edge of edges) {
    if (edge.sourceHandle && edge.targetHandle) {
      const sourceParts = edge.sourceHandle.split('-');
      const targetParts = edge.targetHandle.split('-');
      if (sourceParts.length >= 2 && targetParts.length >= 2) {
        const sourceTable = sourceParts[0];
        const sourceCol = sourceParts[1];
        const targetTable = targetParts[0];
        const targetCol = targetParts[1];
        sql += `ALTER TABLE ${sourceTable}\n`;
        sql += `  ADD CONSTRAINT fk_${sourceTable}_${sourceCol}\n`;
        sql += `  FOREIGN KEY (${sourceCol}) REFERENCES ${targetTable}(${targetCol});\n\n`;
      }
    }
  }

  return sql;
}

/**
 * Generate fake data for seeding
 */
export function generateFakeData(tables: TableSchema[], rowCount: number = 10): string {
  if (tables.length === 0) return '-- No tables to seed\n';

  let sql = '-- Sample data generated by FluidFlow DB Studio\n';
  sql += `-- Generated at: ${new Date().toISOString()}\n`;
  sql += `-- Rows per table: ${rowCount}\n\n`;

  const names = ['Alice', 'Bob', 'Charlie', 'Diana', 'Eve', 'Frank', 'Grace', 'Henry', 'Ivy', 'Jack'];
  const domains = ['gmail.com', 'yahoo.com', 'outlook.com', 'company.com'];
  const products = ['Laptop', 'Phone', 'Tablet', 'Watch', 'Headphones', 'Camera', 'Speaker', 'Monitor', 'Keyboard', 'Mouse'];
  const statuses = ['pending', 'processing', 'shipped', 'delivered', 'cancelled'];

  for (const table of tables) {
    sql += `-- ${table.name} data\n`;

    for (let i = 1; i <= rowCount; i++) {
      const values = table.columns.map(col => {
        const colName = col.name.toLowerCase();
        if (col.isPrimaryKey) return i.toString();

        // Smart value generation based on column name
        if (colName.includes('email')) return `'${names[i % names.length].toLowerCase()}${i}@${domains[i % domains.length]}'`;
        if (colName.includes('name') && colName.includes('user')) return `'${names[i % names.length]}'`;
        if (colName.includes('name') && colName.includes('product')) return `'${products[i % products.length]}'`;
        if (colName.includes('name')) return `'${names[i % names.length]}'`;
        if (colName.includes('title')) return `'Title ${i}'`;
        if (colName.includes('description')) return `'Description for item ${i}'`;
        if (colName.includes('status')) return `'${statuses[i % statuses.length]}'`;
        if (colName.includes('price') || colName.includes('amount') || colName.includes('total')) return (Math.random() * 1000).toFixed(2);
        if (colName.includes('quantity') || colName.includes('count')) return Math.floor(Math.random() * 100).toString();
        if (colName.includes('_id') || colName.includes('id')) return Math.floor(Math.random() * rowCount + 1).toString();
        if (colName.includes('phone')) return `'+1${Math.floor(Math.random() * 9000000000 + 1000000000)}'`;
        if (colName.includes('address')) return `'${Math.floor(Math.random() * 9999)} Main St, City ${i}'`;

        switch (col.type.toUpperCase().split('(')[0]) {
          case 'INT':
          case 'BIGINT':
          case 'SERIAL':
            return Math.floor(Math.random() * 1000).toString();
          case 'VARCHAR':
          case 'TEXT':
            return `'Sample ${col.name} ${i}'`;
          case 'BOOLEAN':
            return Math.random() > 0.5 ? 'TRUE' : 'FALSE';
          case 'DATE':
            return `'2024-${String(Math.floor(Math.random() * 12) + 1).padStart(2, '0')}-${String(Math.floor(Math.random() * 28) + 1).padStart(2, '0')}'`;
          case 'DATETIME':
          case 'TIMESTAMP':
            return `'2024-${String(Math.floor(Math.random() * 12) + 1).padStart(2, '0')}-${String(Math.floor(Math.random() * 28) + 1).padStart(2, '0')} ${String(Math.floor(Math.random() * 24)).padStart(2, '0')}:${String(Math.floor(Math.random() * 60)).padStart(2, '0')}:00'`;
          case 'DECIMAL':
          case 'FLOAT':
            return (Math.random() * 1000).toFixed(2);
          case 'UUID':
            return `'${crypto.randomUUID()}'`;
          case 'JSON':
            return `'{"key": "value${i}"}'`;
          default:
            return 'NULL';
        }
      });

      sql += `INSERT INTO ${table.name} (${table.columns.map(c => c.name).join(', ')}) VALUES (${values.join(', ')});\n`;
    }
    sql += '\n';
  }

  return sql;
}
