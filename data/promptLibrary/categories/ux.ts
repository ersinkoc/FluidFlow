import type { PromptCategory } from '../types';

export const uxCategory: PromptCategory = {
    id: 'ux',
    name: 'UX Improvements',
    icon: 'Sparkles',
    description: 'User experience enhancements',
    prompts: [
      {
        id: 'u1',
        label: 'Better CTAs',
        simple: 'Improve call-to-action buttons with clear action words and prominent styling.',
        detailed: 'Improve call-to-action buttons for maximum conversion. Use action-oriented verbs ("Get Started", "Try Free", "Join Now") instead of generic text. Make primary CTA visually dominant with larger size, bold colors (bg-blue-600), and prominent positioning. Add secondary CTAs with outlined style (border-2 border-blue-600 text-blue-600). Include micro-interactions on hover (scale-105, brightness change). Use contrasting colors against background. Add urgency when appropriate ("Limited time"). Ensure sufficient whitespace around CTAs. Place above the fold and repeat at logical points.',
        advanced: 'Improve call-to-action buttons for maximum conversion using proven UX patterns. Use action-oriented, benefit-focused verbs ("Get Started Free", "Start Saving Today", "Join 10,000+ Users") instead of generic text ("Submit", "Click Here"). Make primary CTA visually dominant: larger size (py-3 px-8), bold colors (bg-blue-600 hover:bg-blue-700), prominent positioning above fold. Create clear visual hierarchy: primary (filled), secondary (outlined border-2), tertiary (text link). Include micro-interactions: hover (scale-105 or brightness-110), active (scale-95), focus-visible ring. Use contrasting colors meeting WCAG AA - test CTA visibility. Add urgency ethically when true ("Limited time offer", countdown timers). Ensure 24px+ whitespace around CTAs. Place strategically: hero section, after value props, fixed bottom bar on long pages. A/B test button copy and colors. Add loading state for form submissions. Consider button placement in thumb zone on mobile. Track click-through rates for optimization.'
      },
      {
        id: 'u2',
        label: 'Loading States',
        simple: 'Add loading spinners and skeleton screens for async operations.',
        detailed: 'Add comprehensive loading states for all async operations. Implement skeleton screens matching content layout using animate-pulse with bg-gray-200 shapes. Add spinner for button loading states (Loader2 icon with animate-spin). Show progress bars for uploads/downloads with percentage. Display contextual loading messages ("Loading your dashboard..."). Use optimistic UI updates where possible. Add minimum loading time (300ms) to prevent flash. Include cancel option for long operations. Implement progressive loading - show content as it arrives. Handle timeout states gracefully with retry option.',
        advanced: 'Add comprehensive loading states for all async operations following perceived performance principles. Implement skeleton screens matching exact content layout using animate-pulse with bg-gray-200 shapes - maintain layout stability (no CLS). Add spinner for button loading states: Loader2 icon with animate-spin, maintain button width with min-w constraint, disable button and show loading text. Show determinate progress bars for uploads/downloads with percentage and estimated time. Display contextual loading messages that reduce anxiety ("Loading your dashboard...", "Almost there..."). Implement optimistic UI: update UI immediately, rollback on error with clear feedback. Add minimum loading time (300ms) to prevent jarring flash for fast operations. Include cancel option (AbortController) for long operations with confirmation. Implement progressive/streaming loading - show content as it arrives. Handle timeout states: show message after 10s, offer retry after 30s, suggest offline mode if repeated failures. Add aria-busy and aria-live for screen reader announcements. Show skeleton for initial loads, spinner for subsequent. Consider network quality - adjust timeout thresholds.'
      },
      {
        id: 'u3',
        label: 'Empty States',
        simple: 'Design helpful empty states with icons and clear call-to-action.',
        detailed: 'Design helpful empty states that guide users to action. Include friendly illustration or icon (use lucide-react icons at large size like h-24 w-24 text-gray-300). Write clear headline explaining the state ("No projects yet"). Add supportive body text with next steps ("Create your first project to get started"). Include prominent CTA button for the primary action. Suggest alternative actions if applicable. Use consistent empty state pattern across all list/grid views. Add subtle background patterns for visual interest. Consider different empty states: first-time vs filtered results vs error state.',
        advanced: 'Design helpful empty states that guide users to action and reduce abandonment. Include friendly illustration or icon (lucide-react icons h-16 w-16 to h-24 w-24 text-gray-400) centered in container. Write clear, empathetic headline explaining the state ("No projects yet" not "Error: Empty"). Add supportive body text with specific next steps ("Create your first project to start collaborating with your team"). Include single prominent CTA button for primary action - dont overwhelm with choices. Suggest ONE alternative if truly applicable ("or import from template"). Use consistent empty state pattern across all views - create reusable EmptyState component. Differentiate states: first-time user (encouraging, onboarding-focused), filtered results ("No matches for X", show clear filters button), error state (apologetic, retry option), permission-denied (explain why, who to contact). Add subtle background pattern or illustration that matches brand. ACCESSIBILITY: Ensure empty state is announced to screen readers, CTA is keyboard accessible. Consider adding sample/demo data option for first-time users. Track empty state views to identify UX friction points.'
      },
      {
        id: 'u4',
        label: 'Error Handling',
        simple: 'Show user-friendly error messages with recovery options.',
        detailed: 'Implement user-friendly error handling throughout the application. Display inline errors near the source with red text (text-red-600) and error icon (AlertCircle). Show toast notifications for transient errors with auto-dismiss. Create full-page error states for critical failures with illustration, clear message, and recovery actions. Provide specific, actionable error messages - avoid technical jargon. Include "Try again" buttons with proper retry logic. Log errors for debugging while showing user-friendly messages. Add error boundaries to prevent full app crashes. Show offline state indicator when network is unavailable.',
        advanced: 'Implement comprehensive user-friendly error handling with graceful degradation. Display inline errors near source with red styling (text-red-600 border-red-500) and AlertCircle icon - position errors below inputs, not in tooltips. Show toast notifications for transient/recoverable errors (auto-dismiss 5s) at bottom-right with dismiss button. Create full-page error states for critical failures: friendly illustration, clear non-technical message, specific recovery actions (retry, go home, contact support). Provide specific, actionable error messages: "Couldnt save - check your internet connection" not "Error 500". Include "Try again" with exponential backoff retry logic (1s, 2s, 4s, max 3 attempts). Log errors to monitoring service (Sentry) with context while showing user-friendly messages. Implement React Error Boundaries at route and component level to prevent full app crashes - show fallback UI. Show offline indicator: banner at top, disable actions requiring network, queue operations for sync. Handle specific error types: 401 (session expired, redirect to login), 403 (permission denied, explain), 404 (not found, suggest alternatives), 429 (rate limited, show wait time), 5xx (server error, apologize and retry). Add aria-live regions for error announcements. Preserve user input on errors - never lose work.'
      },
      {
        id: 'u5',
        label: 'Form Validation',
        simple: 'Add real-time form validation with clear error and success states.',
        detailed: 'Implement comprehensive form validation with excellent UX. Add real-time inline validation as user types (debounced). Show error messages below inputs with text-red-600 and shake animation. Add success checkmarks (CheckCircle icon text-green-600) for valid fields. Use proper input states: default, focus (ring-2 ring-blue-500), error (ring-2 ring-red-500), success (ring-2 ring-green-500). Implement validation on blur for better UX. Show password strength meter with visual indicator. Add character counters for text areas. Disable submit button until form is valid. Show summary of errors at form top for long forms. Preserve user input on validation failure.',
        advanced: 'Implement comprehensive form validation with excellent UX using proven patterns. Add real-time inline validation with 300ms debounce - validate as user types but not on every keystroke. Show error messages below inputs (not tooltips) with text-red-600, error icon, and subtle shake animation on appearance. Add success checkmarks (CheckCircle text-green-600) for valid fields to provide positive feedback. Use proper input states with clear visual distinction: default (border-gray-300), focus (ring-2 ring-blue-500 border-blue-500), error (ring-2 ring-red-500 border-red-500), success (ring-2 ring-green-500 border-green-500). Implement validation on blur for complex fields (email format, async validation) - dont frustrate users typing. Show password strength meter: 4-segment bar with colors (red/orange/yellow/green) and text feedback. Add character counters for textareas showing "X/500" near limit. Disable submit button until required fields valid - but show tooltip explaining what is missing. Show error summary at form top for long forms with links to each error. CRITICAL: Always preserve user input on validation failure. Mark required fields with asterisk and "(required)" for screen readers. Use aria-describedby linking inputs to error messages. Implement async validation (username availability) with loading indicator. Support autocomplete attributes for browser autofill.'
      },
      {
        id: 'u6',
        label: 'Onboarding Flow',
        simple: 'Create welcome screens and setup wizard for new users.',
        detailed: 'Create engaging onboarding experience for new users. Design welcome modal with personalized greeting and value proposition. Add multi-step setup wizard for essential configuration (max 3-5 steps). Include progress indicator showing current step. Use illustrations or icons to explain each feature. Add "Skip" option for users who want to explore freely. Implement feature highlights with spotlight effect (dark overlay with highlighted element). Add tooltip tours pointing to key UI elements. Store onboarding completion state to not repeat. Include sample data or templates to help users understand the product. Add contextual tips that appear during first-time actions.',
        advanced: 'Create engaging onboarding that activates users while respecting their time. Design welcome modal: personalized greeting if name available, clear value proposition (3 bullet benefits), prominent "Get Started" CTA, subtle "Skip" option. Add multi-step setup wizard for essential configuration only (3-5 steps max): each step single-focused, progress indicator visible, back button available. Use illustrations/animations to explain features - not walls of text. Implement progressive onboarding over time, not all at once. Add "Skip" that leads to minimal viable setup - respect user agency. Implement feature highlights with spotlight effect: dark overlay (bg-black/60), highlighted element with padding, tooltip with explanation and "Got it" button, keyboard navigable (arrows/tab). Store onboarding state in backend (not just localStorage) - dont repeat for returning users. Include sample data or templates: "Start with a template" vs "Start from scratch". Add contextual tips on first-time actions using tooltips or coach marks. Track completion rates per step to identify friction. Offer "replay tour" in help menu. ACCESSIBILITY: Ensure spotlight is keyboard accessible, skip link available, announcements for screen readers. Consider different onboarding paths for different user types/goals.'
      },
      {
        id: 'u7',
        label: 'Tooltips & Hints',
        simple: 'Add helpful tooltips that appear on hover with explanations.',
        detailed: 'Add contextual tooltips and hints throughout the interface. Use Tooltip component triggered on hover (desktop) or long-press (mobile). Position tooltips intelligently to stay within viewport (top/bottom/left/right). Include arrow pointer indicating the trigger element. Keep tooltip text concise (max 2-3 lines). Add Info icon (HelpCircle) next to complex features as tooltip trigger. Implement dismissible hint banners for important first-time information. Use coach marks for feature discovery with spotlight effect. Add keyboard shortcut hints in tooltips where applicable. Ensure tooltips are accessible with proper ARIA attributes and keyboard support.',
        advanced: 'Add contextual tooltips and hints throughout the interface following accessibility best practices. Use Tooltip component triggered on hover (desktop) with 200ms delay, long-press (mobile) with 500ms threshold. Position tooltips intelligently: calculate viewport boundaries, flip position if needed, maintain 8px padding from edges. Include arrow pointer indicating trigger element using CSS triangle or SVG. Keep tooltip text concise: max 2-3 lines, no critical information (must be accessible without tooltip). Add HelpCircle icon (w-4 h-4 text-gray-400) next to complex features as explicit tooltip trigger - not relying on hover discovery. Implement dismissible hint banners for important first-time information: yellow/blue background, dismiss persists to localStorage. Use coach marks for feature discovery: spotlight effect, step-through tour, "1 of 5" counter. Add keyboard shortcut hints in tooltips: "Save (Ctrl+S)". ACCESSIBILITY CRITICAL: Use role="tooltip", aria-describedby on trigger, ensure keyboard focusable triggers show tooltip on focus, dont put interactive elements in tooltips, provide 300ms delay before hide to allow mouse movement to tooltip if needed. Consider touch-only devices: add dedicated help buttons instead of relying on long-press. Track tooltip engagement to identify confusing features.'
      },
      {
        id: 'u8',
        label: 'Breadcrumbs',
        simple: 'Add breadcrumb navigation showing the current page hierarchy.',
        detailed: 'Add breadcrumb navigation for clear wayfinding. Display hierarchical path showing current location (Home > Category > Subcategory > Current). Use ChevronRight or Slash icon as separator. Make all items except current clickable with hover underline. Truncate middle items on long paths with "..." (show 2 items + current). Show full path on hover for truncated items. Style current item differently (font-medium, no link). Place breadcrumbs consistently at top of content area. Use semantic nav element with aria-label="Breadcrumb". Include Home icon for first item. Hide on mobile or make horizontally scrollable. Add structured data for SEO.',
        advanced: 'Add breadcrumb navigation for clear wayfinding and SEO benefits. Display hierarchical path: Home > Category > Subcategory > Current Page. Use ChevronRight (w-4 h-4 text-gray-400) or "/" as separator - be consistent. Make all items except current clickable with hover:underline and hover:text-blue-600. Style links: text-gray-600, current item: text-gray-900 font-medium (no link). Truncate middle items on long paths (>4 levels): "Home > ... > Parent > Current" - show full path in tooltip on truncated "...". Place consistently at top of content area, below header, 16px margin bottom. SEMANTIC HTML: Use nav element with aria-label="Breadcrumb", ol/li for list structure, aria-current="page" on current item. Include Home icon (Home from lucide-react, w-4 h-4) for first item to save space. Mobile: hide breadcrumbs (space-consuming) OR horizontal scroll with overflow-x-auto and snap scrolling. Add JSON-LD structured data for SEO: BreadcrumbList schema. Generate breadcrumbs from route automatically if possible. Consider showing back button on mobile instead of full breadcrumbs. Dont use breadcrumbs for linear flows (checkout) - use progress indicator instead.'
      },
      {
        id: 'u9',
        label: 'Search Feature',
        simple: 'Add search input with autocomplete suggestions and results filtering.',
        detailed: 'Implement comprehensive search functionality. Add search input with Search icon prefix and clear (X) button. Implement real-time search with debouncing (300ms delay). Show search suggestions/autocomplete dropdown as user types. Display recent searches for quick access. Add filters sidebar or dropdown (category, date, type). Show result count and sort options (relevance, date, name). Create search results layout with highlighted matching terms. Design "No results" state with suggestions ("Try different keywords"). Add keyboard navigation (arrow keys, Enter to select). Support advanced search operators if applicable. Track search queries for analytics.',
        advanced: 'Implement comprehensive search functionality optimized for findability. Add search input: Search icon prefix (text-gray-400), clear X button on input, placeholder "Search..." or more specific. Implement real-time search with 300ms debounce - balance responsiveness vs API load. Show search suggestions dropdown as user types: recent searches (clock icon), popular searches, autocomplete predictions. Display recent searches (localStorage) with clear history option. Add filters: sidebar for desktop, bottom sheet for mobile - category, date range, type, status. Show result count ("24 results") and sort options (relevance default, date, name) in results header. Create search results layout: highlighted matching terms using mark element or span with bg-yellow-100, snippet context around matches. Design "No results" state: friendly message, suggestions (check spelling, fewer filters, browse categories), show what was searched. Implement keyboard navigation: arrow keys move selection, Enter selects, Escape closes. Support operators if applicable: quotes for exact match, minus for exclusion, site: for scoped search. Track search queries and clicks for relevance improvement. Add search analytics dashboard. ACCESSIBILITY: Use role="combobox" pattern, aria-expanded, aria-activedescendant for dropdown, announce result count. Consider fuzzy matching for typo tolerance.'
      },
      {
        id: 'u10',
        label: 'Notifications',
        simple: 'Build notification system with toast messages and notification center.',
        detailed: 'Build complete notification system. Add toast notifications for transient feedback using fixed bottom-right positioning. Include variants: success (green), error (red), warning (yellow), info (blue) with appropriate icons. Auto-dismiss after 5 seconds with manual close option. Stack multiple toasts with proper spacing. Create notification bell icon with badge showing unread count. Build notification center dropdown/sidebar with list of all notifications. Group notifications by time (Today, Yesterday, Earlier). Mark as read on view or explicit action. Add notification preferences/settings. Implement real-time updates. Include notification sounds option.',
        advanced: 'Build complete notification system covering transient and persistent notifications. Toast notifications for transient feedback: fixed bottom-right (or top-right) positioning avoiding mobile safe areas, z-50. Variants: success (green-500, CheckCircle), error (red-500, XCircle), warning (yellow-500, AlertTriangle), info (blue-500, Info). Auto-dismiss after 5s with progress bar indicator, manual close X button, pause timer on hover. Stack multiple toasts (gap-2), limit to 3 visible, queue others. Animate enter (slide-in-from-right) and exit (fade-out). Notification bell icon: relative positioned badge showing unread count (max "99+"), subtle pulse animation for new notifications. Build notification center: dropdown (desktop) or slide-over (mobile), header with "Notifications" and "Mark all read" button. List notifications grouped by time (Today, Yesterday, This Week, Earlier). Each notification: icon, title, description, timestamp ("2m ago"), unread indicator (blue dot). Mark as read on click or explicit action. Add notification preferences in settings: email, push, in-app toggles per notification type. Implement real-time updates via WebSocket or polling. Include notification sound option (with browser permission) and preference toggle. ACCESSIBILITY: Use aria-live="polite" for toasts, manage focus properly in notification center, announce unread count changes.'
      },
      {
        id: 'u11',
        label: 'Confirmation Dialogs',
        simple: 'Add confirmation modals for delete and other destructive actions.',
        detailed: 'Add confirmation dialogs for destructive or irreversible actions. Create modal with clear headline stating the action ("Delete project?"). Include body text explaining consequences ("This will permanently delete all files and cannot be undone"). Use danger styling for destructive actions (red button). Include Cancel button (secondary) and Confirm button (primary/danger). Make Cancel the default focused element for safety. Show loading state on confirm button during action. Add checkbox confirmation for critical actions ("I understand this cannot be undone"). Close on backdrop click only for non-critical confirmations. Support keyboard: Escape to cancel, Enter to confirm (carefully).',
        advanced: 'Add confirmation dialogs for destructive or irreversible actions to prevent costly mistakes. Create modal: clear headline stating specific action ("Delete Project X?" not just "Are you sure?"), body text explaining consequences in plain language ("This will permanently delete 47 files and remove access for 3 team members. This cannot be undone."). Use danger styling for destructive actions: red confirm button (bg-red-600), keep Cancel as secondary (gray outline). Make Cancel the default focused element for safety - prevent accidental Enter confirmation. Show loading state on confirm button during action with spinner, disable both buttons. Add checkbox confirmation for critical/irreversible actions: "I understand this cannot be undone" checkbox must be checked to enable Confirm button. Close on backdrop click only for non-critical confirmations - keep backdrop click disabled for destructive actions. Support keyboard: Escape always cancels, Enter confirms ONLY if confirm button is focused (not on checkbox), trap focus within modal. ACCESSIBILITY: Use role="alertdialog" for destructive confirmations, aria-describedby for consequence text, focus first focusable element (Cancel) on open, return focus to trigger on close. Consider requiring typing confirmation for critical actions (type "DELETE" to confirm). Log confirmations for audit trail.'
      },
      {
        id: 'u12',
        label: 'Progress Indicator',
        simple: 'Add step progress bar for multi-step forms and wizards.',
        detailed: 'Add step progress indicator for multi-step flows. Show numbered steps in horizontal layout (step-1 → step-2 → step-3). Indicate states: completed (check icon, green), current (highlighted, blue), upcoming (gray). Connect steps with progress line that fills as user advances. Display step labels below numbers. Make completed steps clickable to go back. Show validation state - prevent advancing if current step invalid. Add mobile-responsive version (vertical or simplified). Include percentage or "Step 2 of 5" text indicator. Animate transitions between steps. Save progress to allow resuming later. Show estimated time remaining if applicable.',
        advanced: 'Add step progress indicator for multi-step flows showing clear progress and enabling navigation. Show numbered steps in horizontal layout (1 → 2 → 3 → 4) with max 5-7 visible steps. Step states: completed (CheckCircle icon, green-500 background), current (blue-500, ring highlight), upcoming (gray-300). Connect steps with progress line: gray-200 background, filled portion green-500, animate width on progress. Display step labels below numbers - truncate on mobile. Make completed steps clickable to go back (but warn if unsaved changes). Show validation state: current step shows errors inline, prevent Next if invalid, shake/highlight Next button on attempt to advance invalid form. Mobile: vertical layout OR simplified "Step 2 of 5" text with progress bar only. Include percentage ("40% complete") or "Step 2 of 5" text. Animate step transitions: current step slides out, new slides in (use AnimatePresence). Save progress to localStorage/backend to allow resuming - show "Resume where you left off?" on return. Show estimated time remaining for longer flows ("About 3 minutes left"). ACCESSIBILITY: Use aria-current="step" on current item, aria-label on nav, announce step changes. Consider linear vs non-linear flows - some wizards should enforce order, others allow jumping. Add "Save and exit" option.'
      },
      {
        id: 'u13',
        label: 'Undo/Redo',
        simple: 'Add undo functionality with toast notification after destructive actions.',
        detailed: 'Implement undo functionality for reversible actions. Show toast notification immediately after action ("Item deleted") with "Undo" button. Set undo timeout (5-10 seconds) with visual countdown. Execute actual deletion only after timeout expires (soft delete pattern). Support multiple levels of undo with action history. Add Ctrl/Cmd+Z keyboard shortcut for undo. Store undo stack in state or local storage. Clear undo stack on page navigation or explicit confirmation. Show success message when undo is triggered ("Deletion canceled"). Implement redo (Ctrl/Cmd+Shift+Z) where appropriate. Handle edge cases: undo during loading, undo after navigation.',
        advanced: 'Implement undo functionality for reversible actions to enable fearless interaction. Show toast notification immediately after action: "Item deleted" with prominent "Undo" button. Set undo timeout (5-10 seconds) with visual countdown progress bar in toast. Implement soft delete pattern: mark item as deleted immediately (optimistic UI), execute actual deletion only after timeout expires, restore instantly on undo. Support multiple levels of undo with action history stack (limit to 10-20 items to manage memory). Add Ctrl/Cmd+Z keyboard shortcut for undo, Ctrl/Cmd+Shift+Z for redo - handle both globally. Store undo stack in React state (useReducer) for component-level, localStorage for cross-session persistence on critical actions. Clear undo stack on explicit confirmation ("Empty trash permanently") or after reasonable time. Show success message when undo triggered: "Deletion canceled - item restored". Handle edge cases: undo during loading (disable undo button while processing), undo after navigation (warn or clear stack), concurrent actions (maintain order in stack). For collaborative apps, consider server-side undo with operation transforms. ACCESSIBILITY: Announce undo availability and success via aria-live, ensure keyboard shortcut doesnt conflict with browser. Test rapid undo/redo sequences for race conditions.'
      },
      {
        id: 'u14',
        label: 'Autosave',
        simple: 'Save content automatically with status indicator showing save state.',
        detailed: 'Implement autosave with clear status indication. Save automatically on content change with debouncing (1-2 seconds after last edit). Show save status indicator: "Saving..." with spinner, "Saved" with check icon, "Error saving" with retry. Display last saved timestamp ("Last saved 2 minutes ago"). Use optimistic saves - dont block user interaction. Handle offline gracefully - queue saves, sync when online. Add visual pulse or brief highlight when save completes. Store drafts locally as backup. Show unsaved changes warning on navigation ("You have unsaved changes"). Implement conflict resolution for collaborative editing. Allow manual "Save now" option.',
        advanced: 'Implement autosave with clear status indication to eliminate save anxiety. Save automatically on content change with 1-2 second debounce after last edit - balance between data safety and API load. Show save status indicator (fixed position, consistent location): "Saving..." with subtle Loader2 spinner, "Saved" with CheckCircle icon (fade after 2s), "Error saving" with AlertCircle and "Retry" button. Display last saved timestamp: "Last saved 2 minutes ago" using relative time (formatDistanceToNow). Use optimistic saves: update UI immediately, dont block interaction, rollback on error with notification. Handle offline gracefully: detect with navigator.onLine and online/offline events, queue saves to IndexedDB, show offline indicator, sync automatically when online with conflict resolution. Add visual pulse or brief bg-green-50 highlight when save completes for positive feedback. Store drafts locally in localStorage/IndexedDB as backup even when online. Show unsaved changes warning on navigation: beforeunload event + custom in-app navigation guard ("You have unsaved changes. Leave anyway?"). Implement conflict resolution for collaborative: compare timestamps, show diff, let user choose version or merge. Allow manual "Save now" button for user control. Track save frequency and failures for reliability monitoring.'
      },
      {
        id: 'u15',
        label: 'Quick Actions',
        simple: 'Add floating action button with expandable menu for common actions.',
        detailed: 'Add floating action button (FAB) or quick action menu for common operations. Position FAB at bottom-right (fixed bottom-6 right-6). Use Plus icon as default, expand to show multiple actions on click. Animate expansion with stagger effect. Include labels next to icons when expanded. Add speed dial pattern for related actions. Consider context - show different actions on different pages. Include keyboard shortcut hints. Add backdrop overlay when expanded. Close on action selection or outside click. Make FAB draggable on mobile for repositioning. Hide FAB when scrolling down, show when scrolling up. Ensure FAB doesnt cover important content.',
        advanced: 'Add floating action button (FAB) for quick access to primary actions following Material Design patterns. Position FAB at bottom-right (fixed bottom-6 right-6) respecting safe areas (bottom-[calc(1.5rem+env(safe-area-inset-bottom))]). Use Plus icon as default, rotate to X when expanded. Expand to show multiple actions (3-6 max) on click with stagger animation (delay 50ms each). Include labels next to icons when expanded - labels appear from left side. Add speed dial pattern: actions appear in vertical stack, most important closest to FAB. Context-aware: show different actions on different pages/states (Create on dashboard, Edit on detail page). Include keyboard shortcut hints in labels ("New Project (N)"). Add semi-transparent backdrop overlay (bg-black/20) when expanded - click to close. Close on action selection, outside click, Escape key. Consider making FAB draggable on mobile for repositioning - store position in localStorage. Hide FAB on scroll down (scroll-direction detection), show on scroll up for maximum content visibility. CRITICAL: Ensure FAB doesnt cover important content - add padding-bottom to page content, position above bottom navigation if present. ACCESSIBILITY: Use aria-expanded, aria-haspopup, proper focus management when expanded, announce action completion. Add reduced motion support for users with vestibular disorders.'
      },
      {
        id: 'u16',
        label: 'Contextual Menu',
        simple: 'Add right-click context menu with relevant actions for items.',
        detailed: 'Add right-click context menu with relevant actions. Create menu component positioned at cursor location. Include context-specific actions based on clicked element (edit, delete, duplicate, copy link). Show keyboard shortcuts next to menu items. Group related items with dividers. Add icons prefix for visual scanning. Implement submenus for nested options with ChevronRight indicator. Handle viewport boundaries - flip menu direction if needed. Support keyboard navigation within menu. Close on item click, outside click, or Escape. Add mobile support via long-press trigger. Include disabled states with tooltips explaining why.',
        advanced: 'Add right-click context menu with relevant actions for power user efficiency. Create menu component positioned at cursor location using clientX/clientY from contextmenu event. Include context-specific actions based on clicked element: files (open, rename, move, duplicate, delete, copy link), text (copy, cut, paste, select all), items (edit, delete, archive, share). Show keyboard shortcuts right-aligned in menu items (text-gray-400). Group related items with subtle dividers (border-t border-gray-100 my-1). Add icons (w-4 h-4) prefix for visual scanning. Implement submenus for nested options: ChevronRight indicator, submenu appears on hover/arrow-right with 200ms delay. Handle viewport boundaries: calculate available space, flip direction (up/down, left/right) if menu would overflow. Support full keyboard navigation: arrow up/down to move, arrow right to open submenu, arrow left to close submenu, Enter to select, first letter to jump. Close on item click, outside click, Escape, or scroll. Add mobile support: long-press (500ms) triggers menu, position centered above finger. Include disabled states with reduced opacity and cursor-not-allowed, tooltip explaining why on hover. ACCESSIBILITY: role="menu" on container, role="menuitem" on items, aria-disabled for disabled items, proper focus management. Consider right-click alternatives for touchpad/accessibility users.'
      },
      {
        id: 'u17',
        label: 'Keyboard Shortcuts',
        simple: 'Add keyboard shortcuts for common actions with help modal.',
        detailed: 'Implement keyboard shortcuts for power users. Define shortcuts for common actions: Cmd/Ctrl+S (save), Cmd/Ctrl+K (search), Cmd/Ctrl+N (new), Escape (close modals). Create help modal showing all shortcuts - trigger with "?" key. Group shortcuts by category in help modal. Show shortcut hints in tooltips and menus. Handle modifier keys properly (Cmd for Mac, Ctrl for Windows). Prevent conflicts with browser/OS shortcuts. Add visual feedback when shortcut is triggered. Support sequential shortcuts (g then h for go home). Allow customization if applicable. Disable shortcuts when typing in inputs. Use useEffect with keydown listener and proper cleanup.',
        advanced: 'Implement keyboard shortcuts for power users to dramatically increase efficiency. Define shortcuts for common actions: Cmd/Ctrl+S (save), Cmd/Ctrl+K (search/command palette), Cmd/Ctrl+N (new), Escape (close modals), Cmd/Ctrl+/ (toggle sidebar). Create help modal showing all shortcuts - trigger with "?" key (Shift+/). Group shortcuts by category: Navigation, Actions, View, Help. Show shortcut hints in tooltips and menu items - format: "⌘K" on Mac, "Ctrl+K" on Windows (detect with navigator.platform). Handle modifier keys: detect OS, use metaKey for Mac, ctrlKey for Windows - provide consistent UX. Prevent conflicts: avoid Cmd/Ctrl+W/T/N/P that browsers reserve, test across browsers. Add visual feedback: brief flash or ripple on target element when shortcut triggered. Support sequential shortcuts (vim-style): "g then h" for go home - show mode indicator when in sequence. Allow customization if applicable: settings page for remapping, store in localStorage. CRITICAL: Disable shortcuts when typing in inputs, textareas, contenteditable - check event.target.tagName and isContentEditable. Use useEffect with keydown listener on document, proper cleanup to prevent memory leaks, useCallback for stable handler reference. Consider command palette pattern (Cmd+K) for discoverable shortcuts. ACCESSIBILITY: Ensure all shortcut actions are also accessible via mouse/touch.'
      },
      {
        id: 'u18',
        label: 'Recent Items',
        simple: 'Show recently viewed items for quick access.',
        detailed: 'Add recently viewed/used items for quick access. Store recent items in localStorage with timestamp. Display in dropdown, sidebar section, or dedicated page. Show item preview: name, thumbnail/icon, last accessed time. Limit to reasonable count (5-10 items). Update list on each view/use. Add "Clear history" option. Group by type or time period if many items. Include quick actions (open, remove from recent). Handle deleted items gracefully - remove from recent list. Pin frequently used items to top separately. Add search/filter within recent items. Sync across devices if user is logged in.',
        advanced: 'Add recently viewed/used items for quick access reducing navigation friction. Store recent items in localStorage with timestamp and minimal metadata: {id, type, name, thumbnail, accessedAt}. Display in multiple locations: dropdown in header (quick access), sidebar section (persistent visibility), dedicated page (full history). Show item preview: icon/thumbnail (w-8 h-8), name (truncate with ellipsis), relative time ("2 hours ago"). Limit to reasonable count: 5 in dropdown, 10 in sidebar, unlimited on page with pagination. Update list on each view/use: move to top if exists, add if new, respect limit. Add "Clear history" option with confirmation. Group by type (Projects, Documents, People) or time period (Today, Yesterday, This Week) when many items. Include quick actions on hover/focus: Open, Remove from recent, Pin. Handle deleted items gracefully: check existence on display, silently remove stale items. Implement pinned items separately at top - user explicitly pins, different from recent. Add search/filter within recent items on dedicated page. Sync across devices if user logged in: store in backend, merge with localStorage, handle conflicts by most recent. PRIVACY: Clear recent on logout, respect private browsing mode, allow disabling history. Track recent item clicks for personalization insights.'
      },
      {
        id: 'u19',
        label: 'Smart Defaults',
        simple: 'Pre-fill forms with intelligent defaults based on user context.',
        detailed: 'Pre-fill forms with intelligent defaults to reduce cognitive load. Use user profile data for name, email, address fields. Remember last-used selections (payment method, shipping address). Set date pickers to today or logical defaults. Pre-select most popular or recommended options. Use location data for country/timezone when permitted. Remember form state if user navigates away and returns. Provide "Same as previous" options for repeated data.',
        advanced: 'Pre-fill forms with intelligent defaults to reduce cognitive load and completion time. User data: populate from profile (name, email, phone, company). Last-used values: remember previous selections for dropdowns (payment method, shipping address, currency). Date defaults: today for start dates, tomorrow for due dates, common ranges (this week, this month). Popular options: pre-select most common choices with "Most popular" badge. Location intelligence: use IP geolocation or browser geolocation for country, timezone, currency, language - with permission. Session state: persist form data to sessionStorage, restore if user navigates away and returns, clear on successful submit. "Same as" options: "Same as billing address" toggle, "Same as last order". Conditional defaults: different defaults based on user segment (enterprise vs individual). Progressive profiling: dont ask for data you already have. Learn from behavior: if user always changes a default, update their preference. PRIVACY: be transparent about data sources, dont prefill sensitive fields (passwords, SSN). Clear defaults option available. A/B test default choices to optimize completion rates. Accessibility: ensure defaults dont frustrate screen reader users, allow easy clearing.'
      },
      {
        id: 'u20',
        label: 'Inline Editing',
        simple: 'Enable clicking on text to edit it in place without opening a form.',
        detailed: 'Enable inline editing for quick updates. Click on text to switch to edit mode with input replacing text. Show subtle hover indicator that text is editable (cursor, underline, or edit icon). Use Enter to save and Escape to cancel. Show save/cancel buttons for touch users. Auto-focus input on edit mode. Maintain same width to prevent layout shift. Add validation with inline error display. Show brief success indicator after save.',
        advanced: 'Enable inline editing for quick updates without form navigation. Click or double-click on text to switch to edit mode. Hover indicator: show edit icon (Pencil), cursor:pointer, subtle underline, or background highlight. Edit mode: input/textarea replaces text, same font styling, auto-focus with text selected. Save triggers: Enter key (single line), Cmd/Ctrl+Enter (multi-line), blur (auto-save), explicit Save button. Cancel: Escape key, Cancel button, restore original value. Touch users: show explicit Save/Cancel buttons since no blur event on mobile. Width stability: set min-width to prevent layout shift, or use fixed width matching content. Validation: validate on blur/save attempt, show inline error below input, dont close edit mode if invalid. Success feedback: brief checkmark animation, subtle green flash, "Saved" text that fades. Loading state: disable input and show spinner during save. Error handling: show error message, keep edit mode open, allow retry. Optimistic updates: update UI immediately, rollback on error. Keyboard navigation: Tab to move to next editable field. ACCESSIBILITY: ensure edit mode is announced, focus management correct, errors accessible. Consider edit history/undo for critical fields.'
      },
      {
        id: 'u21',
        label: 'Drag and Drop',
        simple: 'Add drag and drop for reordering lists and moving items.',
        detailed: 'Implement drag and drop for intuitive interactions. Add drag handle (grip icon) or make entire item draggable. Show visual feedback on drag: shadow, opacity change, cursor grabbing. Display drop zone indicators (border, background change). Animate items moving aside during drag. Support keyboard alternative for accessibility. Implement drop constraints (valid targets). Handle edge cases: dropping on self, cancelled drags. Save new order after drop. Add touch support with long-press to initiate drag.',
        advanced: 'Implement drag and drop for intuitive reordering and organization. Use library: @dnd-kit/core or react-beautiful-dnd for complex interactions. Drag handle: GripVertical icon on left, cursor: grab, or entire item draggable (touchAction: none). Drag start feedback: item gets shadow-lg, scale(1.02), opacity-90, cursor: grabbing. Drop zone indicators: 2px dashed border, bg-blue-50 on valid targets, visual gap where item will drop. Animate items: other items smoothly translate to make room (transform: translateY), use spring physics for natural feel. Keyboard alternative REQUIRED: Tab to focus item, Space to pick up, arrow keys to move, Space to drop - announce position to screen readers. Drop constraints: define valid targets, show invalid cursor on invalid drop zones, snap back on invalid drop. Edge cases: dropping on self (no-op), drag cancelled (Escape key, restore position), drag out of bounds (return to origin). Save order: persist immediately after drop (optimistic), handle save failure with undo. Touch support: 150-200ms long-press to initiate (avoid conflict with scroll), haptic feedback on pickup. Multi-select drag: Shift+click to select multiple, drag selection together. ACCESSIBILITY: aria-grabbed, aria-dropeffect, live announcements of position. Performance: virtualize long lists during drag.'
      },
      {
        id: 'u22',
        label: 'Infinite Scroll',
        simple: 'Load more content automatically as user scrolls down.',
        detailed: 'Implement infinite scroll for long content lists. Detect scroll position using Intersection Observer. Load more when approaching bottom (threshold before reaching end). Show loading spinner or skeleton at bottom during load. Handle loading states to prevent duplicate fetches. Add "Load more" button as fallback. Show "No more items" when list ends. Implement scroll position restoration on navigation back. Handle errors with retry option. Consider virtualization for very long lists.',
        advanced: 'Implement infinite scroll for seamless content consumption. Use Intersection Observer (not scroll events) for performance: observe sentinel element at end of list, trigger load when intersecting. Threshold: trigger at 200-300px before reaching bottom (rootMargin: "0px 0px 200px 0px"). Loading indicator: spinner or skeleton rows at bottom during load, maintain layout stability. State management: track loading, hasMore, error states, prevent duplicate fetches with loading guard. Fallback: "Load more" button for users who prefer manual control or if Intersection Observer fails. End state: "No more items" or "Youve reached the end" message, remove loading trigger. Scroll restoration: save scroll position to sessionStorage on navigation, restore on back - works with browser back button. Error handling: show error message with "Retry" button, dont break existing content. Virtual scrolling: for very long lists (1000+ items), use react-window or @tanstack/virtual to only render visible items. URL state: optionally reflect current page in URL for shareable links. Performance: debounce/throttle if using scroll events, batch DOM updates. ACCESSIBILITY: announce new content loaded via aria-live, ensure focus doesnt jump unexpectedly. Alternative: pagination with clear page indicators for users who prefer.'
      },
      {
        id: 'u23',
        label: 'Pull to Refresh',
        simple: 'Add pull-to-refresh gesture for mobile content refresh.',
        detailed: 'Implement pull-to-refresh for mobile content updates. Detect pull-down gesture at top of scrollable area. Show pull indicator with progress (arrow that inverts when threshold reached). Release to trigger refresh with spinner animation. Execute refresh action (API call). Return to normal state with updated content. Add subtle haptic feedback at trigger threshold. Prevent overscroll on iOS. Show timestamp of last refresh. Disable during active refresh.',
        advanced: 'Implement pull-to-refresh for mobile content updates following native patterns. Detect pull-down gesture: touch events at top of scroll container, only when scrollTop is 0. Pull indicator: hidden by default, translate-y to reveal as user pulls, progress arrow that rotates/inverts when threshold (~80px) reached. Visual feedback: arrow icon initially, transforms to spinner at release, color transition at threshold. Release behavior: if past threshold, trigger refresh; if not, snap back smoothly. Refresh action: execute async function (API fetch), minimum display time (500ms) to show activity even if fast. Success state: spinner transitions to checkmark briefly, content updates, indicator hides. Failure state: show error indicator, allow immediate retry. Haptic feedback: vibrate briefly at trigger threshold (navigator.vibrate). iOS overscroll: prevent rubber-banding from interfering, use touch-action or overscroll-behavior. Last refresh timestamp: "Updated 2 minutes ago" in subtle text. Disable: prevent pull during active refresh, disable completely during loading states. Implementation: consider libraries like react-pull-to-refresh or custom with touch events. CSS: use transform for GPU acceleration. ACCESSIBILITY: provide manual refresh button for non-touch users.'
      },
      {
        id: 'u24',
        label: 'Gesture Navigation',
        simple: 'Add swipe gestures for navigation and common actions.',
        detailed: 'Implement swipe gestures for natural mobile interactions. Swipe left/right on list items for quick actions (delete, archive, favorite). Swipe between pages/tabs with indicator dots. Edge swipe for back navigation. Implement gesture velocity for natural feel. Show action preview during swipe. Add visual affordances (subtle arrows or hints). Support gesture cancellation (swipe back). Handle conflicts with scroll. Provide button alternatives for accessibility.',
        advanced: 'Implement swipe gestures for natural mobile interactions. Item swipes: left/right on list items reveals action buttons (archive left, delete right), threshold-based action trigger, color-coded backgrounds (green save, red delete). Page swipes: horizontal swipe between pages/tabs, indicator dots show position, snap to page boundaries, velocity-based (fast swipe jumps pages). Edge swipe: back navigation from left edge (iOS pattern), show preview of previous page, velocity threshold for trigger. Gesture physics: velocity detection (fast vs slow swipe), momentum/inertia, spring animation for snap-back. Preview during swipe: show action that will trigger, progressive reveal of action buttons, haptic feedback at trigger threshold. Visual affordances: subtle hints on first use (animated prompt), edge indicators. Gesture cancellation: swipe back past threshold, gesture interrupted by other touch. Scroll conflicts: lock axis after 10px movement in dominant direction (horizontal swipe vs vertical scroll), dead zone for ambiguous angles. Button alternatives REQUIRED: all swipe actions must be accessible via menu/buttons for accessibility and discoverability. Implementation: use react-use-gesture or native touch events, requestAnimationFrame for smooth animations. Disable gestures: respect prefers-reduced-motion, provide toggle in settings. Tutorial: first-time gesture education with skip option.'
      },
      {
        id: 'u25',
        label: 'Command Palette',
        simple: 'Add CMD+K command palette for quick navigation and actions.',
        detailed: 'Implement command palette (CMD+K / Ctrl+K) for power users. Create modal with prominent search input. Search across pages, actions, settings, and content. Show categorized results with icons. Navigate with arrow keys, select with Enter. Display recent commands at top when empty. Include keyboard shortcut hints in results. Add fuzzy search for typo tolerance. Support parameterized commands. Close on selection or Escape. Store frequently used commands.',
        advanced: 'Implement command palette (CMD+K) for power user efficiency and discoverability. Trigger: Cmd/Ctrl+K opens, prevent browser default, global listener with useEffect. Modal: centered, prominent search input, auto-focus, placeholder "Type a command or search...". Search scope: pages/navigation, actions (create, delete, export), settings, recent items, content search. Categorized results: group by type with headers (Navigation, Actions, Settings), icons for each category. Keyboard navigation: arrow up/down moves selection, Enter executes, Tab for autocomplete, Escape closes. Empty state: show recent commands (last 5-10), suggested actions, help text. Results display: icon + title + description + keyboard shortcut (right-aligned), max 10 visible with scroll. Fuzzy search: typo tolerance using libraries like fuse.js, highlight matched characters. Parameterized commands: "go to project [name]", "create [type]" - show parameter input inline. Ranking: weight by recency, frequency, and match quality. Nested menus: some items expand to sub-options (e.g., "Create..." shows types). Loading state: spinner for async searches (content search). Store frequently used: track command usage for personalized ranking. ACCESSIBILITY: role="combobox", aria-expanded, aria-activedescendant, live announce selection. Implementation: consider libraries like cmdk or kbar. Features: plugins for extensibility, theming support.'
      },
      {
        id: 'u26',
        label: 'Skeleton Loading',
        simple: 'Show content placeholder shapes while loading data.',
        detailed: 'Implement skeleton screens for perceived performance. Create placeholder shapes matching actual content layout. Use subtle pulse animation (animate-pulse). Match skeleton dimensions to real content. Show skeletons immediately, replace with content when ready. Create reusable skeleton components (SkeletonText, SkeletonImage). Vary placeholder widths for natural appearance. Handle multiple loading states (initial vs updating). Consider reduced motion preference.',
        advanced: 'Implement skeleton screens for perceived performance improvement. Design principle: skeleton should preview content structure, reducing perceived loading time by 10-20%. Create placeholder shapes: rounded rectangles for text (varying widths for natural look), squares/circles for images, match actual dimensions. Animation: subtle pulse (animate-pulse bg-gray-200), or shimmer sweep (gradient animation left to right). Dimension matching: skeleton heights must match content to prevent layout shift (CLS). Immediate display: show skeleton instantly on mount, transition to content when loaded. Reusable components: SkeletonText (lines prop for multiple lines), SkeletonImage (aspect ratio prop), SkeletonCard (composed skeleton). Variation: randomize text line widths (80%, 60%, 90%) for organic feel, last line shorter. Multiple states: initial load (full skeleton), updating (overlay skeleton or spinner on existing content), error (error state, not skeleton). Compose skeletons: page-level skeleton composing multiple component skeletons. Implementation: Skeleton wrapper component that shows skeleton or children based on loading prop. Reduced motion: for prefers-reduced-motion, use static gray instead of animation. Accessibility: use aria-busy="true" on loading containers, aria-hidden on skeleton elements. Timeout: if loading exceeds 10s, offer retry/cancel instead of endless skeleton.'
      },
      {
        id: 'u27',
        label: 'Smart Suggestions',
        simple: 'Provide intelligent suggestions based on user behavior and context.',
        detailed: 'Provide smart suggestions to guide users. Suggest based on recent activity (continue editing draft). Recommend based on similar users (people like you also...). Show contextual suggestions in empty states. Offer autocomplete in search and inputs. Suggest next actions after completing tasks. Display related items on detail pages. Personalize suggestions based on preferences. Balance suggestions with user autonomy.',
        advanced: 'Provide smart suggestions to reduce cognitive load and drive engagement. Behavioral suggestions: "Continue editing Draft A" based on recent activity, "Complete your profile" for incomplete setup. Collaborative filtering: "Users who viewed X also viewed Y" - requires ML/analytics backend. Contextual suggestions: empty states with relevant suggestions (no projects → templates), inline suggestions during workflows. Autocomplete: search input suggestions from popular queries and user history, form field suggestions from past entries. Next actions: after task completion, suggest logical next step ("Project created. Add team members?"). Related items: on detail pages, show related content (related articles, similar products). Personalization: learn from user behavior (clicks, ignores), segment-based defaults, explicit preference settings. Smart timing: dont show suggestions when user is focused on task, show when idle or at decision points. Dismissibility: allow dismissing suggestions (dont show again), respect dismissals. Explanation: optionally explain why suggesting ("Because you viewed..."). A/B testing: measure suggestion click rates, optimize recommendations. Privacy: be transparent about data use, allow opting out of personalization. Quality over quantity: show 1-3 high-quality suggestions, not a wall of options. Track engagement: measure suggestion acceptance rate to improve algorithms.'
      },
      {
        id: 'u28',
        label: 'Contextual Help',
        simple: 'Provide help content relevant to the current page or feature.',
        detailed: 'Provide contextual help for each feature. Add help icon (?) that opens relevant documentation. Create slideover or panel with help content. Include text explanations, images, and videos. Show keyboard shortcuts for current context. Link to full documentation for more details. Add "Was this helpful?" feedback. Implement search within help content. Show common questions for current area. Remember dismissed help to not repeat.',
        advanced: 'Provide contextual help reducing support burden and user frustration. Help trigger: HelpCircle icon (w-5 h-5 text-gray-400) in page header or near complex features, keyboard shortcut (F1 or ?). Help panel: slide-over from right (w-80) or bottom sheet on mobile, close on X, Escape, or outside click. Content structure: brief explanation, step-by-step for complex tasks, annotated screenshots, short video walkthroughs (30-60s). Context awareness: help content matches current page/feature automatically via route matching. Keyboard shortcuts: list shortcuts relevant to current context, filterable/searchable. Documentation link: "Learn more" links to full docs, open in new tab. Feedback: "Was this helpful?" with Yes/No, optional comment field, track to improve content. Search: search within help content, show results inline, fallback to full docs search. Common questions: FAQ section for current feature, expandable answers. Progressive disclosure: start with basics, "Show advanced" for power user content. Onboarding integration: "Take a tour" option launches guided tour from help panel. Dismissed help: track viewed help articles, show "Whats New" for updates. Content management: help content in CMS or MDX for easy updates. Analytics: track help access patterns to identify confusing features. ACCESSIBILITY: help panel keyboard navigable, content screen reader friendly.'
      },
      {
        id: 'u29',
        label: 'Batch Operations',
        simple: 'Allow selecting multiple items for bulk actions.',
        detailed: 'Enable batch operations for efficiency. Add checkbox to each item for multi-select. Implement "Select All" for current view/page. Show action bar when items selected with count. Provide bulk actions: delete, move, archive, export, edit. Confirm destructive bulk actions with item count. Show progress for long operations. Handle partial failures gracefully. Support keyboard selection (Shift+click range). Clear selection after action or explicit dismiss.',
        advanced: 'Enable batch operations for power user efficiency. Selection UI: checkbox on each item (left side), checkbox in header for "Select All", indeterminate state when partial selection. Select All options: "Select all on page" vs "Select all X items" (across pages) - clear distinction. Action bar: sticky bar appears when items selected, shows count ("3 selected"), provides bulk actions, "Cancel" or "Clear selection" option. Bulk actions: delete, archive, move to folder, add/remove tags, export, change status - context-dependent. Confirmation: for destructive actions, modal showing "Delete 47 items?" with count, require explicit confirmation. Progress: for long operations (>2s), show progress bar with count ("Deleting 15 of 47..."), allow cancellation. Partial failures: show success count and failure count, list failed items with reasons, offer retry for failures. Selection methods: click checkbox (single), Shift+click (range from last selected), Cmd/Ctrl+click (toggle), Shift+arrow keys (keyboard range). Clear selection: after successful action, on navigation, explicit clear button. Persistence: maintain selection across pagination (store selected IDs). Performance: handle thousands of selected items without lag. ACCESSIBILITY: announce selection count changes, announce action results. Mobile: long-press to enter selection mode, bottom action bar.'
      },
      {
        id: 'u30',
        label: 'Preference Memory',
        simple: 'Remember user preferences like view mode, sort order, and filters.',
        detailed: 'Remember user preferences across sessions. Store view preferences (grid vs list view). Remember sort order and direction. Persist filter selections. Save column visibility and order in tables. Remember sidebar collapsed/expanded state. Store per-page items count preference. Save dark/light mode preference. Sync preferences across devices if logged in. Provide reset option for defaults.',
        advanced: 'Remember user preferences for personalized consistent experience. View preferences: grid vs list view (per section), remember last used. Sort preferences: remember sort column and direction per list/table. Filters: persist active filters per context, option to save filter presets. Table customization: column visibility, column order, column widths - save and restore. UI state: sidebar collapsed/expanded, panel sizes, accordion states. Pagination: remember items per page preference globally. Theme: dark/light/system mode, accent color choices. Regional: timezone, date format, number format, language. Storage locations: localStorage for device-specific, backend for cross-device (logged-in users). Sync strategy: localStorage as cache, backend as source of truth, merge on login. Reset option: "Reset to defaults" per section and global, confirm before clearing. Migration: handle preference schema changes gracefully. Privacy: preferences are personal data, handle appropriately. Initial state: sensible defaults when no preferences stored. Preference UI: dedicated settings page and inline controls (e.g., view toggle). Performance: lazy load preferences, dont block initial render. ACCESSIBILITY: respect browser preferences (reduced-motion, high-contrast) as defaults.'
      },
      {
        id: 'u31',
        label: 'Optimistic Updates',
        simple: 'Update UI immediately before server confirmation for faster feel.',
        detailed: 'Implement optimistic UI updates for perceived speed. Update UI immediately on user action. Show pending state subtly (reduced opacity, progress indicator). Confirm with server in background. Revert on failure with error message. Handle race conditions with concurrent updates. Queue updates if offline. Maintain data consistency. Add undo option for accidental actions.',
        advanced: 'Implement optimistic UI updates for near-instant perceived performance. Immediate update: on action (like, save, delete), update UI instantly without waiting for server. Pending indicator: subtle feedback that sync is in progress (small spinner, opacity change, status text). Background sync: send request to server while UI is already updated. Success handling: often no change needed, optionally update with server-returned data (IDs, timestamps). Failure handling: revert UI to previous state, show error toast with details, offer retry. Race conditions: handle concurrent updates (multiple quick clicks, slow network), use timestamps or version numbers. Offline queue: if offline, queue updates with timestamp, sync when online in order, handle conflicts. Data consistency: ensure local state matches server truth eventually, handle edge cases (item deleted by another user). Undo integration: optimistic delete with undo option (dont hit server until undo timeout expires). Implementation patterns: React Query mutations with optimisticUpdate, Redux with pending/success/failure pattern. Considerations: not all actions should be optimistic (financial, irreversible), evaluate per action type. Animation: optimistic updates can have subtle animations, reverts should be clear but not jarring. Testing: test slow network, failures, offline scenarios thoroughly.'
      },
      {
        id: 'u32',
        label: 'Micro-copy',
        simple: 'Write helpful, friendly UI text for buttons, labels, and messages.',
        detailed: 'Craft thoughtful micro-copy throughout the interface. Write action-oriented button labels (Save Changes not Submit). Use friendly, human error messages. Add helpful placeholder text in inputs. Include instructional helper text below complex fields. Write encouraging empty states. Use consistent terminology throughout. Match brand voice and tone. Consider internationalization. A/B test critical copy.',
        advanced: 'Craft thoughtful micro-copy that guides and reassures users. Button labels: action-oriented and specific ("Save Changes" not "Submit", "Send Invite" not "OK"), indicate outcome. Error messages: friendly, specific, actionable ("Couldnt save. Check your connection and try again" not "Error 500"). Placeholder text: helpful examples ("Enter your email"), disappears on focus, never critical info. Helper text: appears below complex fields, explains format/requirements ("Password must be 8+ characters with a number"). Empty states: encouraging and actionable ("No projects yet. Create your first one to get started!"). Confirmation messages: acknowledge action completed ("Changes saved", "Email sent to 3 recipients"). Loading messages: reduce anxiety ("Loading your dashboard..." not just spinner). Tooltips: concise explanations, no redundant info. Terminology: create glossary, use consistently (always "project" not sometimes "project" sometimes "workspace"). Brand voice: match overall brand tone (professional, friendly, playful), documented guidelines. Internationalization: write copy that translates well, avoid idioms and culturally specific references. A/B testing: test button copy, error messages, CTAs for conversion. Character limits: consider mobile, truncation, translation expansion (German is ~30% longer). ACCESSIBILITY: screen reader friendly, avoid placeholder as label.'
      },
      {
        id: 'u33',
        label: 'Feature Discovery',
        simple: 'Help users discover new and hidden features.',
        detailed: 'Help users discover features they might miss. Add "New" badges on recently added features. Show feature announcements for significant updates. Include "Did you know?" tips periodically. Highlight unused features in empty states. Add progressive feature introduction. Create feature discovery checklist. Use contextual prompts when relevant. Show keyboard shortcuts in menus. Track feature adoption for insights.',
        advanced: 'Help users discover features to increase engagement and reduce churn. "New" badges: pill badge on new features (show for 2 weeks or until clicked), subtle to avoid overwhelming. Announcements: modal or banner for significant releases, "Whats New" page with release notes, in-app changelog. "Did you know?" tips: non-intrusive tips shown periodically (max 1 per session), relevant to current context, dismissible (permanently). Empty state suggestions: when user has unused feature, suggest in related empty state ("Try our new templates"). Progressive introduction: dont show all features at once, introduce advanced features after mastering basics. Discovery checklist: optional checklist of features to explore, reward completion (badge, discount). Contextual prompts: when user is doing something the hard way, suggest easier approach ("You can also drag and drop"). Shortcut hints: keyboard shortcuts in menu items and tooltips, cheatsheet accessible via ?. Adoption tracking: analytics on feature usage, identify underused features, inform roadmap. Segmentation: different discovery paths for different user types. Frequency capping: limit total prompts per session (max 2-3), respect "dont show again". A/B testing: test prompt timing, wording, UI patterns. ACCESSIBILITY: prompts keyboard dismissible, not blocking critical paths. Balance: help without annoying - err on side of fewer prompts.'
      },
      {
        id: 'u34',
        label: 'Version History',
        simple: 'Show history of changes with ability to view and restore previous versions.',
        detailed: 'Implement version history for content recovery. Track changes automatically on each save. Store timestamps and user who made changes. Create timeline or list view of versions. Enable viewing any previous version. Allow comparing versions (diff view). Provide restore to previous version option. Set retention policy (keep last N versions or time-based). Show changes summary for each version. Handle merge conflicts when restoring.',
        advanced: 'Implement version history for content recovery and collaboration transparency. Automatic tracking: save new version on significant changes (save, not every keystroke), include timestamp and user. Storage strategy: full snapshots vs diffs (based on content type and size), retention policy (last 100 versions, or 90 days, or per-plan limit). Version list UI: timeline or list view, show date, user avatar/name, brief change summary, current version highlighted. View previous: click to view read-only previous version, clear indicator that viewing history not current. Compare (diff): show side-by-side or inline diff, highlight additions (green) and deletions (red), toggle between views. Restore: prominent "Restore this version" button, confirmation dialog, creates new version (doesnt delete history). Named versions: allow naming important versions ("Before redesign"), show starred versions prominently. Change summary: auto-generate ("Added 3 paragraphs, removed 1 image") or user-provided commit message. Branching (advanced): create branch from version, merge branches with conflict resolution. Storage optimization: compress old versions, deduplicate similar content. Collaborative awareness: show when viewing version modified by others. ACCESSIBILITY: version comparison accessible to screen readers. Export: download specific version. Conflict resolution: if restoring while others editing, handle gracefully.'
      },
      {
        id: 'u35',
        label: 'Collaborative Indicators',
        simple: 'Show who else is viewing or editing the same content.',
        detailed: 'Show real-time collaboration awareness. Display avatars of users viewing same page. Show cursor positions in collaborative editing. Indicate when someone is typing in shared inputs. Use colored highlights per user. Show user status (viewing, editing, idle). List online collaborators in sidebar. Notify when changes are made by others. Handle conflict resolution. Show "last edited by" information.',
        advanced: 'Show real-time collaboration awareness for team productivity. Presence indicators: avatar stack showing users on same page (max 3 + "+2" overflow), colored rings per user, tooltip with names. Live cursors: in collaborative docs/canvas, show labeled cursors with user name, colored per user, fade when idle >30s. Typing indicators: "Alex is typing..." for chat/comments, "3 people editing" for docs. Per-element highlights: colored border/background on elements being edited by others (prevent conflicts). User status: online (solid dot), idle (hollow dot), editing (typing indicator), offline (gray). Collaborator list: sidebar or panel showing all collaborators, their current position/section, click to navigate to them. Change notifications: toast when others make changes ("Sarah added a comment"), dont interrupt focused work. Conflict handling: last-write-wins with notification, or operational transform for true real-time, or explicit merge UI. "Last edited by": show in metadata, hover for timestamp. Implementation: WebSocket for real-time, presence heartbeat (every 30s), cleanup stale presence. Performance: throttle cursor updates (50-100ms), batch presence updates. Privacy: option to go "invisible", respect if feature disabled. Offline: graceful degradation, sync on reconnect with conflict resolution.'
      },
      {
        id: 'u36',
        label: 'Feedback Collection',
        simple: 'Gather user feedback through ratings, surveys, and feedback buttons.',
        detailed: 'Implement feedback collection touchpoints. Add persistent feedback button (edge-fixed). Create quick emoji or star rating after actions. Build NPS survey triggered periodically. Include contextual feedback for specific features. Add bug report form with automatic context. Implement screenshot capture for visual feedback. Thank users after submission. Track feedback for product improvement. Close the loop by updating users on addressed feedback.',
        advanced: 'Implement feedback collection to inform product decisions. Persistent feedback button: fixed edge button ("Feedback"), expands to form, captures URL and user context automatically. Quick ratings: 5-star or emoji after key actions (completed task, closed ticket), optional comment follow-up if low rating. NPS survey: triggered periodically (not more than once per quarter), after milestone (paid, 30 days active), score + "Why?" follow-up. Contextual feedback: "Rate this feature" on specific pages, appears after 3+ uses. Bug reports: structured form (what happened, expected, steps to reproduce), auto-capture browser, OS, URL, user ID, console errors. Screenshot tool: capture and annotate, highlight areas, blur sensitive info automatically. Submission experience: acknowledge immediately ("Thanks for your feedback!"), set expectation ("We review all feedback"). Context capture: include session replay ID, recent actions, feature flags active. Prioritization: categorize by theme, impact, sentiment, route to appropriate team. Close the loop: if acting on feedback, notify the user ("We fixed the bug you reported"), in-app changelog mentioning community input. Privacy: explain what context is captured, allow opt-out. Rate limiting: prevent spam, cap submissions per user. Analytics: feedback sentiment trends, correlation with churn/retention.'
      },
      {
        id: 'u37',
        label: 'Smart Notifications',
        simple: 'Send relevant notifications at appropriate times without overwhelming.',
        detailed: 'Design thoughtful notification system. Categorize by urgency (critical, informational, promotional). Allow per-category preferences. Batch non-urgent notifications into digests. Respect quiet hours and user timezone. Show notification preview before enabling. Throttle to prevent fatigue. Make notifications actionable. Provide clear unsubscribe options. Track engagement for optimization.',
        advanced: 'Design thoughtful notification system balancing engagement with respect for attention. Categorization: critical (security, billing - always on), transactional (receipts, confirmations), activity (comments, mentions), informational (tips, updates), marketing (promotions) - each has different urgency and opt-out rules. Preferences UI: granular controls per category, delivery method per category (push, email, in-app), frequency options (instant, daily digest, weekly digest). Batching: non-urgent notifications batched into digest (daily summary email), intelligent grouping ("5 new comments on your posts"). Timing: respect timezone (never notify at 3am), quiet hours setting (default 10pm-8am local), learn engagement patterns (send when user typically active). Preview: show sample notification before enabling push, explain value proposition. Throttling: cap notifications per hour/day, prioritize high-value notifications. Actionable: include direct actions in notification (Approve button, Reply field), deep-link to exact content. Unsubscribe: one-click unsubscribe in emails, "Reduce frequency" option before full unsubscribe, explain what youll miss. Engagement tracking: open rates, action rates, unsubscribe rates - optimize send timing, content, frequency. Smart suppression: if user just viewed in-app, dont send push for same thing. A/B testing: test subject lines, timing, content. GDPR/CAN-SPAM: proper consent, easy opt-out, preference center.'
      },
      {
        id: 'u38',
        label: 'Performance Perception',
        simple: 'Use techniques to make the app feel faster than actual load times.',
        detailed: 'Optimize perceived performance beyond actual speed. Prefetch likely next pages on hover. Use skeleton screens instead of spinners. Show progress for long operations. Optimistic UI updates. Animate loading content into view. Defer non-critical content. Lazy load below-fold content. Cache previously viewed content. Use service worker for offline and speed. Show last-known state while refreshing.',
        advanced: 'Optimize perceived performance to make app feel faster. Prefetching: on hover over links (after 100ms), prefetch page data, use Intersection Observer for visible links. Skeleton screens: show content shape immediately, reduces perceived wait vs spinner (feels 10-20% faster). Progress indication: determinate progress bars (54%) feel faster than indeterminate spinners, break long operations into stages. Optimistic updates: update UI before server confirms, feels instant for common actions (likes, saves). Animation: content animating in feels faster than instant appear, stagger list items (50ms delay each). Defer non-critical: load analytics, tracking, chat widgets after main content. Lazy loading: images below fold load on scroll, heavy components load when needed. Caching strategy: memory cache for session, localStorage for persistence, stale-while-revalidate for freshness with speed. Service worker: cache app shell, offline fallback, background sync. Stale state: show cached/previous data immediately while fetching fresh data (show refresh indicator). Priority hints: fetchpriority="high" for critical resources, low for defer. Streaming: stream long responses, show partial content as it arrives. Skeleton-to-content transition: smooth crossfade, not jarring replacement. Metrics: track and optimize Core Web Vitals (LCP, FID, CLS). User research: perceived performance often matters more than actual - test with real users.'
      }
    ]
  };
