import type { PromptCategory } from '../types';

export const animationCategory: PromptCategory = {
  id: 'animation',
  name: 'Animation',
  icon: 'Zap',
  description: 'Motion and transitions',
  prompts: [
    {
      id: 'a1',
      label: 'Micro-interactions',
      simple: 'Add subtle micro-interactions to buttons, inputs, and interactive elements.',
      detailed: 'Add subtle micro-interactions to all interactive elements. Buttons: scale down slightly on press (active:scale-95), lift on hover (hover:-translate-y-0.5). Inputs: smooth border color transition on focus (transition-colors duration-200). Checkboxes/toggles: smooth state change with spring-like feel. Links: underline slide-in animation on hover. Icons: gentle rotation or bounce on interaction. Form submit: button loading state with spinner. Success states: checkmark draw animation. Use consistent timing (200-300ms) and easing (ease-out for enter, ease-in for exit). Keep animations subtle - enhance, don\'t distract.',
      advanced: 'Add subtle micro-interactions to all interactive elements for a polished, premium feel. Buttons: scale down slightly on press (active:scale-95 transition-transform duration-75), lift on hover (hover:-translate-y-0.5 hover:shadow-md transition-all duration-200). Inputs: smooth border color transition on focus (transition-colors duration-200 focus:border-blue-500 focus:ring-2 focus:ring-blue-500/20). Checkboxes/toggles: smooth state change with spring-like feel - use cubic-bezier(0.68, -0.55, 0.265, 1.55) for bounce. Links: underline slide-in animation on hover using pseudo-element width from 0 to 100% with transition-all. Icons in buttons: gentle rotation (hover:rotate-12) or bounce on interaction. Form submit button: loading state with Loader2 icon using animate-spin, maintain button width with min-w. Success states: checkmark draw animation using SVG stroke-dasharray and stroke-dashoffset. Error states: subtle shake animation using keyframes translateX(-2px, 2px). Use consistent timing functions: ease-out for enter animations, ease-in for exit. Performance: use transform and opacity only, add will-change on hover for GPU acceleration. CRITICAL: respect prefers-reduced-motion - wrap all motion in motion-safe: or check media query. Keep animations subtle (max 300ms) - they should enhance UX, not distract from content.'
    },
    {
      id: 'a2',
      label: 'Page Transitions',
      simple: 'Add smooth fade and slide transitions between pages.',
      detailed: 'Implement smooth transitions between pages/views. Add fade transition (opacity 0 to 1) with duration-300 as base. Include slide animations: slide-in-from-right for forward navigation, slide-in-from-left for back. Use scale transitions for modals (scale-95 to scale-100 with opacity). Add exit animations before new content loads. Implement shared element transitions where elements persist across pages. Use transform and opacity for GPU-accelerated performance. Add loading state between page transitions. Consider reduced motion preferences with prefers-reduced-motion media query. Stagger content elements appearing on new page.',
      advanced: 'Implement smooth transitions between pages/views for seamless navigation experience. Base transition: fade (opacity 0 to 1) with duration-300 ease-out as foundation. Directional slides: slide-in-from-right (translate-x-4 to translate-x-0) for forward navigation, slide-in-from-left for back navigation - track navigation direction in state. Modal transitions: scale-95 opacity-0 to scale-100 opacity-100 with backdrop fade. Exit animations: animate-out before new content loads - fade-out slide-out-to-left for leaving page. Shared element transitions: identify persistent elements (header, nav) with layout IDs, interpolate position/size between states - consider Framer Motion layoutId or View Transitions API. Loading state: skeleton of target page during transition, or progress bar at top. Route-based configuration: different transitions for different route patterns (modals, drawers, full pages). GPU acceleration: use transform and opacity exclusively, add will-change: transform opacity on animating elements. Stagger content: child elements appear sequentially (delay-75, delay-150) after container transitions in. PERFORMANCE: keep total transition under 400ms, test on low-end devices. ACCESSIBILITY: wrap all in prefers-reduced-motion check - provide instant transition fallback. Handle browser back/forward: maintain transition direction consistency. Consider page scroll: reset to top or preserve scroll position based on navigation type.'
    },
    {
      id: 'a3',
      label: 'Scroll Animations',
      simple: 'Add fade-in animations when elements scroll into view.',
      detailed: 'Add scroll-triggered reveal animations using Intersection Observer API. Create reusable animation component that observes element visibility. Default animation: fade up (opacity-0 translate-y-4 to opacity-100 translate-y-0). Add variants: fade-left, fade-right, scale-up, blur-in. Trigger when element is 20% visible (threshold: 0.2). Add stagger delays for grouped elements (delay-100, delay-200, delay-300). Use once option to animate only on first scroll. Implement parallax speed variations for layered depth. Add progress-based animations that animate as user scrolls through section. Respect prefers-reduced-motion - use simple fade or no animation.',
      advanced: 'Add scroll-triggered reveal animations using Intersection Observer API for engaging storytelling. Create reusable ScrollReveal component: accepts children, animation variant, threshold, delay props. Observer setup: new IntersectionObserver with configurable threshold (default 0.2 = 20% visible), rootMargin for early trigger ("-50px"). Animation variants: fade-up (opacity-0 translate-y-8 to visible), fade-left/right (translate-x-8), scale-up (scale-95), blur-in (blur-sm to blur-0), clip-reveal (clip-path animation). Initial state: set via CSS class, remove class when observed to trigger transition. Stagger groups: parent component passes index to children, each child calculates delay: style={{transitionDelay: `${index * 100}ms`}}. Once option: observer.unobserve(entry.target) after first intersection. Progress-based animations: calculate scroll progress through section (0-1), use for parallax, progress bars, fade intensity - update in scroll event with requestAnimationFrame. Parallax layers: different translateY speeds based on data-speed attribute. Performance optimization: use CSS transitions not JS animation, batch DOM reads/writes, throttle scroll handlers to 60fps. Intersection Observer threshold array [0, 0.25, 0.5, 0.75, 1] for progress tracking. ACCESSIBILITY: @media (prefers-reduced-motion: reduce) { .scroll-animate { transition: opacity 0.3s; transform: none !important; }} - provide simple fade or instant appearance. Mobile: consider disabling complex animations on touch devices for battery. Debug: add outline during development to visualize observed elements.'
    },
    {
      id: 'a4',
      label: 'Hover Effects',
      simple: 'Add lift, shadow, and scale effects on hover.',
      detailed: 'Create engaging hover effects for interactive elements. Cards: lift effect with shadow increase (hover:-translate-y-2 hover:shadow-xl). Add image zoom within card (overflow-hidden with hover:scale-105 on image). Buttons: background color shift, border glow, or gradient animation. Links: animated underline using pseudo-element width transition. Navigation items: background slide-in from left. Images: subtle brightness/contrast change or color overlay fade. Icons: rotation, bounce, or color fill animation. Add smooth transitions (duration-200 to duration-300). Use transform and opacity for best performance. Consider touch devices - add active states as alternative.',
      advanced: 'Create engaging hover effects for interactive elements that feel responsive and delightful. Cards: lift effect with shadow progression (hover:-translate-y-2 hover:shadow-xl transition-all duration-300), subtle border color change on hover. Image zoom within cards: overflow-hidden on container, image with group-hover:scale-110 transition-transform duration-500 ease-out. Buttons: background color shift (hover:bg-blue-700), border glow using box-shadow (hover:shadow-[0_0_20px_rgba(59,130,246,0.4)]), gradient position animation (background-size: 200% with hover:bg-right). Links: animated underline using pseudo-element - ::after with w-0 hover:w-full transition-all, positioned absolute bottom-0. Navigation items: background slide-in from left using ::before with scaleX(0) hover:scaleX(1) origin-left. Images: subtle brightness change (hover:brightness-110), grayscale to color (grayscale hover:grayscale-0), color overlay fade (overlay absolute opacity-0 hover:opacity-30). Icons: rotation (hover:rotate-12), bounce using keyframes, fill color animation (hover:fill-current). 3D tilt on hover: calculate mouse position within card, apply perspective and rotateX/Y based on position. PERFORMANCE: use transform and opacity exclusively for GPU acceleration, add transition-property specifically (not transition-all when possible), will-change: transform on hover. Touch devices: add active: states as alternatives (active:scale-95), disable hover effects that don\'t work well on touch (title attribute tooltips). State layering: combine hover with focus-visible for keyboard users. Prevent hover on touch: @media (hover: hover) { .hover-effect:hover { ... } }.'
    },
    {
      id: 'a5',
      label: 'Loading Animations',
      simple: 'Create spinner, skeleton, and progress bar loading states.',
      detailed: 'Create polished loading animations for various contexts. Spinner: rotating circle using animate-spin with Loader2 icon or custom SVG. Progress bar: animated width with gradient shimmer overlay moving left to right. Skeleton screens: pulsing gray shapes (animate-pulse) matching content layout exactly. Dots loader: three dots with staggered bounce animation. Logo loader: brand logo with pulse or morph animation. Button loading: replace text with spinner, maintain button width. Full page loader: centered spinner with optional loading message and progress percentage. Add minimum display time (400ms) to prevent flash. Use CSS animations for smooth 60fps performance.',
      advanced: 'Create polished loading animations for various contexts with appropriate feedback levels. Spinner variations: rotating circle using Loader2 with animate-spin, custom SVG with animated stroke-dashoffset for drawing effect, dual-ring spinner with counter-rotation. Progress bar: determinate (width transition) and indeterminate (gradient shimmer using @keyframes translateX from -100% to 100%), include percentage text and ETA when available. Skeleton screens: pulsing gray shapes (bg-gray-200 animate-pulse) matching EXACT content layout - same heights, widths, spacing as real content; use rounded corners matching text (rounded for text, rounded-full for avatars). Dots loader: three dots with staggered bounce using animation-delay (0s, 0.2s, 0.4s). Logo loader: brand logo with subtle pulse (scale 1 to 1.05) or drawing animation. Button loading: replace text with Loader2 animate-spin, maintain button width with min-w-[original-width] to prevent layout shift, disable button during load. Full page loader: fixed inset-0 flex items-center justify-center, centered spinner with loading message below, include progress percentage if available, subtle background blur on content behind. Loading states hierarchy: button spinner (inline), content skeleton (area), overlay loader (blocking), progress bar (known duration). CRITICAL: minimum display time (400ms) to prevent flash for fast loads - use setTimeout or Promise.all([fetch, delay]). Performance: CSS animations only, avoid JS-driven animations, use @keyframes with transform. Accessibility: aria-busy="true" on loading container, aria-live="polite" for status updates, visually hidden text describing loading state.'
    },
    {
      id: 'a6',
      label: 'Button Animations',
      simple: 'Add press, hover, and loading animations to buttons.',
      detailed: 'Add satisfying button interactions that feel responsive. Press effect: scale down on active (active:scale-95) with quick duration-75. Hover: subtle lift (-translate-y-0.5) or background brightness change. Ripple effect: expanding circle from click point using pseudo-element or span. Add ripple with absolute positioning, scale animation (scale-0 to scale-100), and opacity fade. Loading state: smooth transition to spinner, maintain dimensions. Success state: button turns green with checkmark icon, then returns to normal. Disabled state: reduced opacity with not-allowed cursor. Use will-change: transform for performance. Add focus-visible ring for accessibility.',
      advanced: 'Add satisfying button interactions that feel responsive and provide clear feedback. Press effect: scale down on active (active:scale-95 transition-transform duration-75) - quick duration feels snappy. Hover: subtle lift (hover:-translate-y-0.5 hover:shadow-md) or background brightness (hover:brightness-110). Ripple effect implementation: create span on click at pointer position relative to button, apply scale(0) to scale(4) animation with opacity 0.3 to 0 over 600ms, remove span after animation completes; position button as relative, ripple as absolute with pointer-events-none. Material ripple: use ::after pseudo-element for simpler implementation, trigger via :active state. Loading state: smooth transition to spinner (fade text out, fade spinner in), maintain exact button dimensions with explicit width/height or min-w, disable pointer events during load. Success/error states: background color transition (bg-green-600 or bg-red-600), icon swap (Check or X icon), hold for 2 seconds, transition back to original state. Disabled state: opacity-50 cursor-not-allowed, remove all hover/active effects. Icon animations: icon rotates (rotate-180) or slides (translate-x) on hover for arrow buttons. Group hover: button with icon, icon moves on button hover using group and group-hover:translate-x-1. PERFORMANCE: will-change: transform on interactive elements, use transform and opacity for all animations. ACCESSIBILITY: focus-visible:ring-2 focus-visible:ring-offset-2 for keyboard focus, maintain 44x44px minimum touch target, announce loading state with aria-busy. Reduced motion: remove transform animations, keep color feedback only.'
    },
    {
      id: 'a7',
      label: 'Card Animations',
      simple: 'Add hover lift, image zoom, and content reveal to cards.',
      detailed: 'Implement engaging card hover and interaction animations. Lift effect: translate-y and increased shadow (hover:-translate-y-2 hover:shadow-2xl). Image zoom: overflow-hidden on card, scale image on hover (group-hover:scale-110). Content reveal: show additional info or actions on hover with slide-up animation. Border glow: animated gradient border or shadow glow effect. Tilt effect: 3D perspective rotation following cursor position using transform: perspective() rotateX() rotateY(). Flip card: 3D flip to reveal back content on click. Add smooth transitions (duration-300) with ease-out timing. Use group utility for coordinated child animations. Include skeleton loading state for card content.',
      advanced: 'Implement engaging card hover and interaction animations for dynamic, interactive layouts. Lift effect: translate-y and shadow progression (hover:-translate-y-3 hover:shadow-2xl transition-all duration-300 ease-out). Image zoom: card with overflow-hidden rounded-t-lg, image with transition-transform duration-500 group-hover:scale-110. Content reveal: hidden content positioned absolute bottom-0, transform translate-y-full to translate-y-0 on hover with opacity transition; or max-height animation from 0 to auto using grid-rows technique. Border glow: animated gradient border using background linear-gradient with animation rotating the angle, or box-shadow with colored blur (hover:shadow-[0_0_30px_rgba(59,130,246,0.3)]). 3D Tilt effect: track mouse position within card using onMouseMove, calculate rotation angles based on position relative to center, apply transform: perspective(1000px) rotateX(Ydeg) rotateY(Xdeg), reset on mouse leave with smooth transition. Flip card: preserve-3d on container, front and back faces with backface-visibility-hidden, rotate-y-180 on back, hover/click toggles rotate-y-180 on container. Card variants: vertical stack that fans out on hover, horizontal scroll with active card scaling up. Skeleton loading: exactly match card layout with bg-gray-200 animate-pulse shapes, transition to real content with fade. PERFORMANCE: use group utility for coordinated animations, will-change on hover, avoid animating layout properties (width, height - use transform instead). Click feedback: brief scale-95 on mousedown. ACCESSIBILITY: ensure content reveal doesn\'t hide critical information, provide alternative access for keyboard/touch users. Mobile: adapt hover effects to touch with active states or tap-to-reveal.'
    },
    {
      id: 'a8',
      label: 'Staggered Animations',
      simple: 'Add sequential entrance animations to lists and grids.',
      detailed: 'Implement staggered entrance animations for lists and grids. Apply incremental delays to child elements: first child delay-0, second delay-75, third delay-150, etc. Use CSS custom properties for dynamic delays based on index (style={{animationDelay: `${index * 100}ms`}}). Create fade-up animation that each item plays in sequence. Limit total stagger time - cap at 5-6 items then batch. Add intersection observer to trigger only when container is visible. Implement reverse stagger for exit animations. Use for: grid cards, list items, navigation menus, table rows. Keep individual animation short (200-300ms) so sequence feels snappy. Reset animation state properly when content changes.',
      advanced: 'Implement staggered entrance animations for lists and grids creating a cascade reveal effect. Delay calculation: style={{animationDelay: `${index * 75}ms`}} or use CSS custom property --stagger-delay: calc(var(--index) * 75ms). Tailwind approach: [&:nth-child(1)]:delay-0 [&:nth-child(2)]:delay-75 [&:nth-child(3)]:delay-150 for static lists. Animation keyframes: @keyframes stagger-in { from { opacity: 0; transform: translateY(20px); } to { opacity: 1; transform: translateY(0); } }. Apply animation: animation: stagger-in 300ms ease-out forwards, keep in initial hidden state with opacity-0. Grid stagger patterns: sequential (left to right, top to bottom), diagonal (top-left to bottom-right), center-out (middle items first). Cap total stagger duration: for 20+ items, batch into groups of 5-6 with same delay within batch, or use shorter delays (30-50ms). Intersection Observer trigger: observe container, when visible add .animate class that triggers children animations, prevents animation before scrolled into view. Exit animations: reverse stagger with shorter duration (150ms), last item animates first on exit. Content change handling: when data updates, reset animation state by toggling key prop or removing/re-adding animation class. Performance: CSS animations only, avoid animating layout properties, use will-change: transform, opacity on animating elements. ACCESSIBILITY: prefers-reduced-motion users get instant appearance (animation: none). Use cases: card grids, navigation dropdowns, search results, table rows, notification lists. React implementation: pass index to children via context or clone with props, or use CSS nth-child for static markup.'
    },
    {
      id: 'a9',
      label: 'Parallax Effects',
      simple: 'Add parallax scrolling with layers moving at different speeds.',
      detailed: 'Add parallax scrolling for depth and visual interest. Create layers that move at different speeds: background (slow, 0.3x), midground (medium, 0.6x), foreground (normal, 1x). Calculate position based on scroll: translateY(scrollY * speed). Use transform for GPU acceleration. Add parallax to: hero background images, floating decorative elements, section backgrounds. Implement horizontal parallax for side-scrolling effects. Use requestAnimationFrame for smooth 60fps updates. Add bounds to prevent elements from moving too far. Consider mobile - reduce or disable parallax for performance and motion sensitivity. Provide fallback static positioning. Test performance and reduce complexity if janky.',
      advanced: 'Add parallax scrolling for depth and visual interest creating immersive experiences. Layer system: define speed multipliers - background (0.2-0.3x), midground (0.5-0.6x), foreground (0.8-1x), with optional negative values for reverse parallax. Position calculation: translateY((scrollY - elementOffsetTop) * speed), account for element\'s position in document. Implementation pattern: useEffect with scroll listener, store scrollY in ref, use requestAnimationFrame for smooth 60fps updates, calculate transform in rAF callback. CSS variables approach: set --scroll-y on scroll, use in CSS calc(var(--scroll-y) * 0.3px) for each layer. Apply parallax to: hero background images (slow rise), floating decorative elements (varied speeds create depth), section backgrounds, text layers. Horizontal parallax: translateX for side-scrolling effects, triggered by vertical scroll. Bounds and constraints: clamp movement within reasonable range to prevent elements leaving viewport, use Math.max/min. Performance optimization: throttle scroll handler calculation (not the rAF), use transform exclusively (not top/left), add will-change: transform only during scroll (remove on scroll end), consider Intersection Observer to disable parallax for off-screen sections. MOBILE: reduce parallax intensity (half speeds) or disable entirely for battery and motion sensitivity - check window.matchMedia("(prefers-reduced-motion: reduce)") and touch device. Fallback: static positioning for reduced motion preference. Advanced effects: parallax fade (opacity tied to scroll progress), parallax scale, parallax blur for depth of field effect. Testing: verify smooth 60fps on mid-range devices, reduce complexity if janky. Libraries: consider Lenis, Locomotive Scroll for complex implementations with smooth scroll integration.'
    },
    {
      id: 'a10',
      label: 'Morphing Icons',
      simple: 'Create smooth transitions between icon states (hamburger to X, play to pause).',
      detailed: 'Create smooth icon morphing transitions between states. Hamburger to X: animate three lines - top rotates 45deg down, middle fades out, bottom rotates -45deg up. Play to Pause: triangle morphs to two rectangles using SVG path animation or separate elements. Plus to Minus: vertical line shrinks to 0 while horizontal stays. Arrow directions: rotate transform between states (rotate-90, rotate-180). Heart fill: scale animation with color change on like. Use CSS transitions on transform and opacity. For complex morphs, use SVG with animated paths or Lottie animations. Keep duration short (200-300ms) for responsive feel. Add appropriate ARIA labels for state changes.',
      advanced: 'Create smooth icon morphing transitions between states for intuitive state feedback. Hamburger to X menu icon: three span elements in flex-col, transition-all duration-300 on each; open state: top span rotate-45 translate-y-[center], middle span opacity-0 scale-x-0, bottom span -rotate-45 -translate-y-[center]; use origin-center for rotation pivot. Play to Pause: SVG approach with path d attribute transition (requires same point count or use libraries), or element approach with triangle (border-left trick) transitioning to two rectangles. Plus to Minus: two absolutely positioned spans forming cross, vertical span transitions scaleY(1) to scaleY(0). Arrow directions: simple rotate transition (rotate-0 to rotate-90/180/-90), ensure transform-origin is centered. Heart fill: outline heart to filled - use two hearts stacked, filled underneath with scale-0 opacity-0, on like: scale-100 opacity-100 with bounce easing; add particle burst effect for delight. Checkbox morphing: square to checkmark using SVG path animation or clip-path transition. Toggle switch: circle to rectangle with border-radius animation. Complex morphs: use Lottie animations for designer-created morphs, or GSAP MorphSVG plugin for path morphing. CSS approach: use clip-path transitions for simpler shape morphs. TIMING: keep duration short (200-300ms) for responsive feel, use ease-out for quick response. ACCESSIBILITY: update aria-label or aria-expanded to reflect state, announce changes to screen readers. Implementation: controlled component with isOpen/isActive state, conditional classes based on state. Ensure SVG icons have consistent viewBox for smooth transitions.'
    },
    {
      id: 'a11',
      label: 'Number Counter',
      simple: 'Animate numbers counting up when they scroll into view.',
      detailed: 'Add animated counting numbers for statistics and metrics. Trigger animation when element scrolls into view using Intersection Observer. Animate from 0 to target value over 1-2 seconds. Use easeOutExpo easing for satisfying deceleration at end. Format numbers with commas as they count (toLocaleString). Handle decimals and percentages. Add suffix/prefix support ($, %, +). Include optional "+" indicator for numbers that continue to grow. Consider large numbers - abbreviate (1.2M, 500K) and count the abbreviated value. Add subtle scale bounce at completion. Replay option on scroll back. Use requestAnimationFrame for smooth animation. Handle rapid scroll - cancel and restart appropriately.',
      advanced: 'Add animated counting numbers for statistics and metrics with smooth easing and formatting. Intersection Observer trigger: observe element, start animation when isIntersecting, optionally unobserve after first trigger or allow replay on re-entry. Animation implementation: track startTime, use requestAnimationFrame loop, calculate progress (currentTime - startTime) / duration, apply easing function, compute currentValue = startValue + (endValue - startValue) * easedProgress. Easing function: easeOutExpo = progress === 1 ? 1 : 1 - Math.pow(2, -10 * progress) for satisfying deceleration. Number formatting: toLocaleString() for commas, handle decimals with toFixed(decimalPlaces), percentage with % suffix. Prefix/suffix support: $1,234, 99%, +500, props for prefix/suffix strings. Large number abbreviation: if > 1M show "1.2M", if > 1K show "500K", count abbreviated value for visual clarity. Duration: 1.5-2 seconds feels satisfying, adjust based on number magnitude. Animation polish: subtle scale bounce (1 to 1.05 to 1) at completion using separate CSS animation triggered on complete. Component API: <Counter value={1234} prefix="$" suffix="+" duration={2000} decimals={0} />. Handle edge cases: rapid scroll (cancel ongoing animation with cancelAnimationFrame), negative numbers, zero start value. Performance: single rAF loop per counter, batch updates if many counters visible simultaneously. Replay option: re-trigger animation when scrolled back into view, reset displayed value on exit. ACCESSIBILITY: ensure final value is accessible in DOM (not just visual), use aria-label with full number for screen readers.'
    },
    {
      id: 'a12',
      label: 'Typing Animation',
      simple: 'Add typewriter text effect with blinking cursor.',
      detailed: 'Implement typewriter text effect for hero sections and highlights. Type out text character by character with consistent speed (50-100ms per character). Add blinking cursor using animate-pulse or custom animation (opacity 0/1 toggle every 500ms). Support typing multiple phrases with delete animation between. Delete faster than typing (30-50ms). Add pause between phrases (1-2 seconds). Use monospace cursor character (|) or custom styled span. Handle word wrapping - ensure container accommodates full text. Add option for permanent cursor vs disappearing after complete. Consider accessibility - provide full text to screen readers. Implement using setTimeout chain or CSS animation with steps().',
      advanced: 'Implement typewriter text effect for hero sections and highlights with smooth, natural feel. Typing mechanism: setTimeout chain incrementing character index, or useEffect with setInterval and cleanup. Speed: 50-80ms per character for natural feel, vary slightly with random Â±20ms for more human effect. Cursor: blinking | character using animate-pulse or custom keyframes (opacity 0 to 1, step-end for sharp blink), span positioned after text or ::after pseudo-element. Multi-phrase rotation: array of phrases, type first phrase, pause 2s, delete (faster: 30-40ms per char), pause 500ms, type next phrase, loop. Delete animation: remove characters from end, visual effect of backspacing. Cursor variations: underscore _, block cursor with bg-current, vertical bar |. Container handling: fixed height container to prevent layout shift as text length changes, or measure longest phrase and set min-width. Pause points: longer pause after punctuation (.,!?), shorter between words. Component API: <Typewriter phrases={["Hello", "World"]} typingSpeed={70} deleteSpeed={40} pauseDuration={2000} loop={true} />. CSS-only approach: animate max-width from 0 to 100% with steps(characterCount), combine with overflow-hidden and white-space-nowrap. ACCESSIBILITY CRITICAL: provide full text to screen readers - use aria-label on container with full phrase, or visually hidden span with complete text. Handle completion: optional callback onComplete, option to hide cursor after final phrase. Advanced: cursor color matches text color, random typos that self-correct for personality (use sparingly), support for HTML/emoji in typed text.'
    },
    {
      id: 'a13',
      label: 'Pulse/Glow Effects',
      simple: 'Add pulsing and glowing attention animations.',
      detailed: 'Add attention-grabbing pulse and glow animations. Pulse effect: subtle scale oscillation (scale-100 to scale-105) with animate-pulse or custom keyframes. Use for: notification badges, important buttons, live indicators. Glow effect: animated box-shadow with colored blur - shadow-[0_0_15px_rgba(59,130,246,0.5)] that intensifies and fades. Ring pulse: expanding ring that fades out (like iOS notification). Dot pulse: small dot with expanding ring for "live" or "recording" indicators. Apply to: CTAs needing attention, new feature badges, alerts. Use sparingly - too many competing animations distract. Add animation-delay for multiple elements to prevent synchronization. Implement breathing effect for subtle constant attention without being annoying.',
      advanced: 'Add attention-grabbing pulse and glow animations for important UI elements without overwhelming users. Pulse effect variations: scale pulse (animate-pulse with scale-100 to scale-105), opacity pulse (subtle fade in/out), combined transform: scale + shadow increase. Custom keyframes for precise control: @keyframes pulse { 0%, 100% { transform: scale(1); opacity: 1; } 50% { transform: scale(1.05); opacity: 0.8; } }. Glow effect: box-shadow with colored blur - shadow-[0_0_15px_rgba(59,130,246,0.5)], animate intensity with keyframes alternating shadow spread (15px to 25px). Ring pulse (iOS notification style): ::before pseudo-element with absolute positioning, scale(1) to scale(2) with opacity 1 to 0, infinite animation 1.5s ease-out. Dot pulse for live indicators: small dot (w-2 h-2 rounded-full bg-green-500) with ring pulse behind it, offset timing between dot pulse and ring expansion. Breathing effect: very subtle scale (1 to 1.02) over 3-4 seconds for gentle constant attention. Use cases: notification badges (unread count), important CTAs (limited time offers), live/recording indicators, new feature badges, alert icons. CRITICAL: use sparingly - one pulsing element per viewport maximum, too many competing animations overwhelm users and reduce effectiveness. Prevent synchronization: add unique animation-delay (100ms, 234ms, 389ms - varied, not sequential) to multiple elements so they don\'t pulse together. Disable on interaction: stop pulse after user clicks/acknowledges element. ACCESSIBILITY: respect prefers-reduced-motion (disable or reduce to static glow), don\'t rely solely on animation for conveying importance. Duration: 1-2 seconds for pulse cycle, ease-in-out for smooth effect.'
    },
    {
      id: 'a14',
      label: 'Accordion Animation',
      simple: 'Add smooth expand/collapse animations to accordions.',
      detailed: 'Create smooth accordion expand/collapse animations. Use CSS grid for height animation: grid-rows-[0fr] to grid-rows-[1fr] with inner div overflow-hidden. Alternative: max-height transition from 0 to measured height. Add rotation animation to chevron icon (rotate-0 to rotate-180). Animate content opacity slightly delayed from height. Include subtle background color change on open item. Handle multiple accordions - allow single or multiple open states. Add proper ARIA attributes: aria-expanded, aria-controls. Smooth transition duration of 300-400ms with ease-out timing. Prevent content jump by measuring height before animation. Add focus styles for keyboard navigation. Include option to scroll open accordion into view.',
      advanced: 'Create smooth accordion expand/collapse animations avoiding common height animation pitfalls. CSS Grid technique (recommended): wrapper with grid, grid-template-rows: 0fr (closed) to 1fr (open), inner div with overflow-hidden and min-h-0; transition grid-template-rows over 300-400ms. This animates height smoothly without JavaScript measurement. Alternative max-height: transition max-height from 0 to measured scrollHeight, but requires JS measurement and can feel slow if max-height is much larger than content. Content opacity: animate opacity with slight delay (50ms) after height starts, creates layered reveal effect. Chevron icon: transition-transform duration-300, rotate-0 when closed, rotate-180 when open, use transform-origin center. Header styling: subtle background color change on open (bg-gray-50), border-l-4 accent on active item. Multiple accordion behavior: props for single-open (close others when one opens) vs multi-open (independent). State management: array of open IDs for multi, single ID or null for single-open mode. ACCESSIBILITY: button trigger with aria-expanded={isOpen}, aria-controls pointing to panel ID, panel with role="region" and aria-labelledby pointing to button; proper focus styles on button (focus-visible:ring-2), keyboard Enter/Space to toggle. Scroll into view: after opening, if panel extends below viewport, scrollIntoView({ behavior: "smooth", block: "nearest" }). Prevent content jump: if using max-height technique, measure content once and cache, or use grid technique which handles this automatically. Animation timing: 300-400ms with ease-out feels natural, faster feels abrupt, slower feels sluggish. Nested accordions: support recursively with proper ARIA tree structure. Reduced motion: instant expand/collapse without transition.'
    },
    {
      id: 'a15',
      label: 'Confetti Celebration',
      simple: 'Add confetti explosion animation for celebrations and success states.',
      detailed: 'Create confetti celebration effect for success moments. Generate multiple confetti particles with random colors, sizes, and shapes. Animate particles falling with rotation and drift. Add cannon burst origin point. Control particle count and spread angle. Include shapes: circles, squares, rectangles, stars. Use physics for natural falling motion. Auto-cleanup after animation completes. Trigger on success actions (form submit, achievement unlock). Consider performance with limited particle count.',
      advanced: 'Create confetti celebration effect for memorable success moments. Particle generation: create 50-150 particles (canvas or DOM elements), random colors from festive palette (gold, red, blue, green, pink), random sizes (5-15px), shapes (circles, squares, rectangles using CSS, SVGs for stars). Cannon effect: origin point (center, button, or custom), initial velocity with spread angle (60-120 degrees), particles burst outward then fall. Physics simulation: initial upward velocity, gravity pulling down, horizontal drift with randomness, rotation (random rotateZ, rotateY for tumble). Implementation options: canvas (best performance), DOM elements with CSS transforms (simpler, good for <100 particles), libraries (canvas-confetti, react-confetti). Canvas approach: requestAnimationFrame loop, update particle positions each frame, clear and redraw. DOM approach: create absolutely positioned divs, use CSS animations with random values via custom properties. Timing: initial burst 0.5s, fall duration 2-3s, stagger cleanup. Customization: configurable particle count, colors, origin point, spread angle, gravity. Performance: limit particle count (50-100 for mobile), use will-change, cleanup particles after animation. Variants: continuous stream, single burst, emoji rain. Use cases: form success, payment complete, achievement unlock, milestone reached, game win. ACCESSIBILITY: purely decorative (aria-hidden), dont distract from success message. Cleanup: remove particles after animation completes to prevent memory leaks.'
    },
    {
      id: 'a16',
      label: 'Marquee/Ticker',
      simple: 'Create smooth scrolling text or logo marquee animation.',
      detailed: 'Create smooth scrolling marquee for logos, testimonials, or announcements. Duplicate content for seamless loop. Animate using translateX from 0 to -50% (half because of duplication). Use CSS animation for smooth 60fps. Control speed with animation duration. Add pause on hover. Support both directions (left-to-right, right-to-left). Handle variable content widths. Add fade edges for polish. Consider accessibility - pausable, dont distract.',
      advanced: 'Create smooth scrolling marquee for continuous content display. Content structure: container with overflow-hidden, inner flex with two identical content blocks for seamless loop. Animation: @keyframes marquee { from { transform: translateX(0); } to { transform: translateX(-50%); } }, apply with animation: marquee 20s linear infinite. Duration controls speed: shorter = faster. Direction: negative translateX for left scroll, positive for right. Tailwind: animate-marquee with custom keyframes in config. Pause on hover: hover:paused using animation-play-state: paused. Variable content: measure content width, set animation duration proportionally (longer content = longer duration for consistent speed). Fade edges: gradient masks on left/right using mask-image linear-gradient. Content types: logo strips (flex gap-8 with logos), news tickers (text with separators), testimonial highlights. Vertical marquee: use translateY instead for upward scroll. Accessibility: add aria-live="off" to prevent constant announcements, provide pause control, dont use for critical information. Performance: use CSS animation (not JS), will-change: transform. Gap handling: ensure gap between last and first item matches internal gaps. Multiple rows: stack multiple marquees with different speeds or directions. Implementation: create Marquee component with speed, direction, pauseOnHover props. Mobile: consider reducing content or disabling for performance. Reduced motion: pause animation or disable entirely.'
    },
    {
      id: 'a17',
      label: 'Gradient Animation',
      simple: 'Create animated gradient backgrounds that shift colors smoothly.',
      detailed: 'Create animated gradient backgrounds. Use CSS background with linear-gradient or radial-gradient. Animate background-position to create movement. Set background-size larger than element (200% 200%) for smooth loop. Animate hue-rotate for color cycling. Create mesh gradient with multiple color stops. Add subtle movement with transform animations. Use for hero backgrounds, cards, buttons. Control speed to avoid distraction. Layer with noise texture for depth.',
      advanced: 'Create animated gradient backgrounds for dynamic visual interest. Moving gradient: background linear-gradient at angle (45deg), background-size: 200% 200% (or 400%), @keyframes gradient { 0% { background-position: 0% 50% } 50% { background-position: 100% 50% } 100% { background-position: 0% 50% } }, animate over 10-15s ease infinite. Hue rotation: single gradient with hue-rotate filter animation, cycles through color wheel smoothly. Mesh gradient: multiple overlapping radial-gradients with different positions, animate positions for morphing effect. Conic gradient: conic-gradient from center, rotate with transform animation. Aurora effect: multiple color bands with blur, animating position creates flowing aurora. Implementation: @keyframes in Tailwind config or inline styles with CSS custom properties. Performance: use GPU-accelerated properties (transform for position, filter for hue), avoid animating background-position on large elements. Overlay: semi-transparent gradient over solid color base for subtlety. Noise texture: overlay with noise SVG or PNG at low opacity for organic feel. Use cases: hero sections (subtle movement), buttons (attention-grabbing), cards (premium feel), loading states. Speed: 10-20s for subtle background, 3-5s for attention-grabbing. ACCESSIBILITY: ensure text contrast maintained throughout animation, prefers-reduced-motion pauses or disables animation. Variants: breathing gradient (scale or opacity pulse), gradient border (pseudo-element technique).'
    },
    {
      id: 'a18',
      label: 'Flip Animation',
      simple: 'Create 3D flip animations for cards revealing content on back.',
      detailed: 'Create 3D flip animations for interactive cards. Use CSS perspective on container. Apply transform-style: preserve-3d to card. Create front and back faces with backface-visibility: hidden. Flip with rotateY(180deg) on hover or click. Back face pre-rotated 180deg. Add transition for smooth flip (500-600ms). Include proper z-index handling during flip. Support both horizontal (rotateY) and vertical (rotateX) flips. Add depth with translateZ. Handle content on both sides.',
      advanced: 'Create 3D flip animations for interactive card reveals. Container setup: perspective on parent (perspective: 1000px or perspective-[1000px] in Tailwind), enables 3D effect. Card structure: transform-style: preserve-3d, transition-transform duration-500 ease-out, contains front and back faces. Front face: backface-visibility: hidden, positioned normally. Back face: backface-visibility: hidden, rotateY(180deg) applied by default (pre-flipped), same absolute positioning as front. Flip trigger: on hover or click, apply rotateY(180deg) to card container. Horizontal vs Vertical: rotateY for left-right flip, rotateX for top-bottom flip. Depth enhancement: add translateZ(50px) during flip for slight lift effect. Z-index handling: during transition, flipping card needs higher z-index to avoid clipping siblings. Content considerations: front shows preview, back shows details/actions, both need proper styling. Click-to-flip: use state for isFlipped, toggle on click, apply conditional classes. Hover-to-flip: group-hover on container controls flip, consider touch devices (use click instead). Performance: will-change: transform on card during hover/interaction. Easing: ease-in-out for smooth acceleration/deceleration, or custom cubic-bezier. Duration: 500-600ms feels natural for full 180deg rotation. Accessibility: ensure content accessible without flip (provide alternative interaction), visible focus styles, keyboard support (Enter/Space to flip). Responsive: may need smaller perspective on mobile. Libraries: Framer Motion provides simpler API for complex 3D transforms.'
    },
    {
      id: 'a19',
      label: 'Ripple Effect',
      simple: 'Add Material Design style ripple effect on click.',
      detailed: 'Create Material Design ripple effect on click. Calculate click position relative to element. Create expanding circle from click point. Animate scale from 0 to covering element with opacity fade. Use CSS transitions or keyframes. Clean up ripple elements after animation. Support multiple concurrent ripples. Handle elements of various sizes and shapes. Add to buttons, list items, and touch surfaces. Use pseudo-element or dynamically created spans.',
      advanced: 'Create Material Design ripple effect on interactive elements. Implementation approaches: 1) Dynamic span creation, 2) CSS pseudo-element with JS positioning. Span approach: on click, create span at click position (event.clientX/Y relative to element getBoundingClientRect), apply absolute positioning, start at scale(0) with opacity 0.3, animate to scale(4) with opacity 0, remove span after animation ends (600ms). Positioning calculation: const rect = element.getBoundingClientRect(); const x = event.clientX - rect.left; const y = event.clientY - rect.top;. Span styles: absolute, rounded-full, bg-white/30 (or bg-current for themed), transform scale-0, animation: ripple 600ms ease-out forwards. Container: relative, overflow-hidden (critical to clip ripple to element bounds). Multiple ripples: allow new ripple before previous finishes, each independent. CSS-only approach (simpler but centered): ::after with scale transition on :active, always from center. Size handling: ripple needs to be large enough to cover element, set width/height to max(elementWidth, elementHeight) * 2, center at click point. Custom hook: useRipple() returning onClick handler and necessary styles. Performance: use transform scale (GPU accelerated), limit concurrent ripples if needed. Cleanup: remove span elements after animation with setTimeout or animationend event. Color: white with opacity on dark buttons, dark with opacity on light, or use currentColor. Tailwind: custom animation in config, or use inline keyframes. Accessibility: purely visual enhancement, doesn\'t affect interaction. Touch devices: works with touch events, larger ripple for finger size.'
    },
    {
      id: 'a20',
      label: 'Drawer Animation',
      simple: 'Create smooth slide-in drawer/panel animations from screen edges.',
      detailed: 'Create smooth slide-in drawer animations. Position fixed at screen edge. Animate transform from off-screen to visible. Support all directions: left, right, top, bottom. Add backdrop with fade animation. Sync content and backdrop timing. Include spring/bounce effect for natural feel. Handle body scroll lock. Add drag-to-close gesture. Support nested drawers with z-index stacking. Coordinate with other animations.',
      advanced: 'Create smooth slide-in drawer animations for side panels and bottom sheets. Base structure: fixed positioning, z-50, flex for content layout. Direction variants: left (translate-x-full to translate-x-0 for open, reversed for close), right (negative translate), top (translate-y), bottom (translate-y from 100%). Backdrop: fixed inset-0, bg-black, opacity animation 0 to 0.5, separate from content animation for layered effect. Animation timing: content slides while backdrop fades simultaneously, 300ms ease-out for open, 250ms ease-in for close. Spring effect: use cubic-bezier(0.32, 0.72, 0, 1) for slight overshoot and settle. Drag-to-close: track touch/mouse drag perpendicular to edge, if drag exceeds threshold (30% of drawer size), close on release; if not, spring back. Velocity consideration: fast drag even if short distance can trigger close. Body scroll lock: add overflow-hidden to body when open, restore on close. Nested drawers: increment z-index for each level, new drawer pushes or overlays previous. Bottom sheet specifics: rounded-t-xl, drag handle at top (w-10 h-1 bg-gray-300 rounded-full), snap points (collapsed, expanded, dismissed). Transform origin: set origin for any scale effects to match edge (origin-left for left drawer). Performance: use transform only (not left/top), will-change during animation. Reduce motion: instant visibility toggle, fade backdrop without slide. ACCESSIBILITY: focus trap when open, Escape to close, aria-hidden on main content, focus first element on open, return focus on close. Swipe gesture: common on mobile, from edge-swipe to open as well.'
    },
    {
      id: 'a21',
      label: 'Text Gradient Animation',
      simple: 'Create animated gradient text that shifts colors.',
      detailed: 'Create animated gradient text effect. Apply background gradient to text using bg-clip-text and text-transparent. Animate background-position or hue-rotate for color shift. Use larger background-size for smooth loop. Support multiple color stops. Control animation speed. Add shimmer variant with linear gradient sweep. Consider performance for large text. Ensure readability throughout animation.',
      advanced: 'Create animated gradient text for attention-grabbing headings. Base technique: background linear-gradient, background-clip: text (-webkit-background-clip: text), color: transparent (text-transparent). Moving gradient: background-size: 200% 200%, @keyframes gradient-text { 0% { background-position: 0% 50% } 100% { background-position: 100% 50% } }, animate 3-5s ease infinite. Hue shift: single gradient, filter: hue-rotate animation from 0deg to 360deg. Shimmer effect: linear-gradient with transparent, white highlight, transparent, animate background-position across text width. Multi-color: gradient with multiple stops (rainbow or brand colors), animate position for flowing effect. Chrome/metallic: gradient with multiple white/gray stops at different angles, subtle position animation for reflective look. Tailwind implementation: custom animation in tailwind.config, or inline styles for complex gradients. Browser support: -webkit-background-clip for Safari, test in all browsers. Performance: filter animations can be expensive on large text, prefer transform/background-position when possible. Readability: ensure all color combinations in animation provide sufficient contrast. Use cases: hero headlines, highlight text, call-to-action text. Fallback: for browsers without support, ensure solid color fallback. Animation speed: 3-10s depending on effect, faster for attention, slower for ambient. ACCESSIBILITY: animated text can be distracting, consider prefers-reduced-motion to disable, ensure text remains readable. Gradient direction: 45deg or 90deg most common, experiment for desired effect.'
    },
    {
      id: 'a22',
      label: 'Skeleton Shimmer',
      simple: 'Add shimmer animation to skeleton loading placeholders.',
      detailed: 'Create shimmer animation for skeleton loading states. Apply moving highlight gradient over gray base. Animate from left to right continuously. Use linear-gradient with transparent, light highlight, transparent. Animate background-position. Keep animation subtle and non-distracting. Apply to text placeholders, image containers, and UI shapes. Sync animation across multiple skeleton elements. Consider reduced motion preference.',
      advanced: 'Create shimmer animation for skeleton loading placeholders providing perceived progress. Base skeleton: bg-gray-200 (or bg-gray-100) with border-radius matching content type (rounded for text, rounded-lg for cards). Shimmer technique: linear-gradient overlay with three stops (transparent, rgba(255,255,255,0.4), transparent), positioned at -100% initially, animate to 100% over 1.5-2s. Implementation: pseudo-element ::after with absolute positioning, gradient background, @keyframes shimmer { 0% { transform: translateX(-100%); } 100% { transform: translateX(100%); } }. Alternative: animate background-position on the skeleton itself with larger background-size. Gradient angle: slight angle (20deg) for natural sweep, or horizontal for uniform. Timing: 1.5-2s duration, infinite loop, ease-in-out or linear. Sync across elements: same animation-duration and animation-delay: 0 ensures synchronized shimmer, or stagger for wave effect. Skeleton shapes: text (h-4 with varying widths for lines), avatar (rounded-full), image (aspect-ratio container), button (rounded-lg). Color matching: adjust shimmer color to match background (lighter shimmer on gray). Performance: use transform: translateX (GPU accelerated) instead of background-position. Reduced motion: static gray without shimmer, or very slow subtle pulse. Component structure: reusable Skeleton component with variant prop (text, avatar, image, button). Content transition: crossfade from skeleton to real content, not abrupt replacement. Dark mode: adjust base gray and shimmer highlight colors. Consider: skeleton should roughly match content dimensions to prevent layout shift.'
    },
    {
      id: 'a23',
      label: 'Magnetic Buttons',
      simple: 'Create buttons that attract toward cursor on hover.',
      detailed: 'Create magnetic button effect where button subtly follows cursor. Track mouse position relative to button. Calculate distance and angle from button center. Apply transform to move button toward cursor when nearby. Limit movement range (10-20px max). Add smooth transition for natural feel. Reset position smoothly on mouse leave. Apply to important CTAs for engagement. Handle touch devices gracefully.',
      advanced: 'Create magnetic button effect for engaging interactive elements. Mouse tracking: onMouseMove on button or container, get cursor position relative to button center. Distance calculation: const rect = button.getBoundingClientRect(); const centerX = rect.left + rect.width / 2; const centerY = rect.top + rect.height / 2; const deltaX = event.clientX - centerX; const deltaY = event.clientY - centerY;. Magnetic pull: when cursor within threshold radius (100-150px), apply transform: translate(deltaX * 0.3, deltaY * 0.3), multiply by factor <1 for subtlety. Max displacement: clamp movement to prevent button moving too far (max 15-20px). Smooth transition: transition-transform duration-200 ease-out for lag effect that feels natural. Reset: onMouseLeave triggers transition back to translate(0, 0). Activation radius: only start magnetic effect when cursor enters larger radius around button, prevents distant interference. Easing: ease-out when following, ease-in when resetting. Inner content: optionally move inner content (text, icon) in opposite direction for parallax. Performance: use requestAnimationFrame for smoother tracking if needed, throttle updates. Implementation: useRef for button, useState for transform values, useEffect cleanup for listeners. Touch devices: disable effect (no concept of hover distance), use normal button behavior. Use cases: primary CTAs, navigation items, interactive demos. ACCESSIBILITY: magnetic effect is enhancement only, all functionality must work without it, dont interfere with click target. Libraries: GSAP or Framer Motion can simplify implementation with spring physics.'
    },
    {
      id: 'a24',
      label: 'Reveal Animation',
      simple: 'Create content reveal animations with mask or clip-path.',
      detailed: 'Create reveal animations using clip-path or mask. Animate clip-path to reveal content progressively. Support multiple reveal directions (left to right, center out, diagonal). Use inset for rectangular reveals. Use polygon for angular reveals. Use circle for radial reveals. Combine with content animation for layered effect. Add staggered reveals for multiple elements. Control timing and easing.',
      advanced: 'Create content reveal animations using clip-path for dramatic entrances. Clip-path techniques: inset (rectangular), circle (radial), polygon (angular/custom shapes). Left-to-right reveal: clip-path: inset(0 100% 0 0) to inset(0 0 0 0), transition-[clip-path] duration-700. Right-to-left: inset(0 0 0 100%) to inset(0). Top-down: inset(100% 0 0 0) to inset(0). Center-out (horizontal): inset(0 50% 0 50%) to inset(0). Center-out (radial): circle(0% at center) to circle(100% at center). Diagonal wipe: polygon(0 0, 0 0, 0 100%, 0 100%) to polygon(0 0, 100% 0, 100% 100%, 0 100%). Custom shapes: use polygon with multiple points for creative reveals. Staggered reveals: apply delays to each element, creates cascade effect. Layered reveal: reveal background first, then content with offset timing. Performance: clip-path animations are GPU-accelerated, smooth even for complex shapes. Browser support: good modern browser support, consider fallback opacity animation for older browsers. Trigger: combine with Intersection Observer for scroll-triggered reveals. Combined animations: reveal clip-path while also animating content transform/opacity for richer effect. Direction patterns: match reveal direction to reading direction or scroll direction for natural feel. Easing: cubic-bezier(0.77, 0, 0.175, 1) for smooth accelerate-decelerate. Duration: 500-1000ms for dramatic reveals, shorter for functional transitions. ACCESSIBILITY: ensure content is accessible once revealed, provide reduced-motion fallback (simple fade).'
    },
    {
      id: 'a25',
      label: 'Floating Elements',
      simple: 'Create gentle floating animation for decorative elements.',
      detailed: 'Create gentle floating animation for decorative elements. Apply subtle vertical movement (translateY oscillation). Add slight horizontal drift for organic feel. Include gentle rotation. Vary animation timing for multiple elements. Use ease-in-out for smooth direction changes. Create different float patterns (gentle bob, figure-8, circular). Apply to icons, images, badges, or decorative shapes. Keep movement subtle to avoid distraction.',
      advanced: 'Create gentle floating animation for ambient decorative elements. Basic float: @keyframes float { 0%, 100% { transform: translateY(0); } 50% { transform: translateY(-20px); } }, animate over 3-5s ease-in-out infinite. Multi-axis float: combine translateY with slight translateX for organic drift, different amplitude for each. Rotation: add subtle rotate(-5deg to 5deg) for natural tumble. Figure-8 pattern: combine translateX and translateY with different durations that create lissajous curve. Circular orbit: use translateX(cos(t)*radius) translateY(sin(t)*radius) via keyframe points. Multiple elements: different animation-duration (3s, 4s, 5s) and animation-delay for desync, prevents unnatural synchronized movement. Parallax float: elements at different depths float at different speeds, creates depth. Scale breathing: subtle scale(1 to 1.05) combined with float. Blur variation: slight blur animation with position for dreamy effect. Apply to: decorative icons, abstract shapes, floating cards, illustrations, badges. Anchor point: use transform-origin to control rotation pivot. Performance: transform only (GPU accelerated), will-change: transform for many elements. Reduced motion: disable or significantly reduce movement. Use cases: hero sections, empty states, illustrations, onboarding. Amount of movement: keep subtle (10-30px displacement), too much distracts from content. Z-index layering: layer floaters at different depths with corresponding size/blur. Interaction: optionally respond to mouse position with parallax offset. Libraries: for complex paths, consider GSAP for precise motion control.'
    },
    {
      id: 'a26',
      label: 'Text Scramble',
      simple: 'Create text scramble effect that reveals text through random characters.',
      detailed: 'Create text scramble effect for dramatic reveals. Start with random characters. Progressively reveal correct characters from start. Each character cycles through random chars before settling. Use monospace or similar-width font for stability. Control reveal speed and scramble duration. Apply to headings, statistics, or dramatic reveals. Add subtle color transition as characters finalize. Handle different text lengths.',
      advanced: 'Create text scramble effect for dramatic text reveals (Matrix/hacking aesthetic). Algorithm: for each character position, cycle through random characters before settling on final character, reveal progresses from first to last character. Implementation: use setInterval to update displayed text, each position has a resolve time, before resolved show random char, after resolved show final char. Character pool: alphanumeric (A-Z, 0-9) for tech feel, or match character type (uppercase for uppercase). Timing: each character resolves after delay, stagger from start to end (first char resolves quickly, last takes full duration). Update frequency: 30-50ms for smooth scramble effect. Duration: 1-2s for full reveal depending on text length. Font: monospace fonts work best (equal character widths prevent jumping), or use tabular-nums for numbers. Reveal patterns: left-to-right (classic), random positions, outside-in. Color transition: scrambling characters slightly different color/opacity, final characters full opacity. Numbers: great for statistics counters, scramble digits before showing final value. React implementation: useEffect with interval, cleanup on unmount, state for displayed characters array. Trigger: on scroll into view, on interaction, or on mount. Edge cases: handle text changes mid-animation, support variable lengths. Performance: simple string manipulation, no heavy computation. ACCESSIBILITY: final text must be accessible to screen readers, use aria-label with final text, aria-live for dynamic updates. Reduced motion: instant reveal without scramble. Use cases: hero text, statistics, dramatic reveals, tech/gaming aesthetics.'
    },
    {
      id: 'a27',
      label: 'Cursor Effects',
      simple: 'Create custom cursor with trail or interactive effects.',
      detailed: 'Create custom cursor effects for unique experiences. Hide default cursor. Track mouse position. Create custom cursor element that follows mouse. Add trailing effect with multiple following elements. Include interactive states (hover changes). Add blob/circle that responds to clicks. Implement magnetic pull near interactive elements. Create cursor spotlight effect. Handle cursor leaving window.',
      advanced: 'Create custom cursor effects for distinctive interactive experience. Hide default cursor: body { cursor: none }, or per-element. Cursor element: fixed position div, pointer-events-none, z-50 (above all content), transform translate(-50%, -50%) to center on mouse. Position tracking: document mousemove listener, update CSS custom properties or state with clientX, clientY. Smooth follow: use transition on cursor element (transition: transform 0.1s ease-out) or lerp position in rAF for lag effect. Trail effect: multiple cursor elements with increasing transition delay, creates snake trail. Interactive states: change cursor size, color, or shape based on what is being hovered (detect with event.target), grow on clickable elements. Click effect: scale pulse or ripple from cursor on mousedown. Blob cursor: larger soft circle that morphs/stretches based on movement speed and direction. Spotlight: radial gradient mask that follows cursor, reveals hidden content. Magnetic effect: cursor distorts or pulls when near specific elements. Hover detection: poll or use mouseover/mouseout on interactive elements to change cursor state. Mixed cursor: show custom cursor alongside default (partial replacement). Performance: use transform for position (GPU accelerated), reduce complexity on mobile. Touch devices: hide custom cursor entirely on touch-only devices. Accessibility: custom cursor is enhancement, ensure all interactions work with default cursor. Cursor context: different cursor for different page sections (pointer over links, crosshair over canvas). Window boundary: detect mouseout on document to hide/position cursor appropriately. Implementation: React refs or vanilla JS event listeners, cleanup on unmount.'
    },
    {
      id: 'a28',
      label: 'Split Text Animation',
      simple: 'Animate text by splitting into individual characters or words.',
      detailed: 'Create split text animations by animating individual characters or words. Split text into spans programmatically. Apply staggered animation to each span. Support character-by-character or word-by-word splits. Add animation variants (fade up, rotate in, scale). Handle whitespace properly. Maintain accessibility with original text. Create wave effects with delay patterns.',
      advanced: 'Create split text animations for dynamic typographic effects. Splitting approach: wrap each character or word in span, apply inline-block display (needed for transforms). Character split: text.split("").map((char, i) => <span key={i} style={{animationDelay: `${i * 50}ms`}}>{char}</span>), handle spaces specially (use &nbsp; or preserve whitespace). Word split: text.split(" ").map() with spaces rendered between. Animation variants: fade-up (opacity 0, translateY(20px) to visible), rotate-in (rotateX(-90deg) to 0), scale-pop (scale(0) to scale(1)), blur-in (filter: blur(10px) to 0). Stagger patterns: linear (50ms increment), accelerating, decelerating, random within range. Wave effect: use sine-based delay calculation for smooth wave. Combined effects: animate multiple properties with different timings. Line awareness: split by lines for responsive animations (more complex, may need JS line detection). Performance: many spans can impact performance, use CSS animations not JS, avoid animating on each scroll. Trigger: Intersection Observer for scroll-triggered, or on mount/event. Libraries: splitting.js, GSAP SplitText for easier implementation with more features. Reduced motion: show complete text without animation. ACCESSIBILITY: use aria-label with full text on container, individual spans can be aria-hidden if needed. Text updates: re-split when text content changes. Special characters: handle emojis, punctuation properly. Cursor/selection: inline-block spans maintain normal text selection. Use cases: hero headlines, emphasis text, dramatic reveals.'
    },
    {
      id: 'a29',
      label: 'Morphing Shapes',
      simple: 'Create SVG shapes that smoothly morph between states.',
      detailed: 'Create morphing shape animations using SVG paths. Animate between different path definitions. Ensure paths have same number of points for smooth morph. Use SMIL animations or CSS/JS. Create blob morphing with organic transitions. Support click-triggered or continuous morphing. Handle complex shapes with multiple paths. Add color transitions during morph.',
      advanced: 'Create morphing shape animations using SVG paths for organic transitions. Morphing requirement: source and target paths must have same number of points/commands for smooth interpolation. Path matching: manually create paths with matching point counts, or use libraries like flubber to interpolate between different paths. CSS approach: transition d attribute (limited browser support), or use SVG SMIL animate element. JavaScript approach: interpolate path points each frame, update d attribute via ref. Blob morphing: organic blob shapes with bezier curves, multiple control points, animate point positions with noise/random for continuous organic movement. Continuous morph: animate path points in loop with varying speeds per point, creates breathing/flowing effect. Click-triggered: interpolate between two specific states on interaction, reverse on toggle. Implementation pattern: store path points as state, animate point positions, generate d attribute from points. Easing: apply easing to point position changes for natural movement. Multi-path SVG: each path morphs independently, coordinate timing for cohesive animation. Color sync: animate fill/stroke color alongside shape change. Libraries: GSAP MorphSVG (most powerful, handles different point counts), Anime.js, Framer Motion SVG animation. Performance: complex morphs with many points can be expensive, optimize point count. Use cases: logo animations, decorative backgrounds, illustration interactions, button states. Fallback: for browsers without support, crossfade between static states. Looping: use seamless loop by morphing AâBâA or through multiple states. Reduced motion: show static shape or simple fade between states.'
    },
    {
      id: 'a30',
      label: 'Scroll Progress',
      simple: 'Create scroll progress indicator that fills based on page position.',
      detailed: 'Create scroll progress indicator showing reading/scroll position. Calculate scroll percentage (scrollY / (scrollHeight - clientHeight)). Display as horizontal bar at top or side. Animate width/height based on scroll. Add smooth transition. Support both page and container scroll. Style with gradient or brand colors. Include numerical percentage option. Handle dynamic content height changes.',
      advanced: 'Create scroll progress indicator showing document or section reading progress. Calculation: progress = scrollY / (document.documentElement.scrollHeight - window.innerHeight), results in 0-1 value. Bar indicator: fixed top-0 left-0 w-full h-1, inner div with bg-blue-500, width set to percentage (style={{ width: `${progress * 100}%` }}). Smooth updates: either CSS transition on width (transition-all duration-75), or throttled scroll handler for efficiency. Circular indicator: SVG circle with stroke-dasharray and stroke-dashoffset, offset calculated from progress. Container scroll: target specific container scrollTop and scrollHeight instead of document. Section progress: track progress through specific section (when section is in view), calculate progress within that section bounds. Styling: gradient fill, rounded end caps, glow effect, brand colors. Numerical display: show "75%" text, optional tooltip with scroll depth. Direction indicator: show when scrolling up vs down with color or arrow. Hide behavior: fade out when not scrolling (after 2s timeout), or hide at top. Dynamic content: recalculate max scroll height when content changes, use ResizeObserver. Performance: use passive scroll listener, throttle to 60fps, use transform instead of width for very smooth animation. Implementation: useScrollProgress hook returning progress value and direction. Variants: thin line (h-0.5), chunky bar (h-1), sticky in header, floating sidebar. ACCESSIBILITY: purely decorative, use aria-hidden. Mobile: useful for long-form content, ensure doesnt obstruct content or navigation.'
    },
    {
      id: 'a31',
      label: 'Particle Systems',
      simple: 'Create particle effects for backgrounds and decorative elements.',
      detailed: 'Create particle systems for dynamic backgrounds. Generate multiple particle elements. Animate position, opacity, and scale. Add physics-like behavior (floating, drifting). Support mouse interaction (attract/repel). Create connected particles with lines. Control density and performance. Handle resize gracefully. Add variety in particle size and speed.',
      advanced: 'Create particle systems for engaging backgrounds and decorative effects. Particle creation: generate array of particles with random properties (x, y, size, speed, direction). Canvas approach (recommended for many particles): requestAnimationFrame loop, clear and redraw particles each frame, update positions based on velocity. DOM approach (for fewer particles): absolutely positioned divs with CSS animations, each with random animation-duration and animation-delay. Movement patterns: linear drift, sine wave oscillation, random walk, gravity fall, upward float. Mouse interaction: calculate distance from mouse, apply attraction (move toward mouse) or repulsion (move away), stronger effect when closer. Connected particles: draw lines between particles within threshold distance, line opacity based on distance. Particle properties: position (x, y), velocity (vx, vy), size, opacity, color/hue. Bounds handling: wrap around edges, bounce off edges, or fade out and respawn. Performance: limit particle count (50-200 typically), use canvas for 100+, throttle mouse interaction calculations. Dynamic density: fewer particles on mobile, adjust based on viewport size. Resize handling: recalculate bounds, redistribute particles proportionally. Variety: randomize size (2-6px), speed (0.5-2x), opacity, and optionally color. Parallax layers: particles at different depths move at different speeds. Libraries: particles.js, tsparticles for feature-rich implementations. Reduced motion: reduce to static dots or significantly slow movement. ACCESSIBILITY: purely decorative (pointer-events: none), dont convey information. Use cases: hero backgrounds, login pages, 404 pages, special sections.'
    },
    {
      id: 'a32',
      label: 'Notification Animation',
      simple: 'Create slide-in animations for toast notifications.',
      detailed: 'Create notification/toast animations. Slide in from screen edge (top, bottom, right). Stack multiple notifications properly. Add exit animation before removal. Include progress bar for auto-dismiss timing. Support different notification types (success, error, warning, info). Add hover pause for auto-dismiss. Handle notification queue and limits. Create subtle attention animation for critical alerts.',
      advanced: 'Create notification/toast animations with proper queuing and interaction. Entry animation: slide from edge with fade - right edge: translateX(100%) opacity-0 to translateX(0) opacity-100, top edge: translateY(-100%). Exit animation: reverse direction or fade out, trigger before removal, remove from DOM after animation completes (300ms). Stacking: flex-col gap-2 for vertical stack, new notifications push existing ones. Position variants: top-right (most common), top-center, bottom-right, bottom-center. Progress indicator: thin bar at bottom showing time until auto-dismiss, animates width from 100% to 0 over duration. Type styling: success (green accent, CheckCircle icon), error (red, XCircle), warning (yellow, AlertTriangle), info (blue, Info). Auto-dismiss: default 5s timeout, pause timer on hover (onMouseEnter/Leave), resume on leave. Manual dismiss: X button with fade/slide out animation. Queue management: limit visible notifications (max 3-5), queue others, show next when space available. Animation timing: 300ms enter, 250ms exit, use ease-out for enter, ease-in for exit. Attention animation: for critical notifications, add subtle pulse or shake animation. Swipe to dismiss: on mobile, swipe right to dismiss with drag gesture. Sound: optional audio cue for important notifications (with user permission). Implementation: notification state manager (array), portal rendering, AnimatePresence for exit animations. ACCESSIBILITY: role="alert" for important, role="status" for informational, aria-live="polite" or "assertive", focus management for persistent notifications. Reduced motion: fade only without slide. Z-index: high enough to appear above all content (z-50).'
    },
    {
      id: 'a33',
      label: 'Spring Physics',
      simple: 'Apply spring physics for natural bouncy animations.',
      detailed: 'Apply spring physics for natural feeling animations. Configure stiffness, damping, and mass. Create bouncy button interactions. Add overshoot and settle effects. Use for modal entrances. Apply to drag and drop settle. Create natural following animations. Handle interruption gracefully. Use libraries like Framer Motion for implementation.',
      advanced: 'Apply spring physics for natural, physically-accurate animations. Spring parameters: stiffness (higher = snappier, 100-500), damping (higher = less bounce, 10-50), mass (higher = slower, 0.5-3). Framer Motion springs: transition={{ type: "spring", stiffness: 300, damping: 20 }} for bouncy, { stiffness: 400, damping: 40 } for snappy, { stiffness: 100, damping: 10 } for very bouncy. Presets: wobbly (low damping), gentle (low stiffness), stiff (high stiffness, high damping). Button press: scale spring from 1 to 0.95 to 1, natural overshoot feels satisfying. Modal entrance: scale 0.9 to 1 with opacity, spring creates arrival effect. Drag release: spring to final position after drag ends, velocity from drag affects spring. Following animations: cursor followers, scroll-linked elements, use spring interpolation. Interruption handling: spring naturally handles mid-animation interruption, new target blends smoothly. Chained springs: stagger spring animations on children with delay. Custom spring: for non-library implementation, use spring equation in rAF loop: velocity += (target - current) * stiffness; velocity *= damping; current += velocity. React Spring: useSpring hook for imperative control, animated components. Framer Motion: animate prop with spring transition, layout animations with spring. Performance: spring calculations each frame, but transform-only animations are GPU accelerated. When to use springs: UI responses (buttons, toggles), drag/drop, modals, micro-interactions. When not to use: progress bars, page transitions (usually), loading animations. Reduced motion: reduce spring effect to simple ease, or disable entirely. Tuning: adjust stiffness/damping by feel, test on various devices.'
    },
    {
      id: 'a34',
      label: 'Animated Icons',
      simple: 'Create animated versions of common icons (loading, success, error).',
      detailed: 'Create animated icon states for feedback. Loading spinner with rotation. Success checkmark with draw effect. Error X with shake or draw. Warning triangle with pulse. Transition between states smoothly. Use SVG for crisp animations. Add color transitions. Support icon size variants. Create morphing between icon states.',
      advanced: 'Create animated icon states for clear visual feedback. Loading spinner: circular stroke with stroke-dasharray gap, animate rotation (transform: rotate) or stroke-dashoffset for spinning arc. Checkmark draw: SVG path with stroke-dasharray equal to path length, animate stroke-dashoffset from length to 0, reveals stroke. Error X: two diagonal lines, animate each with draw or fade-in, add subtle shake (translateX oscillation) on complete. Warning pulse: scale 1 to 1.1 with opacity pulse, draws attention. State transitions: morph between icons (loading â success/error), or crossfade with scale. SVG structure: viewBox="0 0 24 24" for consistent sizing, stroke icons for draw animations, currentColor for theme inheritance. Draw animation timing: 500-800ms for satisfying reveal, ease-out for natural deceleration. Color transitions: animate stroke or fill color alongside shape (gray loading, green success, red error). Size variants: scale SVG or adjust stroke-width proportionally. Looping states: loading loops infinitely, success/error play once and hold. Sequencing: for multi-element icons (like list checkmarks), stagger animation across items. Implementation: CSS keyframes for rotation, stroke-dashoffset for draw, React state for conditional rendering. Libraries: Lottie for designer-created animations, react-icons with custom animation wrapper. Morphing icons: same point count for smooth morph, or use Flubber/GSAP for path interpolation. ACCESSIBILITY: use aria-label to describe state ("Loading", "Success", "Error"), dont rely solely on animation for communication. Reduced motion: show static icon in final state without animation. Performance: SVG animations are efficient, prefer CSS over JS animation when possible.'
    }
  ]
};
