import type { PromptCategory } from '../types';

export const accessibilityCategory: PromptCategory = {
    id: 'accessibility',
    name: 'Accessibility',
    icon: 'Accessibility',
    description: 'A11y improvements',
    prompts: [
      {
        id: 'ac1',
        label: 'WCAG Compliance',
        simple: 'Audit and fix for WCAG 2.1 AA accessibility compliance.',
        detailed: 'Audit and fix for WCAG 2.1 AA compliance. Check color contrast ratios (4.5:1 minimum for normal text, 3:1 for large text) using tools. Ensure all interactive elements have visible focus indicators (ring-2 ring-blue-500 ring-offset-2). Use semantic HTML elements: nav, main, article, aside, header, footer, section. Add proper heading hierarchy (h1 through h6 in order). Ensure links have descriptive text (not "click here"). Make all functionality keyboard accessible. Add skip links for navigation. Test with screen readers (VoiceOver, NVDA). Verify form inputs have labels. Check touch targets are minimum 44x44px on mobile.',
        advanced: 'Audit and fix for WCAG 2.1 AA compliance with comprehensive testing. Perceivable: color contrast ratios (4.5:1 normal text, 3:1 large text/UI) using WebAIM or browser devtools, text alternatives for all non-text content, captions for video, adaptable content that works in different presentations, distinguishable content (don\'t use color alone for meaning). Operable: all functionality keyboard accessible with visible focus (focus-visible:ring-2 ring-blue-500 ring-offset-2), no keyboard traps, sufficient time for interactions, no content that flashes >3 times/second, skip navigation links, clear page titles, focus order follows visual order, link purpose clear from text. Understandable: page language set (lang attribute), consistent navigation patterns, input assistance with clear labels and error messages. Robust: valid HTML, proper ARIA usage only where needed. Testing protocol: automated scan (axe, WAVE), keyboard-only navigation test, screen reader testing (VoiceOver Mac, NVDA Windows, TalkBack Android, VoiceOver iOS), color blindness simulation, zoom to 200%. Semantic HTML: use nav, main, article, aside, header, footer, section appropriately, proper heading hierarchy (h1-h6 in order, one h1 per page). Forms: all inputs have associated labels, error messages linked with aria-describedby. Touch targets: minimum 44x44px on mobile. Documentation: maintain accessibility statement and conformance report.'
      },
      {
        id: 'ac2',
        label: 'Keyboard Navigation',
        simple: 'Ensure all functionality is keyboard accessible with visible focus.',
        detailed: 'Implement complete keyboard accessibility. Ensure all interactive elements are focusable (buttons, links, inputs, custom controls). Use proper tabindex: 0 for focusable, -1 for programmatic focus, never positive values. Create logical tab order matching visual layout. Add visible focus indicators with sufficient contrast (focus-visible:ring-2). Implement skip links: "Skip to main content", "Skip to navigation". Handle focus trapping in modals - focus stays within, returns on close. Add keyboard shortcuts for common actions with discoverable hints. Support arrow key navigation in menus, tabs, and custom widgets. Use roving tabindex for composite widgets. Test entire app using only keyboard.',
        advanced: 'Implement complete keyboard accessibility for all interactive functionality. Focus management: all interactive elements focusable (button, a, input, select, textarea, [tabindex="0"]), tabindex usage (0 for custom focusable, -1 for programmatic focus, NEVER positive values which break natural order), logical tab order matching visual layout (use CSS order/flex carefully). Focus indicators: focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-blue-500 focus-visible:ring-offset-2, minimum 3:1 contrast against all backgrounds, visible in both light/dark modes. Skip links: first focusable element, sr-only focus:not-sr-only, target has id and tabindex="-1" for receiving focus. Focus trapping: modals keep focus within until closed (Tab cycles through focusable elements), return focus to trigger element on close, implement with useEffect tracking and event listeners. Keyboard shortcuts: common actions (Ctrl+S save, Escape close), show hints in UI or help modal, don\'t conflict with browser/screen reader shortcuts, provide alternative for single-key shortcuts. Arrow key navigation: menus (up/down), tabs (left/right), grids (all arrows), implement roving tabindex (only one item tabindex=0, others -1, move 0 with arrows). Composite widgets: toolbar, listbox, tree, grid - follow WAI-ARIA patterns. Testing: navigate entire app with Tab, Shift+Tab, Enter, Space, Escape, arrow keys; verify no focus traps except modals; ensure all functionality reachable. Focus visible polyfill: consider for consistent behavior across browsers.'
      },
      {
        id: 'ac3',
        label: 'Screen Reader Support',
        simple: 'Add ARIA labels and live regions for screen reader compatibility.',
        detailed: 'Enhance screen reader compatibility throughout application. Add aria-label for icon-only buttons and links. Use aria-labelledby and aria-describedby to associate labels with content. Implement aria-live regions for dynamic content updates ("polite" for non-urgent, "assertive" for critical). Add role attributes for custom widgets: role="button", role="dialog", role="tablist", etc. Use aria-expanded for collapsible content, aria-selected for tabs, aria-checked for toggles. Hide decorative elements with aria-hidden="true". Announce page changes in SPAs. Add aria-current for navigation. Test with VoiceOver (Mac), NVDA (Windows), and mobile screen readers. Ensure form errors are announced.',
        advanced: 'Enhance screen reader compatibility with comprehensive ARIA implementation. Labeling: aria-label for icon-only buttons ("Close", "Search", "Menu"), aria-labelledby to reference visible text (dialog title, section header), aria-describedby for supplementary info (hint text, error messages). Live regions: aria-live="polite" for non-urgent updates (search results loaded, form saved), aria-live="assertive" for critical alerts (errors, time-sensitive), aria-atomic="true" to announce entire region, aria-relevant for what changes matter. Role attributes: role="button" on clickable non-button elements, role="dialog" with aria-modal="true" for modals, role="tablist/tab/tabpanel" for tabs, role="alert" for error messages, role="status" for non-critical updates. State attributes: aria-expanded for collapsible (accordions, dropdowns), aria-selected for tabs and listbox options, aria-checked for checkboxes/toggles, aria-pressed for toggle buttons, aria-current="page" for current navigation item, aria-invalid="true" for invalid inputs. Hiding content: aria-hidden="true" for decorative icons/images, inert attribute for background content when modal open. SPA navigation: announce route changes (aria-live region or focus management), manage focus on page change. Testing protocol: VoiceOver (Mac): Cmd+F5 enable, use rotor; NVDA (Windows): free download, test with browse/focus modes; TalkBack (Android) and VoiceOver (iOS) for mobile. Common patterns: proper table markup with headers and scope, figure with figcaption, progress indicators with aria-valuenow. First rule of ARIA: don\'t use ARIA if native HTML works.'
      },
      {
        id: 'ac4',
        label: 'Color Contrast',
        simple: 'Fix color contrast issues to meet 4.5:1 ratio for text.',
        detailed: 'Fix all color contrast issues for accessibility compliance. Use contrast checking tools to verify ratios. Normal text (under 18px or 14px bold): minimum 4.5:1 ratio. Large text (18px+ or 14px+ bold): minimum 3:1 ratio. UI components and graphics: minimum 3:1 ratio against adjacent colors. Update low contrast combinations: light gray text on white, colored text on colored backgrounds. Ensure links are distinguishable from regular text (not just by color). Check contrast in both light and dark modes. Use sufficient contrast for placeholder text. Verify disabled states are still readable. Test with colorblind simulation tools. Provide alternative indicators beyond color alone (icons, patterns, underlines).',
        advanced: 'Fix all color contrast issues for WCAG AA/AAA compliance. WCAG requirements: normal text (<18px or <14px bold) needs 4.5:1 minimum (7:1 for AAA), large text (≥18px or ≥14px bold) needs 3:1 minimum (4.5:1 for AAA), UI components and graphical objects need 3:1 against adjacent colors. Tools: browser devtools accessibility panel, WebAIM Contrast Checker, Stark plugin, axe DevTools. Common violations to fix: light gray text on white (text-gray-400 on white fails - use text-gray-600+), colored text on colored backgrounds (blue on purple), placeholder text (often too light), disabled states (still need to be perceivable). Links: must be distinguishable from surrounding text by more than color (add underline, font-weight, or icon), visited vs unvisited distinction. Mode testing: verify in both light and dark modes, ensure theme toggle doesn\'t break contrast. Focus indicators: ring color must contrast with background. Beyond color: never use color alone to convey meaning (add icons, text, patterns for errors, status, required fields). Colorblind considerations: test with Sim Daltonism or browser extensions, avoid red/green only distinctions, use patterns or shapes as backup. Interactive states: hover, active, focus states all need sufficient contrast. Disabled elements: use opacity-50 or similar but ensure still perceivable (don\'t rely on color to show disabled). Text over images: add overlay or text shadow for reliable contrast. Dynamic content: ensure programmatically-added content maintains contrast.'
      },
      {
        id: 'ac5',
        label: 'Focus Indicators',
        simple: 'Add visible focus indicators for all interactive elements.',
        detailed: 'Add clear, consistent focus indicators for all interactive elements. Default style: focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-blue-500 focus-visible:ring-offset-2. Ensure focus ring has sufficient contrast (3:1) against all backgrounds. Use focus-visible instead of focus to avoid showing on mouse click. Style focus indicators consistently across the application. Custom focus styles for specific components: cards, images, custom widgets. Ensure focus indicator is visible in both light and dark modes. Add focus states to custom form controls (switches, checkboxes, radio buttons). Make focus indicator offset from element edge for visibility. Test focus appearance at different zoom levels. Never remove outline without providing alternative.',
        advanced: 'Add clear, consistent focus indicators for all interactive elements meeting WCAG requirements. Default style: focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-blue-500 focus-visible:ring-offset-2 focus-visible:ring-offset-white (adjust offset color for dark mode). Why focus-visible: shows focus on keyboard navigation but not mouse click, better UX while maintaining accessibility. Contrast requirements: focus indicator needs 3:1 contrast against adjacent colors, on all backgrounds (light, dark, images, gradients). Consistency: apply same focus style across all interactive elements (buttons, links, inputs, custom controls), consider creating Tailwind @apply class for reuse. Custom components: cards (entire card focusable if clickable), images (in galleries/carousels), custom switches/checkboxes (ensure ring visible around control), dropdown triggers, accordions. Dark mode: adjust ring-offset-gray-900 or ring-white for visibility on dark backgrounds. Ring offset importance: offset creates separation from element edge, making indicator visible regardless of element background. Custom form controls: native inputs have built-in focus, but custom replacements need explicit styling. Never: remove outline without replacement (outline-none alone is accessibility fail), use color-only focus indicators (must have shape change). Testing: Tab through entire application, verify focus visible everywhere, test at 200% zoom (focus shouldn\'t be cropped), test on varied backgrounds. Enhanced focus: consider :focus-within for parent highlighting when child focused (search containers, form groups). High contrast mode: ensure focus remains visible in forced-colors mode.'
      },
      {
        id: 'ac6',
        label: 'Skip Links',
        simple: 'Add skip navigation links for keyboard users.',
        detailed: 'Implement skip navigation links for keyboard users. Add visually hidden skip link as first focusable element: "Skip to main content". Style: sr-only by default, visible on focus (focus:not-sr-only focus:absolute focus:top-4 focus:left-4 focus:z-50 focus:p-4 focus:bg-white). Link target: main content area with id="main-content" and tabindex="-1". Add additional skip links for complex pages: "Skip to navigation", "Skip to footer", "Skip to search". Ensure skip link targets receive focus properly (tabindex="-1" on non-interactive targets). Position skip links appropriately when visible. Test skip links with keyboard navigation. Consider skip links for repeated sidebar content on mobile. Style consistently with site design when visible.',
        advanced: 'Implement skip navigation links allowing keyboard users to bypass repetitive content. Primary skip link: first focusable element in DOM, appears before header/navigation. Link text: "Skip to main content" (or "Skip to content"). Styling: sr-only normally (position: absolute, clip: rect(0,0,0,0)), visible on focus (focus:not-sr-only focus:fixed focus:top-4 focus:left-4 focus:z-[100] focus:p-4 focus:bg-white focus:text-blue-600 focus:shadow-lg focus:rounded). Target setup: main content area needs id="main-content" and tabindex="-1" for receiving focus, focus should move to target on click. Implementation: <a href="#main-content" className="sr-only focus:not-sr-only ...">Skip to main content</a> as first child of body or layout. Multiple skip links for complex pages: "Skip to navigation" (for mega menus), "Skip to search" (prominent search), "Skip to footer" (contact info). Skip link group: if multiple, show as a row of links on focus (first link receives focus, Tab moves through group). Target considerations: tabindex="-1" on non-interactive targets (main, section), ensures focus moves without adding to tab order. Testing: press Tab immediately after page load, skip link should be first thing focused and visible, clicking should move focus past navigation. Responsive: on mobile with drawer navigation, skip link less critical but still valuable. Scroll behavior: browser should scroll target into view, consider scroll-margin-top if fixed header. Alternative: skip-link alternatives like landmark navigation (screen readers can jump to nav, main, etc.) complement but don\'t replace skip links.'
      },
      {
        id: 'ac7',
        label: 'Alt Text',
        simple: 'Add descriptive alt text to all images and icons.',
        detailed: 'Add appropriate alt text to all images and media. Informative images: describe content and function ("Team photo showing five employees in office"). Decorative images: use empty alt="" to hide from screen readers. Functional images (buttons, links): describe the action ("Search", "Close menu", "Download PDF"). Complex images (charts, diagrams): provide detailed description or link to text alternative. Icons: use aria-label on parent button/link, aria-hidden on icon SVG. Background images with text: ensure text is in HTML, not just visual. Logo images: company name as alt text. Avoid redundant descriptions ("Image of...", "Photo of..."). Image links: alt describes destination. Review all img elements, SVGs, and CSS background images.',
        advanced: 'Add appropriate alt text to all images and media following best practices. Image types and alt text: 1) Informative images: describe content and function concisely ("Team of five engineers collaborating at whiteboard"), 2) Decorative images: alt="" (empty, not absent) to hide from AT, or use CSS background, 3) Functional images (in links/buttons): describe destination/action ("Search products", "Open settings"), 4) Images of text: include the text in alt, 5) Complex images (charts, diagrams): brief alt + longer description via aria-describedby or link to text alternative. Writing good alt text: be concise (typically under 125 chars), don\'t start with "Image of" or "Photo of" (AT already announces image), include relevant details based on context, consider what information the image conveys. Icons in buttons/links: icon itself has aria-hidden="true", parent element has aria-label describing action (<button aria-label="Search"><SearchIcon aria-hidden="true" /></button>). Standalone meaningful icons: use aria-label on SVG or wrap in span with sr-only text. Logo images: alt="Company Name" (home link) or alt="Company Name logo" for footer. Background images with text: ensure text is in HTML, not burned into image; if text is in image, provide alternative. Image links: alt describes destination, not image content. Figure and figcaption: use for images with captions, figcaption provides visible description. Testing: disable images, can you still understand the content? Screen reader testing to hear how images announced. SVGs: add role="img" and aria-label, or title element with unique ID and aria-labelledby. Review: audit all img, svg, [role="img"], and CSS background-image for appropriate alt text or hiding.'
      },
      {
        id: 'ac8',
        label: 'Form Labels',
        simple: 'Ensure all form inputs have proper labels.',
        detailed: 'Ensure all form inputs have proper labels and accessibility support. Associate labels with inputs using htmlFor matching input id. Wrap inputs in label elements for implicit association. Add aria-label for inputs without visible labels (search boxes). Use aria-describedby to connect inputs with hint text and error messages. Group related inputs with fieldset and legend (radio groups, checkbox groups). Add aria-required="true" for required fields, show visually with asterisk or text. Error messages: associate with aria-describedby, use role="alert" for dynamic errors. Input validation: use aria-invalid="true" when invalid. Placeholder text: supplement labels, don\'t replace them. Ensure autocomplete attributes are set correctly. Test forms with screen readers.',
        advanced: 'Ensure all form inputs have proper labels and accessibility support. Label association methods: 1) Explicit label with htmlFor matching input id (<label htmlFor="email">Email</label><input id="email">), 2) Implicit wrapping (<label>Email <input /></label>), 3) aria-label for inputs without visible labels (search boxes: <input aria-label="Search products">), 4) aria-labelledby to reference another element. Descriptive text: use aria-describedby to connect inputs with hint text ("Password must be 8+ characters") and error messages, multiple IDs supported (aria-describedby="hint error"). Grouping: fieldset + legend for related inputs (radio groups, checkbox groups, address sections), legend provides group label. Required fields: aria-required="true" on input, visual indicator (* or "Required") with legend explaining ("* Required fields"). Error handling: aria-invalid="true" when validation fails, error message linked via aria-describedby, role="alert" or aria-live="polite" for dynamically shown errors so they\'re announced, error message should be specific ("Email must include @"). Placeholder text: never use as only label (disappears on input, insufficient contrast), use for examples or hints that supplement visible label. Autocomplete: set correct values for common fields (email, name, tel, postal-code, cc-number) for autofill and AT. Input types: use appropriate type (email, tel, url, number) for validation and mobile keyboards. Forms testing: screen reader testing through entire form submission flow, verify all labels announced, errors caught. Additional: instructions at top of form, clear submit button text ("Create Account" not "Submit"), success/error feedback accessible.'
      },
      {
        id: 'ac9',
        label: 'Reduce Motion',
        simple: 'Respect user motion preferences with prefers-reduced-motion.',
        detailed: 'Respect user motion preferences with prefers-reduced-motion. Wrap animations in media query: @media (prefers-reduced-motion: no-preference). In Tailwind: motion-safe:animate-bounce, motion-reduce:transition-none. Affected animations: transitions, transforms, scroll-triggered animations, auto-playing carousels, parallax effects, loading spinners. Provide static alternatives: instant state changes instead of transitions, static images instead of videos. Keep essential motion for understanding (progress indicators) but simplify. Disable auto-play on videos and carousels. Reduce or remove parallax scrolling effects. Test with system settings: macOS Accessibility > Display > Reduce motion, Windows Settings > Ease of Access > Display. Consider providing manual animation toggle in UI settings.',
        advanced: 'Respect user motion preferences for users with vestibular disorders or motion sensitivity. Media query: @media (prefers-reduced-motion: reduce) { /* disable or reduce animations */ }. Tailwind utilities: motion-safe: prefix for animations that only run without reduced motion preference (motion-safe:animate-bounce), motion-reduce: prefix for reduced motion alternatives (motion-reduce:transition-none). What to reduce/disable: transitions longer than ~100ms, transforms (scale, rotate, translate animations), scroll-triggered animations, parallax effects, auto-playing carousels/sliders, loading spinners with rotation, page transition animations, hover animations, infinite animations. What to keep (simplified): progress indicators (essential information), loading states (can use pulse instead of spin), focus transitions (quick, <100ms). Implementation strategies: 1) Conditional classes based on media query, 2) CSS @media at-rules for global reduction, 3) useReducedMotion hook for complex cases. CSS approach: @media (prefers-reduced-motion: reduce) { *, *::before, *::after { animation-duration: 0.01ms !important; transition-duration: 0.01ms !important; } }. Alternative content: static images instead of videos/GIFs, instant state changes instead of transitions. Testing: macOS: System Preferences > Accessibility > Display > Reduce motion, Windows: Settings > Ease of Access > Display > Show animations, iOS: Settings > Accessibility > Motion > Reduce Motion. Manual toggle: consider adding animation toggle in app settings for users who prefer reduction but haven\'t set system preference. Videos: autoplay with muted and playsinline, provide pause control, respect preference by not autoplaying if reduced motion.'
      },
      {
        id: 'ac10',
        label: 'High Contrast Mode',
        simple: 'Support Windows High Contrast Mode and provide enhanced contrast.',
        detailed: 'Support Windows High Contrast Mode and provide enhanced contrast option. Use CSS forced-colors media query: @media (forced-colors: active). Ensure UI remains functional when colors are overridden - don\'t rely solely on color. Add visible borders that appear in high contrast mode (transparent by default, visible when forced). Use system colors for forced-colors: Canvas, CanvasText, LinkText, ButtonFace, ButtonText. Test with Windows High Contrast themes. Create optional high contrast theme toggle in settings. High contrast theme: increase all contrast ratios, add borders, use solid colors instead of gradients, increase font weights. Ensure focus indicators work in high contrast. Test interactive state visibility (hover, active, disabled).',
        advanced: 'Support Windows High Contrast Mode and provide enhanced contrast options for users with low vision. Forced colors mode: Windows High Contrast overrides your colors - detect with @media (forced-colors: active). Design for forced colors: don\'t rely solely on color (add borders, icons, text), ensure UI structure remains understandable when colors change, use transparent borders that become visible (border: 1px solid transparent becomes visible in HC mode). System colors for forced-colors: Canvas (background), CanvasText (text), LinkText (links), ButtonFace (button backgrounds), ButtonText (button text), Highlight (selected), HighlightText (selected text), GrayText (disabled). Forced-colors CSS: @media (forced-colors: active) { .card { border: 2px solid ButtonText; } .icon { forced-color-adjust: none; /* preserve custom colors if intentional */ } }. Testing: Windows Settings > Ease of Access > High contrast, try different themes (High Contrast Black, White, #1, #2). Custom high contrast theme in app: toggle in settings, increases all contrast ratios to 7:1+, adds visible borders to all containers, uses solid colors instead of gradients, increases font weights, enlarges focus indicators. Focus in high contrast: ensure ring/outline visible regardless of theme (use system Highlight color or solid border). Interactive states: hover, active, disabled must remain distinguishable in high contrast (use borders, underlines, transparency). Gradients and shadows: replaced by solid colors in forced colors - ensure buttons, cards still recognizable. Images and icons: can preserve colors with forced-color-adjust: none where meaning is conveyed (logos, status icons), but ensure alternatives exist.'
      },
      {
        id: 'ac11',
        label: 'Touch Target Size',
        simple: 'Ensure all interactive elements have minimum 44x44px touch targets.',
        detailed: 'Ensure all interactive elements meet minimum touch target size for mobile accessibility. WCAG 2.2 requires 44x44 CSS pixels minimum. Apply min-h-11 min-w-11 (44px) to all buttons, links, and interactive controls. For inline links within text, ensure adequate line height (leading-loose). Icon buttons: even if icon is smaller, clickable area should be 44px. Form inputs: ensure adequate height for touch. Close buttons: don\'t place too close to edges. Navigation items: ensure comfortable spacing. Touch target spacing: minimum 8px gap between adjacent targets to prevent accidental taps. Use padding for larger targets without affecting visual design.',
        advanced: 'Ensure all interactive elements meet minimum touch target size requirements. WCAG 2.2 Level AA: minimum 44x44 CSS pixels (Target Size Enhanced: 24x24 minimum). Apply consistently: min-h-11 min-w-11 (44px in Tailwind) to buttons, links, form controls, checkboxes, radio buttons, toggles. Implementation strategies: use padding to expand touch area without changing visual size, wrapper element with click handler if padding not possible, pseudo-element ::before/::after with position absolute and larger size. Icon buttons: even if icon is 20px, clickable area should be 44px (p-3 around 20px icon). Inline text links: ensure adequate line height (leading-loose or leading-relaxed), consider underlining to make tap target visible. Form inputs: min-h-11 for inputs, selects, textareas. Close buttons: don\'t place too close to screen edges (minimum 8px margin), ensure thumb can reach. Navigation: comfortable spacing between items (gap-2 minimum). Touch target spacing: minimum 8px gap between adjacent interactive elements to prevent accidental activation. Testing: use browser devtools device mode, test on actual mobile devices, check with large finger simulation. Small targets with adequate spacing: allowed if 24px minimum with no overlapping targets. Exception: inline text links can be smaller if text block has 24px+ height. Mobile-first: design for touch then adapt for mouse, not reverse.'
      },
      {
        id: 'ac12',
        label: 'Error Announcement',
        simple: 'Announce form errors to screen readers when they occur.',
        detailed: 'Ensure form validation errors are announced to screen readers immediately. Use aria-live="polite" region for error summary or individual errors. Link error messages to inputs with aria-describedby. Add aria-invalid="true" to invalid inputs. Error message container: role="alert" for critical inline errors. Focus management: on form submit with errors, focus first invalid field or error summary. Error format: "Error: [field name] - [problem and solution]". Visual + audible: red text/border plus screen reader announcement. Clear errors when user corrects them. Test complete error flow with screen readers.',
        advanced: 'Ensure form validation errors are fully accessible and announced to screen readers. Announcement methods: aria-live="polite" region for error summary (updates on submit), role="alert" for individual critical errors that need immediate attention. Link errors to inputs: aria-describedby="email-error" on input, matching id on error message span. Input state: aria-invalid="true" when field is invalid, remove when corrected. Error message format: specific and actionable ("Email address must include @" not "Invalid"), include field name for context when read in isolation. Focus management: on submit with errors, either focus first invalid field or focus error summary at top. Error summary pattern: list of errors linking to respective fields, announced when appearing. Inline errors: position near input (below or beside), associate with aria-describedby. Visual indicators: red text (text-red-600), red border (border-red-500), error icon (XCircle), plus text for color-blind users. Clear errors: remove aria-invalid and hide error message when user corrects input (on blur or change). Real-time validation: announce corrections positively ("Email format is now valid") using aria-live. Testing: complete form with errors using VoiceOver/NVDA, verify errors announced, verify focus moves appropriately. Avoid: error-only announcements without visual indication, clearing errors only on submit.'
      },
      {
        id: 'ac13',
        label: 'Dialog Accessibility',
        simple: 'Make modal dialogs fully accessible with focus trapping and ARIA.',
        detailed: 'Implement fully accessible modal dialogs. Structure: role="dialog" aria-modal="true" aria-labelledby="dialog-title". Focus trap: Tab cycles within dialog, doesn\'t escape to background. Initial focus: first focusable element or dialog itself (tabindex="-1"). Return focus: to trigger element when dialog closes. Escape key: closes dialog. Background: aria-hidden="true" on content behind dialog, or use inert attribute. Overlay: clicking closes dialog (optional, confirm for important dialogs). Scrolling: prevent body scroll when open. Announce: dialog title read on open. Close button: accessible, labeled "Close dialog".',
        advanced: 'Implement fully accessible modal dialogs following WAI-ARIA Authoring Practices. Structure: role="dialog", aria-modal="true", aria-labelledby pointing to dialog title id, optional aria-describedby for description. Focus trap implementation: on open, save previously focused element, move focus to first focusable item in dialog (or dialog itself with tabindex="-1"), Tab key cycles only through dialog elements (wrap from last to first), Shift+Tab wraps from first to last. Focus trap code: add keydown listener, detect Tab/Shift+Tab, if target is last focusable and Tab, focus first, if target is first and Shift+Tab, focus last. Return focus: store document.activeElement before opening, restore on close (triggerRef.current.focus()). Escape key: add keydown listener for Escape, call close function. Background treatment: add aria-hidden="true" to app root content (not dialog), or use inert attribute on siblings, prevents AT accessing background content. Click outside: overlay click closes dialog (but consider confirmation for destructive actions). Body scroll lock: add overflow-hidden to body when open, restore on close. Animation: don\'t autofocus until transition complete. Close button: position top-right, aria-label="Close dialog" or "Close" with visually hidden text. Alert dialogs: use role="alertdialog" for critical dialogs requiring user action, don\'t auto-close. Testing: Tab through entire dialog, verify can\'t Tab to background, verify Escape closes, test with screen reader.'
      },
      {
        id: 'ac14',
        label: 'Table Accessibility',
        simple: 'Add proper headers and scope attributes to data tables.',
        detailed: 'Make data tables fully accessible. Use semantic table elements: table, thead, tbody, tr, th, td. Header cells: use th with scope="col" for column headers, scope="row" for row headers. Caption: add caption element describing table content. Complex tables: use id/headers attributes for cells spanning multiple rows/columns. Responsive tables: maintain relationships on mobile (don\'t just linearize). Sortable columns: aria-sort="ascending|descending|none". Summary: add description if table is complex. Avoid: layout tables (use CSS grid/flexbox instead), missing headers, tables for non-tabular data.',
        advanced: 'Make data tables fully accessible for screen reader navigation. Semantic structure: table element (not divs), thead for header row(s), tbody for data rows, tfoot for summary row(s), tr for rows, th for header cells, td for data cells. Header associations: th scope="col" for column headers, th scope="row" for row headers (first cell in each row if applicable). Table caption: caption element as first child of table, describes table purpose. Complex tables with merged cells: use id on th cells and headers attribute on td cells listing associated th ids. Simple table example: <table><caption>Sales Data</caption><thead><tr><th scope="col">Product</th><th scope="col">Q1</th></tr></thead><tbody><tr><th scope="row">Widget</th><td>$500</td></tr></tbody></table>. Sortable tables: th has button inside for sorting, aria-sort="ascending|descending|none" on th indicating current sort state. Responsive tables: maintain associations (don\'t just stack cells), horizontal scroll wrapper, or reformat to cards with explicit labels. Empty cells: use data or appropriate indicator, not completely empty. Avoid: layout tables (use CSS grid/flexbox), divs with display:table, missing th elements, tables for non-tabular data. Testing: navigate table with screen reader table navigation (Ctrl+Alt+Arrow keys in VoiceOver), verify headers announced with each cell. Consider: sticky headers for long tables, row selection checkboxes with proper labeling.'
      },
      {
        id: 'ac15',
        label: 'Live Regions',
        simple: 'Add ARIA live regions for dynamic content updates.',
        detailed: 'Implement ARIA live regions for dynamic content announcements. Types: aria-live="polite" (waits for pause in speech), aria-live="assertive" (interrupts immediately). Use cases: form validation messages, search results count, loading states, save confirmations, chat messages, notifications. Status messages: role="status" with aria-live="polite" for non-critical updates. Alert messages: role="alert" with aria-live="assertive" for critical information. Avoid: overusing assertive (annoying), announcing too frequently, announcing unchanged content. Best practice: announce meaningful changes, keep messages concise, test with actual screen readers.',
        advanced: 'Implement ARIA live regions for announcing dynamic content changes to screen readers. Live region politeness levels: aria-live="polite" (queued, read during speech pauses) for non-urgent updates, aria-live="assertive" (interrupts immediately) for critical alerts only. Built-in live region roles: role="status" (implicit polite) for status updates, role="alert" (implicit assertive) for errors/warnings, role="log" for chat/activity logs, role="timer" for countdown displays. Atomic vs non-atomic: aria-atomic="true" announces entire region content on any change, aria-atomic="false" (default) announces only changed nodes. Relevant changes: aria-relevant="additions" (default, new content), "removals" (content removed), "text" (text changes), "all" (everything). Common use cases: form validation ("Email is invalid"), search results ("24 results found"), save status ("Changes saved"), loading states ("Loading content..."), cart updates ("Item added to cart"), notifications, chat messages. Implementation: create hidden live region, update its text content when events occur. Avoid: too many announcements (fatiguing), assertive for non-critical info, empty live regions that later fill, announcing on every keystroke. Testing: actually use screen readers (VoiceOver, NVDA) to verify announcements occur and are understandable. Timing: some readers need element to exist before populating, consider rendering empty region on mount.'
      },
      {
        id: 'ac16',
        label: 'Autocomplete Accessibility',
        simple: 'Make autocomplete/combobox components fully accessible.',
        detailed: 'Implement accessible autocomplete following combobox pattern. Structure: input with role="combobox", listbox popup with role="listbox". States: aria-expanded="true|false" on input, aria-activedescendant pointing to highlighted option. Options: role="option" with aria-selected on selected item. Keyboard: down arrow opens and navigates, up arrow navigates, Enter selects, Escape closes. Announce: selection changes to screen reader. Live region: announce result count ("5 results available"). Clear button: accessible label. No results: announce "No results found" message.',
        advanced: 'Implement accessible autocomplete following WAI-ARIA Combobox pattern. Input element: role="combobox", aria-autocomplete="list" (or "both" if also completes), aria-haspopup="listbox", aria-expanded="true|false", aria-controls="listbox-id", aria-activedescendant="option-id" (currently highlighted). Listbox element: role="listbox", id matching aria-controls, rendered below input when expanded. Options: role="option", unique id for aria-activedescendant, aria-selected="true" on currently selected item (if any). Keyboard navigation: down arrow opens listbox if closed and highlights first option, up/down arrows move highlight through options, Enter selects highlighted option and closes, Escape closes without selection, Tab closes and moves focus. Mouse: clicking option selects it, hovering highlights. Visual highlight: clear highlight styling on active option. Live announcements: aria-live region announces result count ("5 suggestions available", "No results"), optionally announce highlighted option. Clear button: visible when input has value, aria-label="Clear search" or similar. Loading state: announce when searching ("Searching..."), show spinner. Grouping: optgroup pattern with role="group" and aria-label if options are grouped. No results: visible "No results found" message, announced via live region. Implementation: consider Downshift, React-Aria, or Radix UI for battle-tested implementations. Testing: navigate with keyboard only, test with screen reader, verify all states announced.'
      },
      {
        id: 'ac17',
        label: 'Accessible Tabs',
        simple: 'Implement accessible tab interface with proper ARIA roles.',
        detailed: 'Build accessible tabs following WAI-ARIA pattern. Structure: tablist with role="tablist", tab buttons with role="tab", panels with role="tabpanel". Associations: aria-controls on tab pointing to panel id, aria-labelledby on panel pointing to tab id. States: aria-selected="true" on active tab. Keyboard: Arrow keys move between tabs, Tab moves to panel content. Activation: automatic (arrows activate) or manual (Enter/Space activates). Focus management: roving tabindex pattern (active tab tabindex="0", others tabindex="-1"). Panel association: panel shows when its tab is selected.',
        advanced: 'Build accessible tabs following WAI-ARIA Tabs pattern. Container: role="tablist", optional aria-label describing the tab group. Tab buttons: role="tab", id for panel reference, aria-controls="panel-id", aria-selected="true|false". Tab panels: role="tabpanel", id matching aria-controls, aria-labelledby="tab-id", tabindex="0" for keyboard access. Roving tabindex: selected tab has tabindex="0", unselected tabs have tabindex="-1", only selected tab in tab order. Keyboard navigation: Left/Right arrows move between horizontal tabs (Up/Down for vertical), arrows wrap from end to start, Tab key moves from tabs to panel content. Activation mode: automatic (arrows immediately show panel) is recommended, manual (arrows just move focus, Enter/Space activates) is alternative. Orientation: aria-orientation="horizontal" (default) or "vertical" for vertical tabs, affects which arrows work. Focus visible: clear focus indicator on focused tab. Disabled tabs: aria-disabled="true", style as disabled, skip in arrow navigation. Panel rendering: can render all panels and hide non-selected with hidden attribute, or conditionally render only selected. Animations: fade or slide transitions for panel changes. Persistence: optionally save selected tab to URL hash or localStorage. Mobile: consider switching to accordion pattern on small screens. Testing: Tab to tablist, arrow through tabs, Tab to panel, verify screen reader announces tab name and selected state.'
      },
      {
        id: 'ac18',
        label: 'Accessible Accordion',
        simple: 'Create accessible accordion with proper expand/collapse behavior.',
        detailed: 'Build accessible accordion component. Trigger: button with aria-expanded="true|false", aria-controls pointing to content panel. Content panel: id matching aria-controls, role="region" with aria-labelledby pointing to button. Keyboard: Enter/Space toggles, up/down arrows move between buttons (optional). Focus: remains on button after toggle. Animation: smooth height transition using grid-rows or max-height. Multiple open: allow or restrict to single open panel. Icons: chevron rotates indicating state, aria-hidden on icon. Heading: wrap button in heading element for semantics.',
        advanced: 'Build accessible accordion component following disclosure pattern. Trigger element: button element (not div with onClick), wrapped in heading (h3, h4, etc.) for proper document outline, aria-expanded="true|false" indicating state, aria-controls="panel-id" linking to content. Content panel: id matching aria-controls, role="region" with aria-labelledby="button-id" (or omit region role for simple content), hidden when collapsed. Expand/collapse: toggle aria-expanded and panel visibility on button click. Keyboard: Enter/Space on button toggles panel, optionally arrow keys move between accordion buttons (like tabs). Focus management: focus stays on button after toggle, don\'t auto-focus content. Single vs multiple: decide if only one panel can be open (like exclusive) or multiple (independent), no ARIA difference but UX consideration. Animation: CSS transition on max-height or grid-template-rows for smooth expand/collapse, ensure not jarring for reduced motion preference. Icons: ChevronDown that rotates 180deg when expanded, aria-hidden="true" on decorative icon. State persistence: optionally save open panels to localStorage. Nested accordions: ensure heading levels remain logical. Screen reader testing: verify "expanded"/"collapsed" state announced, button label read, content accessible when expanded. Default state: consider which panels (if any) start expanded. Group label: if accordion group has overall label, wrap in section with aria-label.'
      },
      {
        id: 'ac19',
        label: 'Heading Structure',
        simple: 'Fix heading hierarchy to use proper h1-h6 levels.',
        detailed: 'Audit and fix heading hierarchy for accessibility. Rules: single h1 per page (main title), headings in logical order (h1 → h2 → h3), don\'t skip levels (no h1 → h3), use for structure not styling. Page structure: h1 for page title, h2 for major sections, h3 for subsections, etc. Cards/components: appropriate heading level based on context (h2 in main, h3 in sidebar). Styling: use text utilities for size (text-2xl, text-xl) independent of heading level. Navigation: consider headings for nav sections. Test: create outline of headings, should read like table of contents. Screen readers use headings for navigation shortcuts.',
        advanced: 'Audit and fix heading hierarchy for accessible document structure and navigation. Core rules: exactly one h1 per page (main page title), descending order without skips (h1 → h2 → h3, never h1 → h3), headings represent document outline. Page structure: h1 for page title (often in header or hero), h2 for major sections (sidebar nav, main content sections, footer sections), h3 for subsections, h4-h6 for deeper nesting. Context-dependent levels: in a sidebar widget, if main content uses h2, sidebar can also use h2 (parallel sections); within a card inside main, use h3 if card is in h2 section. Styling independence: use heading element for semantics, CSS for appearance - a h3 can be styled larger than h2 if design requires, use text-3xl font-bold on h3 without changing semantic level. Component design: accept heading level as prop (as="h2") for reusable components to adapt to context. Hidden headings: use sr-only class for headings that help screen reader navigation but aren\'t visible ("Navigation", "Main content"). Navigation: major nav regions benefit from headings for orientation. Landmarks vs headings: landmarks (nav, main, aside) provide region navigation, headings provide content structure - both valuable. Testing: browser extensions show heading outline, should read like table of contents; screen reader users navigate by heading (H key in VoiceOver), verify all content reachable. Avoid: using bold text instead of headings, empty headings, headings for styling only without structural meaning.'
      },
      {
        id: 'ac20',
        label: 'Landmark Regions',
        simple: 'Add ARIA landmarks to define page regions.',
        detailed: 'Implement ARIA landmark regions for screen reader navigation. Use semantic HTML5 elements: header (banner), nav (navigation), main (main), aside (complementary), footer (contentinfo). Explicit roles: add role attribute when element doesn\'t have implicit landmark. Labels: aria-label or aria-labelledby for multiple landmarks of same type (e.g., two nav regions). Required landmarks: every page needs main. Nesting: banner and contentinfo must not be nested. Single main: only one main landmark per page. Test: screen reader landmark navigation (rotor in VoiceOver) shows all regions.',
        advanced: 'Implement ARIA landmark regions for screen reader navigation and orientation. HTML5 landmarks with implicit roles: header (banner - not inside article/section), nav (navigation), main (main), aside (complementary - not inside article/section), footer (contentinfo - not inside article/section), section with aria-label/labelledby (region), form with accessible name (form). Required landmark: main - every page must have exactly one main landmark containing primary content. Labeling multiple landmarks: if page has multiple nav elements, add aria-label to distinguish ("Primary navigation", "Footer navigation"); same for multiple aside elements. Page structure example: header role="banner", nav aria-label="Main", main, aside aria-label="Related content", footer role="contentinfo". Explicit roles: add when HTML element doesn\'t have implicit role or for older browser support. Nesting rules: banner and contentinfo should not be inside article, aside, main, nav, or section; main should not be inside these either. Search landmark: role="search" on form or div containing search functionality. Testing: use screen reader landmark navigation (VoiceOver: Ctrl+Option+U shows landmarks rotor, NVDA: D key cycles landmarks); verify all page regions discoverable. Skip links: complement landmarks, especially useful when landmarks don\'t cover all repetitive content. Avoid: empty landmarks, too many landmarks (cognitive load), landmarks without discernible content.'
      },
      {
        id: 'ac21',
        label: 'Loading State A11y',
        simple: 'Announce loading states to screen reader users.',
        detailed: 'Make loading states accessible for screen reader users. Loading start: announce "Loading..." via aria-live region. Progress: announce percentage updates for long operations (debounced). Completion: announce "Content loaded" or specific success message. Spinner: add aria-label="Loading" and role="status" or aria-live. Loading button: aria-disabled="true", aria-busy="true", change label to "Saving..." or show spinner. Skeleton content: aria-hidden="true" on skeleton, announce when real content loaded. Page loads: manage focus appropriately after load. Avoid: silent loading states, constant announcements.',
        advanced: 'Make loading states accessible for screen reader users through announcements and state indication. Loading announcement: use aria-live="polite" region to announce "Loading content..." when async operation starts. Implementation: hidden div with aria-live, update text content to trigger announcement. Loading button pattern: during load - aria-disabled="true" prevents action, aria-busy="true" indicates processing, update visible text ("Saving...") or add spinner (with aria-hidden="true" on visual spinner, actual status in text). Determinate progress: for file uploads or long operations, periodically announce percentage (debounced to avoid spam, e.g., every 25%). Completion: announce success ("Products loaded", "Saved successfully") or failure ("Load failed, try again"). Skeleton screens: add aria-hidden="true" to skeleton placeholder, skeleton is purely visual while loading; when content loads, announce via live region or manage focus to new content. Spinner component: role="status" or role="progressbar" (for determinate), aria-label="Loading", accessible name. Page/route loading: optionally announce navigation start, focus h1 or main content area after load. Loading overlay: if blocking interaction, ensure focus is trapped or background is inert. Avoid: silent loading (user doesn\'t know something is happening), excessive announcements (every spinner frame), not announcing completion. Test: screen reader experience during various loading scenarios.'
      },
      {
        id: 'ac22',
        label: 'Carousel Accessibility',
        simple: 'Make carousel/slider components fully accessible.',
        detailed: 'Build accessible carousel with proper controls and announcements. Region: role="region" with aria-label describing carousel. Slides: role="group" with aria-roledescription="slide", aria-label="1 of 5". Controls: Previous/Next buttons with clear labels. Pagination: current indicator with aria-current="true". Auto-play: pause button required, pause on hover/focus. Keyboard: arrows navigate slides. Live region: announce current slide on change. Reduce motion: disable auto-play and reduce animations. Focus management: handle focus appropriately when slides change.',
        advanced: 'Build fully accessible carousel following WAI-ARIA Carousel pattern. Container: role="group" (or "region" for important content), aria-roledescription="carousel", aria-label describing content ("Product images", "Testimonials"). Slides container: role="group" or live region for announcements. Individual slides: role="group", aria-roledescription="slide", aria-label="Slide 1 of 5" or actual content description. Visible state: non-visible slides have aria-hidden="true" or inert attribute. Navigation buttons: Previous/Next with clear labels (aria-label="Previous slide"), disabled (aria-disabled) when at boundaries for non-looping. Pagination dots: button elements, current has aria-current="true", aria-label="Go to slide 3". Auto-play requirements: must have pause button (labeled "Pause auto-play"), must pause on hover or keyboard focus within carousel, must respect prefers-reduced-motion. Keyboard: focus on carousel region, arrow keys or Tab navigate slides/controls. Announcements: aria-live region announces current slide ("Slide 2 of 5: Product name") on change, debounce for auto-play. Reduced motion: @media (prefers-reduced-motion: reduce) disables auto-play entirely and uses instant transitions. Focus management: when navigating, focus can move with slide or stay on controls depending on design. Touch: swipe gestures with adequate targets. Testing: navigate with keyboard only, test with screen reader, test with reduced motion enabled.'
      },
      {
        id: 'ac23',
        label: 'Drag and Drop A11y',
        simple: 'Provide accessible alternatives to drag and drop interactions.',
        detailed: 'Make drag and drop functionality accessible. Keyboard alternative: arrow keys to move item, Enter to drop. Reorder buttons: up/down move buttons visible on focus. Grab/drop state: aria-grabbed (deprecated, use aria-describedby for instructions). Instructions: announce how to use keyboard reordering. Live announcements: "Grabbed item 3", "Moved to position 2", "Dropped". Focus management: maintain focus on moved item. Touch: adequate touch targets for drag handles. Selection mode: alternative method using checkboxes and move action. Context: provide clear visual feedback during drag. Test: complete reordering tasks with keyboard only.',
        advanced: 'Make drag and drop functionality accessible with keyboard and screen reader support. Alternative interaction patterns: 1) Arrow keys while focused move item (up/down for lists, arrows for grids), 2) Visible reorder buttons (up/down arrows) appear on focus/hover, 3) Selection mode with checkboxes plus Move To action, 4) Input field to specify position directly. Instructions: aria-describedby linking to instructions text ("Press space to grab, arrows to move, space to drop"). Announcing state changes: live region announces "Picked up [item name]", "Moved to position 3 of 7", "Dropped [item name] in position 3". Focus management: focus remains on item throughout drag operation, item stays focused after drop. Implementation: track isDragging state, keydown handler for space (pick up/drop) and arrows (move), update position in list, announce changes. Library: dnd-kit, react-beautiful-dnd, @dnd-kit/accessibility have built-in a11y support. Visual feedback: clear indication of grabbed state, drop target highlighting, position preview. Mouse/touch DnD: still works normally, a11y is additive. Handle indicators: visible drag handle icon, adequate size for touch. aria-grabbed deprecated: don\'t use, instead rely on instructions and announcements. Multi-item selection: accessible multi-select then batch move. Testing: reorder list items using only keyboard, verify announcements describe what happened.'
      },
      {
        id: 'ac24',
        label: 'Video Accessibility',
        simple: 'Add captions, transcripts, and controls to video content.',
        detailed: 'Make video content accessible. Captions: add WebVTT track with kind="captions", ensure accuracy and timing. Transcript: provide full text transcript link/button. Audio description: separate track describing visual content for blind users. Controls: use native controls or build accessible custom controls. Keyboard: all controls keyboard accessible. Autoplay: avoid, or ensure muted and pausable. Player controls: labeled buttons (Play, Pause, Mute, Fullscreen). Progress: accessible progress bar with keyboard control. Volume: keyboard adjustable. Reduce motion: consider not autoplaying for motion preference.',
        advanced: 'Make video content accessible for all users. Captions: add track element with kind="captions" and WebVTT file, ensure accurate timing and speaker identification, captions describe meaningful audio (not just dialogue - sound effects, music mood). Subtitles vs captions: subtitles for language translation, captions for deaf/hard of hearing (include non-speech audio). Transcript: provide complete text transcript (link below video or expandable section), includes all spoken content plus visual descriptions. Audio description: separate audio track describing important visual content for blind users, kind="descriptions", or extended audio description if pauses needed. Custom controls: if not using native controls, build fully accessible player - all controls keyboard accessible and labeled, focus visible, announced states. Native controls: video controls attribute provides accessible defaults, may need styling overrides. Keyboard controls: Tab to each control, Enter/Space to activate, arrow keys for volume/seek. Autoplay: avoid entirely, or must be muted and have visible pause button. Player state: aria-label on play button updates ("Play"/"Pause"), live region for important state changes. Progress bar: role="slider" with aria-valuenow, aria-valuemin, aria-valuemax, keyboard arrows adjust position. Reduced motion: @media (prefers-reduced-motion) prevents autoplay. Sign language: consider adding sign language interpretation track for deaf users. Test: use player with keyboard only and screen reader.'
      },
      {
        id: 'ac25',
        label: 'Chart Accessibility',
        simple: 'Make data visualizations accessible with text alternatives.',
        detailed: 'Make charts and graphs accessible. Text alternative: provide data table alternative for all charts. Description: aria-label or aria-describedby with chart summary. Patterns: use patterns in addition to colors for differentiation. High contrast: ensure sufficient contrast on all elements. Interactive charts: keyboard navigable data points. Tooltip content: announced to screen readers. Legend: associated with chart, clear labels. Focus order: logical focus order through chart elements. Table toggle: button to switch between chart and table view. Screen reader: describe trends and key insights, not just raw data.',
        advanced: 'Make data visualizations accessible for screen reader users and those with visual impairments. Data table alternative: always provide accessible data table showing same information as chart, toggle button to switch views ("View as table"/"View as chart"). Chart container: role="img" with aria-label describing what chart shows (not raw data, but insight: "Bar chart showing sales increasing 25% from January to March"). Detailed description: aria-describedby linking to longer description for complex charts, describe trends, outliers, key takeaways. Color considerations: don\'t rely on color alone (add patterns, shapes, or direct labels), ensure all colors meet contrast requirements, test with colorblind simulation. High contrast mode: ensure chart remains usable, borders visible, text readable. Interactive charts: keyboard navigable (Tab/arrows move through data points), focus indicator on elements, tooltips announced (aria-live or aria-describedby), keyboard press activates point for details. Chart libraries: Chart.js, Recharts, Victory have varying a11y support, may need enhancement. Live data: announce significant changes via aria-live ("Alert: CPU usage exceeded 90%"). Legend: clearly labeled, associated with chart, interactive legends keyboard accessible. SVG charts: add role="img" and aria-label to svg element, or use title and desc elements with aria-labelledby. Testing: navigate chart with screen reader, verify data is obtainable without vision.'
      },
      {
        id: 'ac26',
        label: 'Notification A11y',
        simple: 'Make toast notifications accessible to screen readers.',
        detailed: 'Make notification/toast system accessible. Role and live region: role="alert" or role="status" with aria-live. Urgency: "assertive" for errors/critical, "polite" for info/success. Auto-dismiss: minimum 5 seconds visible, pause on hover/focus. Action buttons: keyboard accessible, clear labels. Close button: labeled "Dismiss notification". Focus management: optionally focus critical notifications. Queue: don\'t overwhelm with multiple simultaneous notifications. Position: consistent location, don\'t block important content. Screen reader: message content is announced when notification appears.',
        advanced: 'Make notification/toast system accessible for screen reader users. ARIA roles: role="alert" with implicit aria-live="assertive" for errors and critical info, role="status" with implicit aria-live="polite" for success and info. Alert content: entire message text is announced automatically when element appears. Auto-dismiss timing: minimum 5 seconds visible (WCAG 2.2.1), pause timer on hover and focus, option for persistent notifications. Implementation: render notification into existing aria-live container, or ensure notification container has role before content appears. Multiple notifications: queue system, don\'t show more than 1-2 simultaneously, don\'t spam announcements. Action buttons: keyboard accessible (Tab), clear labels ("Undo", "View", "Dismiss"), adequate touch targets. Close/dismiss: always provide close button, labeled "Dismiss notification" or "Close", keyboard accessible (Escape key while focused). Focus management: for critical actionable notifications, move focus to notification; for passive info, don\'t steal focus. Position: consistent location (top-right, bottom-center, etc.), don\'t cover important UI, stack gracefully. Animation: slide/fade in, respect prefers-reduced-motion. History: optionally provide notification history for reviewing dismissed notifications. Testing: trigger various notifications, verify screen reader announces content, test keyboard interaction.'
      },
      {
        id: 'ac27',
        label: 'Date Picker A11y',
        simple: 'Build accessible date picker with keyboard navigation.',
        detailed: 'Create accessible date picker component. Structure: dialog or inline calendar with proper ARIA. Grid: role="grid" for calendar, cells are gridcell or button. Keyboard: Arrow keys navigate days, Page Up/Down for months, Home/End for week start/end. Focus: date cells focusable, clear focus indicator. Current date: marked visually and with aria-current="date". Selected date: aria-selected="true". Labels: month/year heading, day-of-week headers. Buttons: previous/next month with labels. Input: connected with aria-describedby for format hint. Announcements: date announced when focused.',
        advanced: 'Create accessible date picker following ARIA Date Picker pattern. Calendar structure: role="grid" on calendar, role="row" for weeks, role="gridcell" or role="button" for individual days. Month/year header: heading element or role="heading" showing current month and year. Day-of-week headers: role="columnheader" or th in table structure. Navigation buttons: Previous/Next month buttons with aria-label="Previous month, November 2024". Keyboard navigation: Arrow keys move focus between days (wrap weeks), Page Up/Down change months, Page Up/Down + Shift change years, Home/End go to start/end of week, Enter/Space select date. Focus management: roving tabindex on days (focused day has tabindex="0", others tabindex="-1"), clear visible focus indicator. Date states: aria-current="date" on today, aria-selected="true" on selected date, aria-disabled="true" on disabled dates. Input field: text input with date format hint (aria-describedby), opens calendar on focus or button click, accepts typed dates. Calendar display: as dialog (role="dialog") for popup, trap focus when open, Escape closes; or inline always visible. Date announcement: when focus moves to date, announce full date ("Wednesday, January 15, 2025"). Range picker: both dates selected indicated, range highlighted visually. Testing: select date using only keyboard, verify dates announced correctly, test with screen reader.'
      },
      {
        id: 'ac28',
        label: 'Navigation A11y',
        simple: 'Make navigation menus fully accessible with proper structure.',
        detailed: 'Build accessible navigation with proper structure. Element: nav element with aria-label if multiple navs. Links: use a elements with href for navigation. Current page: aria-current="page" on active link. Dropdown menus: button triggers with aria-expanded, submenu appears on click. Keyboard: Tab navigates links, Enter activates, Escape closes submenus. Focus: visible focus indicators, logical tab order. Mobile menu: accessible hamburger button, focus trapped when open. Skip link: first element in page, bypasses navigation. Mega menu: organized with headings, keyboard navigable.',
        advanced: 'Build accessible navigation following best practices. Semantic structure: nav element with aria-label if multiple nav regions ("Main navigation", "Footer navigation"). Link usage: a elements with href (not buttons) for page navigation, buttons for actions that don\'t navigate. Current page: aria-current="page" on link to current page, visually distinct styling. Dropdown menus: button trigger with aria-expanded="true|false" and aria-haspopup="true", submenu role="menu" or list, open on click (not hover for accessibility), Escape closes. Keyboard navigation: Tab between top-level items, Enter/Space opens dropdown, Arrow keys navigate dropdown items, Escape closes dropdown and returns focus to trigger. Focus management: submenu doesn\'t auto-open, focus moves into submenu when opened, logical focus order, visible focus indicator. Mobile hamburger: button with aria-label="Menu" or "Open menu", aria-expanded state, icon has aria-hidden. Mobile panel: slide-out menu is accessible dialog or panel, focus trapped within, Escape/X closes, body scroll locked. Skip link: first focusable element on page, visible on focus, links to main content. Mega menus: structured with headings, columns have semantic grouping, keyboard navigable throughout. Breadcrumb: nav with aria-label="Breadcrumb", current page not linked. Testing: navigate entire menu with keyboard, test mobile menu with screen reader.'
      },
      {
        id: 'ac29',
        label: 'Custom Checkbox A11y',
        simple: 'Build accessible custom-styled checkboxes and radio buttons.',
        detailed: 'Create accessible custom checkbox and radio components. Hidden native input: visually hidden but not display:none, receives focus and input. Custom visual: pseudo-element or sibling styled element. Label: clicking label toggles input (htmlFor). States: checked state styled, focus ring visible, disabled styling. Keyboard: Space toggles checkbox, arrow keys navigate radio group. ARIA: aria-checked for indeterminate state if needed. Grouping: radio buttons in fieldset with legend, role="radiogroup" with aria-labelledby. Custom styling: focus-visible ring, checked indicator (check icon, filled circle).',
        advanced: 'Create accessible custom checkbox and radio components with full keyboard and screen reader support. Implementation approach: visually hidden native input + styled pseudo-element/sibling. Hidden input: position: absolute, opacity: 0, width: 1px, height: 1px (not display: none which removes from accessibility tree), still focusable and operable. Label connection: label wraps input, or label htmlFor matches input id, clicking label toggles input. Custom visual element: sibling span styled as checkbox/radio, or ::before pseudo-element, pointer-events: none (clicks go to input). States to style: unchecked (border), checked (check icon or filled), focused (focus ring on custom element via input:focus-visible + sibling), disabled (opacity, cursor), indeterminate (dash icon). Focus indicator: input:focus-visible + .custom-checkbox { ring-2 ring-blue-500 }, ensure visible on all backgrounds. Checked indicator: SVG checkmark or pseudo-element, transition for smooth appearance. Radio specifics: circular shape, filled circle when selected, group with fieldset/legend or role="radiogroup" with aria-labelledby. Indeterminate: for checkbox trees, set via JavaScript (input.indeterminate = true), style with :indeterminate pseudo-class. Touch targets: ensure 44x44px minimum clickable area. Animation: subtle scale or color transition on check/uncheck. Tailwind example: sr-only on input, peer class for sibling styling. Testing: Tab to each control, Space to toggle, verify screen reader announces checked state.'
      },
      {
        id: 'ac30',
        label: 'Accessible Tooltips',
        simple: 'Create accessible tooltips that work for all users.',
        detailed: 'Build accessible tooltips following ARIA practices. Trigger: element has aria-describedby pointing to tooltip id. Show on: hover AND focus (not hover only). Delay: slight show delay (100-200ms), longer hide delay. Tooltip content: role="tooltip", id matching aria-describedby. Positioning: above/below trigger, doesn\'t get cut off. Keyboard: visible when trigger focused, Escape dismisses. Persistence: remains visible while hovering tooltip itself. Non-essential: tooltips for supplementary info only. Touch: consider alternative for touch devices (tap to show, tap elsewhere to hide). Text: concise, don\'t put essential info only in tooltips.',
        advanced: 'Build accessible tooltips following best practices for all users. ARIA connection: trigger element has aria-describedby pointing to tooltip id when visible (add/remove dynamically). Tooltip element: role="tooltip", unique id, content provides supplementary description. Triggering: show on mouseenter AND focus (keyboard users), not just hover. Timing: slight delay before showing (150ms prevents flash), longer delay before hiding (300ms allows moving to tooltip), instant show on focus. Positioning: above/below/left/right of trigger, flip to stay in viewport, don\'t cover trigger element. Escape to dismiss: keydown listener closes tooltip and returns focus. Hover persistence: tooltip stays visible while pointer is over tooltip itself, not just trigger. Touch devices: tooltips problematic on touch (no hover state), consider: tap trigger to show, tap elsewhere to hide, or use toggle button pattern, or show info inline. Content guidelines: concise supplementary text only, never put essential information only in tooltip (user must be able to proceed without it), no interactive content (use popover instead). Focus visible: tooltip trigger should have focus indicator. Animation: subtle fade in, respect prefers-reduced-motion. Pointer: cursor-help on trigger to indicate additional info available. Implementation: Radix UI Tooltip or Floating UI for positioning. Testing: Tab to trigger and verify tooltip shows, test keyboard dismissal, verify screen reader announces tooltip content.'
      }
    ]
};
