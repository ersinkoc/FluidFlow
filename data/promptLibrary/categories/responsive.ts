import type { PromptCategory } from '../types';

export const responsiveCategory: PromptCategory = {
  id: 'responsive',
  name: 'Responsive',
  icon: 'Smartphone',
  description: 'Mobile and tablet optimization',
  prompts: [
    {
      id: 'r1',
      label: 'Mobile First',
      simple: 'Optimize design for mobile screens with vertical stacking and large touch targets.',
      detailed: 'Optimize for mobile-first design starting with base styles for small screens. Stack all elements vertically using flex-col. Increase touch targets to minimum 44x44px (min-h-11 min-w-11). Use full-width buttons (w-full) and inputs. Simplify navigation to hamburger menu. Reduce padding (p-4) and margins for efficient space use. Use larger text (text-base minimum) for readability. Remove hover-only interactions - ensure all actions work with tap. Add proper spacing between tappable elements to prevent mis-taps.',
      advanced: 'Optimize for mobile-first design starting with base styles for small screens, then progressively enhance for larger viewports. Stack all elements vertically using flex-col with logical content ordering for screen readers. Increase touch targets to minimum 44x44px (min-h-11 min-w-11) per WCAG 2.1 guidelines - 48px preferred. Use full-width buttons (w-full) and inputs with proper padding. Simplify navigation to hamburger menu with focus trap when open. Reduce padding (p-4) and margins for efficient space use while maintaining visual breathing room. Use text-base (16px) minimum to prevent iOS auto-zoom on input focus. Remove hover-only interactions - ensure all actions work with tap and have visible active states (active:bg-opacity-80). Add 8px minimum spacing between tappable elements to prevent mis-taps. Implement pull-to-refresh for list views. Test with thumb-zone analysis for important actions. Add safe-area-inset support for notched devices. Consider one-handed reachability for key actions.'
    },
    {
      id: 'r2',
      label: 'Tablet Layout',
      simple: 'Create tablet-optimized layout with two columns and collapsible sidebar.',
      detailed: 'Create optimized tablet layout for md: breakpoint (768px+). Use two-column grids (grid-cols-2) for cards and content where appropriate. Keep sidebar navigation but make it collapsible. Increase spacing (p-6, gap-6) compared to mobile. Use touch-friendly button sizes (h-12 px-6). Split forms into two columns for shorter forms. Show more content per row in data tables. Adjust hero sections to side-by-side layouts. Consider landscape and portrait orientations - test both. Keep navigation accessible with larger touch targets.',
      advanced: 'Create optimized tablet layout for md: breakpoint (768px+) supporting both iPad and Android tablets. Use two-column grids (grid-cols-2) for cards and content where appropriate - consider content relationship when splitting. Keep sidebar navigation but make it collapsible with toggle button always visible (fixed position). Increase spacing (p-6, gap-6) compared to mobile for better touch accuracy. Use touch-friendly button sizes (h-12 px-6 min-w-[120px]). Split forms into two columns for shorter forms - keep related fields grouped. Show more content per row in data tables - consider horizontal scroll for wide tables. Adjust hero sections to side-by-side layouts (flex-row). Test thoroughly in landscape and portrait orientations - content reflow should feel natural in both. Implement Split View/Slide Over support for iPadOS. Add keyboard shortcut support for external keyboard users. Consider stylus input for drawing/annotation features. Maintain 48px touch targets. Test with iPad cursor/trackpad navigation.'
    },
    {
      id: 'r3',
      label: 'Full Responsive',
      simple: 'Implement complete responsive design across all screen sizes from mobile to desktop.',
      detailed: 'Implement comprehensive responsive design across all breakpoints - sm (640px), md (768px), lg (1024px), xl (1280px). Use responsive grid: grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4. Apply fluid spacing with responsive padding (p-4 md:p-6 lg:p-8). Scale typography appropriately (text-2xl md:text-3xl lg:text-4xl). Adjust container max-widths per breakpoint. Handle images with responsive sizing and srcset attributes. Test navigation at each breakpoint. Use responsive flex direction (flex-col md:flex-row). Ensure no horizontal scroll at any size.',
      advanced: 'Implement comprehensive responsive design across all Tailwind breakpoints - sm (640px), md (768px), lg (1024px), xl (1280px), 2xl (1536px). Use responsive grid: grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4 with consistent gap scaling (gap-4 sm:gap-6 lg:gap-8). Apply fluid spacing with responsive padding (p-4 md:p-6 lg:p-8) maintaining visual rhythm. Scale typography using clamp() or responsive classes: h1 (text-2xl sm:text-3xl lg:text-4xl xl:text-5xl). Adjust container max-widths per breakpoint (max-w-sm md:max-w-2xl lg:max-w-5xl xl:max-w-7xl). Handle images with picture element, srcset, and sizes attributes for art direction and performance. Transform navigation: mobile hamburger, tablet collapsible sidebar, desktop full nav. Use responsive flex direction (flex-col md:flex-row) with logical content reordering. Ensure no horizontal scroll at any size - use overflow-x-hidden as safety. Test at every breakpoint plus 320px (minimum supported) and common device sizes. Add resize observer for dynamic layout adjustments. Consider print stylesheet. Validate with real device testing, not just browser resizing.'
    },
    {
      id: 'r4',
      label: 'Mobile Navigation',
      simple: 'Add hamburger menu with slide-out drawer for mobile navigation.',
      detailed: 'Add mobile hamburger menu with Menu icon from lucide-react. Create slide-out drawer (fixed inset-y-0 left-0 w-64) with smooth transform transition (translate-x-0/-full). Include dark overlay backdrop (fixed inset-0 bg-black/50) that closes menu on tap. Add close X button inside drawer. Stack navigation links vertically with large touch targets (py-4 px-6). Include user profile section at top if applicable. Add smooth animation (duration-300 ease-in-out). Ensure menu is accessible with proper ARIA labels and focus trap. Handle body scroll lock when open.',
      advanced: 'Add mobile hamburger menu with Menu icon from lucide-react (w-6 h-6). Create slide-out drawer (fixed inset-y-0 left-0 w-64 sm:w-80) with smooth transform transition (translate-x-0 for open, -translate-x-full for closed) using GPU-accelerated transforms. Include dark overlay backdrop (fixed inset-0 bg-black/50) that closes menu on tap with fade transition. Add close X button inside drawer at top-right. Stack navigation links vertically with large touch targets (py-4 px-6 min-h-[48px]). Include user profile section at top with avatar and name. Add smooth animation (duration-300 ease-in-out). ACCESSIBILITY: Add aria-expanded, aria-controls, aria-label on trigger button. Implement focus trap keeping focus within drawer when open. Set aria-hidden on main content when drawer open. Handle body scroll lock (overflow-hidden on body) when open. Return focus to trigger on close. Support Escape key to close. Add role="navigation" and aria-label to nav element. Announce drawer open/close to screen readers. Support swipe-to-close gesture from right edge. Consider safe-area-inset for notched devices.'
    },
    {
      id: 'r5',
      label: 'Responsive Images',
      simple: 'Optimize images to scale properly across all screen sizes with lazy loading.',
      detailed: 'Optimize images with responsive containers using aspect-ratio utilities (aspect-video, aspect-square, aspect-[4/3]). Use object-cover or object-contain for proper scaling. Implement responsive grid for image galleries - grid-cols-2 md:grid-cols-3 lg:grid-cols-4. Add skeleton loading placeholders with animate-pulse. Use lazy loading with loading="lazy" attribute. Create responsive hero images with different crops per breakpoint. Ensure images never overflow containers (max-w-full h-auto). Add proper alt text for accessibility. Consider bandwidth - smaller images on mobile if possible.',
      advanced: 'Optimize images with responsive containers using aspect-ratio utilities (aspect-video, aspect-square, aspect-[4/3]) for layout stability before load. Use object-cover or object-contain based on content - cover for backgrounds, contain for product images. Implement responsive grid for galleries: grid-cols-2 md:grid-cols-3 lg:grid-cols-4 with consistent gaps. Add skeleton loading placeholders matching exact dimensions with animate-pulse bg-gray-200. Use native lazy loading (loading="lazy") with Intersection Observer fallback for older browsers. Implement picture element with art direction - different crops per breakpoint using source media queries. Add srcset with 1x, 2x, 3x resolutions and sizes attribute for proper selection. Ensure images never overflow (max-w-full h-auto block). Add meaningful alt text - descriptive for content images, empty alt="" for decorative. Implement blur-up placeholder technique for perceived performance. Consider WebP/AVIF with fallbacks. Use CDN with automatic format negotiation. Add fetchpriority="high" for above-fold hero images. Calculate and reserve space to prevent CLS (Cumulative Layout Shift).'
    },
    {
      id: 'r6',
      label: 'Collapsible Sections',
      simple: 'Convert content sections to expandable accordions on mobile screens.',
      detailed: 'Convert content sections to collapsible accordions on mobile using responsive display (block md:hidden for accordion, hidden md:block for full). Add collapse/expand trigger button with ChevronDown icon that rotates (rotate-180) when open. Implement smooth height animation using grid-rows transition or max-height. Show section previews/summaries when collapsed. Keep important information visible in collapsed state. Add visual indicator of collapsed content (e.g., "Show more"). Use state to track open sections - allow multiple open or single-open accordion behavior. Add proper ARIA expanded states.',
      advanced: 'Convert content sections to collapsible accordions on mobile using responsive display (block md:hidden for accordion, hidden md:block for full content). Add collapse/expand trigger button with ChevronDown icon that rotates (rotate-180 transition-transform duration-200) when open. Implement smooth height animation using CSS Grid (grid-template-rows: 0fr/1fr with transition) for better performance than max-height. Show meaningful section previews/summaries when collapsed - first sentence or key stats. Keep critical information visible in collapsed state - dont hide essential content. Add clear visual indicator ("Show more", "+3 items"). Use React state to track open sections - implement both allow-multiple and single-open-only modes based on content type. ACCESSIBILITY: Add aria-expanded on trigger, aria-controls pointing to content ID. Use aria-hidden on collapsed content. Make trigger a button element (not div). Support Enter/Space to toggle. Add aria-labelledby linking content to its header. Announce expansion state changes to screen readers. Maintain focus management - dont lose focus on collapse. Add prefers-reduced-motion support for animation.'
    },
    {
      id: 'r7',
      label: 'Bottom Navigation',
      simple: 'Add fixed bottom navigation bar for mobile with icon tabs.',
      detailed: 'Add mobile bottom navigation bar fixed at screen bottom (fixed bottom-0 inset-x-0). Use safe area padding for notched devices (pb-safe or pb-6). Include 4-5 primary navigation items maximum. Each item has icon (24px) above label (text-xs). Highlight active item with different color and filled icon variant. Add subtle top border or shadow for separation. Ensure touch targets are large enough (min-h-14). Handle keyboard appearance - hide nav when keyboard opens. Add smooth transitions for active state. Include badge indicators for notifications if needed. Use z-50 for proper stacking.',
      advanced: 'Add mobile bottom navigation bar fixed at screen bottom (fixed bottom-0 inset-x-0 bg-white dark:bg-gray-900). Use safe area padding for notched devices (pb-[env(safe-area-inset-bottom)] or pb-safe with fallback). Include 4-5 primary navigation items maximum - more causes cramped touch targets. Each item: icon (w-6 h-6) above label (text-xs font-medium), centered in flex-col. Highlight active item with primary color and filled icon variant vs outline for inactive. Add subtle top border (border-t border-gray-200) or shadow-[0_-1px_3px_rgba(0,0,0,0.1)] for separation. Touch targets minimum 48x48px (min-h-[56px] flex-1). Handle virtual keyboard: use visualViewport API or CSS env(keyboard-inset-height) to hide/adjust nav when keyboard opens. Add smooth color transitions (transition-colors duration-150). Include badge indicators (absolute -top-1 -right-1) for notifications with pulse animation for new items. Use z-50 for proper stacking above content. ACCESSIBILITY: Use nav element with aria-label="Main navigation". Each item is a link or button with clear accessible name. Indicate current page with aria-current="page". Dont hide important actions in bottom nav without alternative access.'
    },
    {
      id: 'r8',
      label: 'Swipe Gestures',
      simple: 'Add touch swipe interactions for carousels and dismissible cards.',
      detailed: 'Implement touch swipe interactions for carousels and cards. Use touch-action CSS to control gesture behavior. Track touchstart, touchmove, touchend events for swipe detection. Calculate swipe direction and velocity for natural feel. Add visual feedback during swipe - show next/previous items peeking. Implement momentum scrolling with proper deceleration. Include dot indicators or progress bar for carousel position. Add haptic feedback on iOS if available. Prevent vertical scroll while horizontal swiping. Support both left/right swipe for navigation and swipe-to-dismiss patterns. Add snap points for carousel items (scroll-snap-type, scroll-snap-align).',
      advanced: 'Implement touch swipe interactions for carousels and cards with native-feeling physics. Use touch-action: pan-y for horizontal carousels (allow vertical scroll, capture horizontal). Track touchstart (record start position), touchmove (calculate delta, apply transform), touchend (determine action based on velocity and distance). Calculate swipe velocity (distance/time) for momentum - above threshold triggers navigation, below snaps back. Add visual feedback: transform: translateX() following finger, show next/previous items peeking (10-20px visible). Implement momentum scrolling with deceleration curve (ease-out, ~300ms duration). Include dot indicators (current highlighted) or progress bar showing position. Add haptic feedback via navigator.vibrate() or iOS taptic engine. Use passive: false on touchmove only when preventing scroll. Support both navigation swipe (threshold ~30% of width or velocity > 0.5) and swipe-to-dismiss (with confirm or undo option). Implement CSS scroll-snap for simpler carousels: scroll-snap-type: x mandatory, scroll-snap-align: start on items. Add keyboard navigation (arrow keys) as alternative to swipe. Consider prefers-reduced-motion - disable momentum animations.'
    },
    {
      id: 'r9',
      label: 'Responsive Typography',
      simple: 'Scale text sizes smoothly across different screen sizes.',
      detailed: 'Implement fluid typography that scales smoothly across viewports. Use clamp() for fluid sizing - e.g., text-[clamp(1rem,2.5vw,1.5rem)]. Scale headings proportionally: h1 (text-3xl md:text-4xl lg:text-5xl), h2 (text-2xl md:text-3xl), h3 (text-xl md:text-2xl). Adjust line-height for different sizes (leading-tight for large headings, leading-relaxed for body). Reduce letter-spacing on mobile for tighter text. Ensure minimum text size of 16px to prevent iOS zoom on input focus. Use responsive max-width for optimal line length (max-w-prose or max-w-[65ch]). Test readability at all sizes.',
      advanced: 'Implement fluid typography that scales smoothly across viewports using CSS clamp() for true fluidity. Formula: clamp(min, preferred, max) - e.g., text-[clamp(1rem,0.5rem+2vw,1.5rem)] for body, text-[clamp(2rem,1rem+4vw,4rem)] for h1. Scale headings proportionally maintaining hierarchy: h1 (text-3xl md:text-4xl lg:text-5xl), h2 (text-2xl md:text-3xl lg:text-4xl), h3 (text-xl md:text-2xl). Adjust line-height inversely to size: leading-tight (1.25) for large headings, leading-normal (1.5) for subheadings, leading-relaxed (1.625) for body text. Reduce letter-spacing on mobile (tracking-tight) where space is premium, increase on desktop for large headings (tracking-wide). CRITICAL: Minimum 16px text size for form inputs to prevent iOS auto-zoom on focus. Use responsive max-width for optimal line length: 45-75 characters (max-w-prose â‰ˆ 65ch). Test with browser zoom up to 200% - text should remain readable and not overflow containers. Implement proper heading hierarchy for accessibility. Consider dyslexia-friendly options: increased letter/word spacing, specific fonts. Add text-wrap: balance for headings in supporting browsers.'
    },
    {
      id: 'r10',
      label: 'Hide on Mobile',
      simple: 'Hide non-essential elements on mobile to reduce clutter.',
      detailed: 'Strategically hide non-essential elements on mobile using hidden sm:block or hidden md:flex. Hide secondary navigation items - keep in hamburger menu. Remove decorative images or illustrations that dont add value. Collapse detailed descriptions to "Read more" expandable sections. Hide table columns showing secondary data - keep essential columns only. Remove sidebar widgets on mobile - move to bottom or hide. Hide breadcrumbs on mobile (space-consuming). Simplify footer - show only essential links. Keep all functionality accessible through alternative paths. Use lg:hidden to hide mobile-only elements on desktop.',
      advanced: 'Strategically hide non-essential elements on mobile using hidden sm:block or hidden md:flex - but NEVER hide functionality without alternative access. Hide secondary navigation items - move to hamburger menu, not remove entirely. Remove decorative images/illustrations that consume bandwidth without adding value - consider replacing with smaller icons. Collapse detailed descriptions to "Read more" expandable sections using disclosure pattern. Hide table columns showing secondary data: use data-priority attribute to mark importance, keep essential columns (name, status, primary action), offer "View details" for full data. Remove sidebar widgets on mobile - move to end of main content or dedicated page, not just hidden. Hide breadcrumbs on mobile (space-consuming) but ensure other navigation paths exist. Simplify footer: accordion sections by category, essential links only, move secondary links to dedicated pages. Use lg:hidden to hide mobile-specific elements (like bottom nav) on desktop. ACCESSIBILITY: Hidden content must be truly hidden (display:none or hidden attribute) not just visually hidden, unless its meant for screen readers only. Ensure no functionality is lost - all hidden features must have alternative access path. Test keyboard navigation after hiding elements.'
    },
    {
      id: 'r11',
      label: 'Responsive Tables',
      simple: 'Transform data tables for mobile with horizontal scroll or card layouts.',
      detailed: 'Optimize tables for mobile viewing. Option 1: Horizontal scroll with overflow-x-auto wrapper, sticky first column. Option 2: Transform to card layout on mobile - each row becomes a card with label-value pairs stacked vertically. Add data-label attributes for mobile card labels. Use min-w-full to prevent table shrinking. Hide less important columns on mobile with hidden md:table-cell. Add visual scroll indicators for horizontal scroll tables.',
      advanced: 'Optimize tables for mobile with multiple strategies based on data type. Horizontal scroll: overflow-x-auto wrapper, min-w-[600px] on table, sticky first column (sticky left-0 bg-white z-10), shadow on scroll indicator. Card transformation: use CSS grid or flexbox at mobile breakpoint, display:block on all table elements, add ::before pseudo-element with attr(data-label) for field names. Priority columns: mark with data-priority, hide lower priority with hidden md:table-cell. Responsive actions: move row actions to dropdown menu on mobile. Pagination: show fewer rows per page on mobile. Sorting: ensure sort controls are touch-friendly. Search/filter: full-width on mobile, collapsible filter panel. Empty state: responsive empty message. Loading: skeleton matching current layout. Export: offer data export as alternative to viewing large tables. Accessibility: maintain proper table semantics even when restyled, ensure data relationships are clear.'
    },
    {
      id: 'r12',
      label: 'Touch-Friendly Forms',
      simple: 'Optimize form inputs for touch with larger targets and proper spacing.',
      detailed: 'Optimize forms for touch devices. Increase input height to min-h-12 (48px). Add generous padding px-4 py-3. Space form fields with gap-6 for fat-finger prevention. Use full-width inputs on mobile (w-full). Increase checkbox and radio sizes to w-6 h-6. Add clear touch feedback with active states. Use appropriate input types for virtual keyboard (email, tel, number). Disable autocorrect on username fields. Add input mode attributes for numeric keyboards.',
      advanced: 'Optimize forms for touch with comprehensive mobile patterns. Input sizing: min-h-[48px] per WCAG touch targets, py-3 px-4 internal padding. Field spacing: gap-6 between fields prevents accidental taps. Full-width: w-full on mobile for easier targeting. Checkboxes/radios: w-6 h-6 minimum, larger tap area with padding. Touch feedback: active:bg-gray-100, focus:ring-2 visible focus states. Input types: type="email" for email keyboard, type="tel" for phone pad, inputmode="numeric" for numbers without spinners. Autocomplete: appropriate autocomplete attributes for autofill. Autocorrect: disable on usernames, codes (autocorrect="off" autocapitalize="off"). Labels: always visible (not placeholder-only), tap label to focus input. Error messages: clear, inline, sufficient contrast. Submit buttons: min-h-12, full-width, sticky bottom on long forms. Keyboard avoidance: scroll input into view when focused. Password: show/hide toggle, paste allowed. Multi-step: progress indicator, save progress. Date inputs: native date pickers or touch-optimized date selectors.'
    },
    {
      id: 'r13',
      label: 'Responsive Modal',
      simple: 'Create modals that work well on mobile as bottom sheets or full screen.',
      detailed: 'Adapt modals for mobile devices. Use bottom sheet pattern on mobile (fixed bottom-0 inset-x-0) sliding up from bottom. On desktop, use centered modal. Add rounded-t-2xl for bottom sheet style. Include drag handle indicator at top for swipe-to-dismiss. Make modal full-screen on very small devices if content is lengthy. Add safe area padding for notched devices. Ensure close button is easily reachable.',
      advanced: 'Adapt modals for mobile with bottom sheet pattern. Mobile: fixed bottom-0 inset-x-0 left-0 right-0, transform translate-y for slide animation, rounded-t-2xl for rounded top corners, max-h-[90vh] with overflow-y-auto. Drag handle: w-10 h-1 bg-gray-300 rounded-full mx-auto mt-3 for swipe-to-dismiss affordance. Implement swipe-to-dismiss with touch handlers and velocity detection. Full-screen: on small devices (<375px) or lengthy content, use full screen with close button in header. Desktop: centered modal with max-w-lg, rounded-xl, centered vertically. Backdrop: fixed inset-0 bg-black/50, tap to close. Safe area: pb-[env(safe-area-inset-bottom)] for notched devices. Close button: always visible in top-right or header. Focus trap: keep focus within modal when open. Keyboard: Escape to close, Tab cycles through focusable elements. Body scroll lock: prevent background scrolling. Reduce motion: respect prefers-reduced-motion, use fade instead of slide. Animation: slide-up for bottom sheet, fade+scale for centered modal.'
    },
    {
      id: 'r14',
      label: 'Responsive Cards Grid',
      simple: 'Create card layouts that adapt from single column to multi-column grids.',
      detailed: 'Build responsive card grids that adapt to viewport. Use CSS Grid with responsive columns: grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4. Maintain consistent gap spacing (gap-4 md:gap-6). Cards should have equal heights in rows (grid auto-rows or flex with stretch). On mobile, cards can span full width with horizontal scroll for featured items. Add responsive padding inside cards (p-4 md:p-6).',
      advanced: 'Build responsive card grids with optimal layout per viewport. Grid setup: grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4 with gap-4 md:gap-6 lg:gap-8 scaling. Equal heights: grid auto-rows-fr for equal height rows, or use flex with align-items-stretch. Card internals: flex flex-col for content, flex-grow on main content area, mt-auto on footer/actions. Featured cards: col-span-2 for wide cards, row-span-2 for tall cards, responsive (col-span-2 lg:col-span-1). Mobile optimization: consider horizontal scroll carousel for featured section (overflow-x-auto snap-x). Card padding: p-4 md:p-6 responsive, maintain consistent internal spacing. Images: aspect ratio containers (aspect-video, aspect-square) for consistent sizing. Hover states: transform hover:scale-[1.02] hover:shadow-lg transition on desktop. Loading: grid of skeleton cards matching layout. Empty state: centered message spanning all columns. Accessibility: cards as list items, clear heading hierarchy within cards.'
    },
    {
      id: 'r15',
      label: 'Breakpoint Debug',
      simple: 'Add visual breakpoint indicator for responsive development debugging.',
      detailed: 'Add development-only breakpoint indicator showing current viewport size. Fixed position badge in corner (fixed bottom-4 right-4). Display current breakpoint: default/sm/md/lg/xl/2xl. Show viewport dimensions in pixels. Color-code by breakpoint for quick identification. Only show in development mode. Remove or hide in production builds.',
      advanced: 'Add development-only breakpoint indicator for responsive debugging. Position: fixed bottom-4 right-4 z-[9999]. Display: show active breakpoint name and pixel dimensions. Implementation: use Tailwind responsive classes with content in pseudo-elements or conditional rendering. Show: block sm:hidden for xs indicator, hidden sm:block md:hidden for sm, etc. Dimensions: use window.innerWidth/Height, update on resize. Color coding: each breakpoint has distinct background color for instant recognition. Production: use process.env.NODE_ENV check to exclude from production, or use Tailwind debug-screens plugin. Additional info: optional toggle to show more details (container width, device pixel ratio). Accessibility: mark as decorative (aria-hidden="true"), no interaction. Performance: debounce resize handler, use resize observer for efficiency. Bonus: highlight elements with responsive classes on hover, show applied breakpoint-specific styles.'
    },
    {
      id: 'r16',
      label: 'Responsive Video',
      simple: 'Embed responsive videos that maintain aspect ratio across screen sizes.',
      detailed: 'Create responsive video embeds maintaining aspect ratio. Use aspect-video (16:9) or aspect-[4/3] container. Video fills container with w-full h-full object-cover. For iframes (YouTube, Vimeo): wrap in aspect ratio container, iframe w-full h-full. Remove fixed width/height attributes from iframe. Add rounded corners (rounded-lg) and overflow-hidden on container. Consider smaller video size on mobile for bandwidth.',
      advanced: 'Create responsive video embeds with proper aspect ratio handling. Container: relative w-full aspect-video (16:9) or aspect-[4/3], overflow-hidden rounded-lg. Native video: w-full h-full object-cover for fill, object-contain for letterbox. Iframe embeds: wrap in aspect ratio container, iframe absolute inset-0 w-full h-full, remove inline width/height. Poster image: show before play for faster perceived load. Loading: lazy load with IntersectionObserver, show skeleton or poster while loading. Autoplay: only with muted, consider prefers-reduced-motion. Controls: custom controls overlay for native video, position absolute over video. Mobile: consider lower resolution source for bandwidth, offer quality selector. Full-screen: support fullscreen API, handle safe areas. Captions: include track element with captions, style with ::cue. PiP: support Picture-in-Picture where available. Performance: preload="none" or "metadata" for below-fold videos. Accessibility: captions required, keyboard controls, focus visible.'
    },
    {
      id: 'r17',
      label: 'Responsive Spacing',
      simple: 'Apply consistent spacing that scales appropriately across breakpoints.',
      detailed: 'Implement responsive spacing system. Use consistent spacing scale that increases with viewport. Container padding: px-4 md:px-6 lg:px-8. Section padding: py-12 md:py-16 lg:py-24. Gap between elements: gap-4 md:gap-6 lg:gap-8. Margin between sections: my-8 md:my-12 lg:my-16. Maintain visual rhythm across all screen sizes. Reduce spacing on mobile to maximize content area.',
      advanced: 'Implement responsive spacing system with visual rhythm. Define spacing scale: use Tailwind default scale, apply responsively. Container: px-4 sm:px-6 lg:px-8 xl:px-12 2xl:px-16. Sections: py-12 md:py-16 lg:py-24 for major sections, py-8 md:py-12 for subsections. Gaps: gap-4 md:gap-6 lg:gap-8 for grids and flex containers. Margins: space-y-4 md:space-y-6 lg:space-y-8 for stacked elements. Headings: mb-4 md:mb-6 after major headings, mb-2 md:mb-3 after subheadings. Cards: p-4 md:p-6 lg:p-8 internal padding. Visual rhythm: maintain consistent vertical spacing multiples (e.g., 4, 8, 12, 16). Mobile: tighter spacing (4px base) to maximize content. Desktop: more generous spacing (8px base) for breathing room. Consistency: define spacing tokens and apply consistently. CSS custom properties: define --section-padding etc. for easy adjustment. Maintain spacing in both orientations on tablets. Test edge cases: very small (320px) and very large (2560px+) screens.'
    },
    {
      id: 'r18',
      label: 'Orientation Handling',
      simple: 'Handle landscape and portrait orientations appropriately.',
      detailed: 'Handle device orientation changes gracefully. Use orientation media queries (landscape:, portrait:). Adjust layout for landscape mobile: reduce vertical space, consider horizontal layouts. Lock orientation for specific views if needed (video player, games). Handle virtual keyboard appearance in landscape. Reflow content appropriately on rotation. Test both orientations on tablets.',
      advanced: 'Handle device orientation with appropriate layouts. Media queries: use landscape: and portrait: variants in Tailwind. Landscape mobile: reduce header height, consider horizontal split layouts, hide non-essential UI elements, maximize content area. Portrait tablet: similar to desktop layout, more columns. Landscape tablet: wide layouts, sidebar visible. Keyboard landscape: critical issue - very limited viewport height, scroll to keep input visible, consider minimizing UI. Orientation lock: use Screen Orientation API for specific views (games, video). Detect changes: use matchMedia listener or resize event. Smooth transitions: handle layout changes gracefully, avoid jarring reflows. Safe areas: update safe area handling on rotation (notches move). Video: auto-fullscreen suggestion in landscape. Forms: reflow multi-column forms to single column in portrait mobile. Images: art direction - different crops for portrait vs landscape. Test matrix: phone portrait, phone landscape, tablet portrait, tablet landscape.'
    },
    {
      id: 'r19',
      label: 'Responsive Sidebar',
      simple: 'Create sidebar that adapts from overlay on mobile to fixed on desktop.',
      detailed: 'Build responsive sidebar navigation. Mobile: hidden by default, slide-in overlay on hamburger click, fixed inset-y-0 left-0, dark backdrop behind. Tablet: collapsible to icons-only (w-16) with expand on hover. Desktop: always visible, fixed width (w-64). Use breakpoints: lg:block for persistent sidebar, hidden lg:flex for hamburger. Handle main content offset on desktop.',
      advanced: 'Build responsive sidebar with three states. Mobile (<768px): hidden by default, hamburger trigger in header, slide-in overlay (fixed inset-y-0 left-0 w-64 z-50), dark backdrop (fixed inset-0 bg-black/50 z-40), body scroll lock, swipe to close. Tablet (768-1024px): collapsible, icons-only by default (w-16), expand on hover or toggle to full width (w-64), persistent (always visible), tooltip labels when collapsed. Desktop (>1024px): always visible at full width (w-64), fixed or sticky, main content offset (ml-64). Implementation: use state for mobile open/close, localStorage for collapse preference. Transitions: translate-x for mobile slide, width transition for collapse. Main content: ml-0 md:ml-16 lg:ml-64 responsive offset. Overlay: use createPortal for proper stacking. Focus: trap focus when mobile overlay open. Resize: close mobile overlay if resizing to larger viewport. Navigation items: icons required for collapsed state, text for expanded. Active indicator: visible in both states. Sub-menus: expand within sidebar or popover in collapsed mode.'
    },
    {
      id: 'r20',
      label: 'PWA Responsive',
      simple: 'Optimize for Progressive Web App installation and standalone mode.',
      detailed: 'Optimize for PWA installation and standalone mode. Add meta viewport with viewport-fit=cover for notched devices. Use CSS env() for safe area insets. Handle standalone display mode (display-mode: standalone). Design for app-like experience without browser chrome. Add splash screens for various device sizes. Ensure offline mode works responsively. Test installed app behavior.',
      advanced: 'Optimize for PWA installation across devices. Viewport: <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">. Safe areas: use env(safe-area-inset-*) for padding on notched devices, especially fixed elements. Standalone mode: detect with display-mode: standalone media query or navigator.standalone, adjust UI (hide back button, add custom navigation). manifest.json: include all icon sizes (192, 512, maskable), set display: standalone. Splash screens: Apple requires specific sizes, Android generates from manifest. Offline: responsive layouts should work with cached content, skeleton states for loading. Install prompt: responsive install banner, deferrable. Status bar: meta theme-color, adjust for dark mode. Navigation: handle back button/gesture in standalone, provide navigation within app. Update handling: prompt for update, refresh mechanism. Desktop PWA: handle window resizing, min/max dimensions. Testing: test as installed app on multiple devices, verify safe areas, check orientation handling.'
    },
    {
      id: 'r21',
      label: 'Responsive Hero Section',
      simple: 'Create hero sections that adapt content layout across screen sizes.',
      detailed: 'Build responsive hero sections. Mobile: stack content vertically, image above or below text. Tablet: side-by-side layout begins. Desktop: larger typography, more whitespace, prominent imagery. Adjust button sizes and layout per breakpoint. Handle background images responsively with object-position. Scale heading sizes significantly (text-3xl to text-6xl).',
      advanced: 'Build responsive hero sections with strong visual impact at all sizes. Mobile: stack vertically (flex-col), image full-width, text-center, text-3xl heading, single column CTA buttons, py-12 for spacing. Tablet: side-by-side begins (md:flex-row), text-left, image right, text-4xl heading, inline buttons. Desktop: larger canvas (lg:py-24), text-5xl xl:text-6xl heading, more whitespace, imagery prominence, animated elements. Background images: use picture element for art direction, object-position adjustments per breakpoint, overlay gradient for text contrast. CTAs: button sizing (text-sm py-2 to text-lg py-4), layout (flex-col to flex-row), primary + secondary. Content width: max-w-xl for text content, prevent overly long lines. Animation: entrance animations on desktop, respect reduced motion. Video backgrounds: consider bandwidth, provide static fallback on mobile. Alignment: center on mobile, left or creative alignment on desktop. Scroll indicator: visible on desktop, hidden on mobile.'
    },
    {
      id: 'r22',
      label: 'Responsive Footer',
      simple: 'Create footer that adapts from stacked to multi-column layout.',
      detailed: 'Build responsive footer layout. Mobile: stack all sections vertically, accordion for link groups, centered content. Tablet: 2-column grid for link sections. Desktop: 4+ column layout with sitemap-style navigation. Logo and social links adapt position. Newsletter signup spans appropriate width. Legal links in single row on desktop, stacked on mobile.',
      advanced: 'Build responsive footer with complete adaptation. Mobile: single column stack, accordion link sections (save space, tap to expand), centered logo, stacked social icons, full-width newsletter input, vertical legal links with separators. Tablet: 2-column grid (grid-cols-2) for link sections, side-by-side logo and social, inline newsletter form. Desktop: 4-5 column layout (grid-cols-4 or grid-cols-5), sitemap-style link groups with headings, horizontal newsletter, inline legal links with dot separators. Logo: prominent on all sizes, link to home. Social icons: horizontal row, appropriately sized touch targets. Newsletter: label + input + button, responsive layout (stacked to inline). Back to top: fixed button on long pages, smooth scroll. Legal: copyright, privacy, terms links, responsive separator. Accessibility: footer as landmark, proper heading hierarchy, link groups as nav elements. Dark mode: appropriate color adjustments. Animation: fade-in on scroll into view.'
    },
    {
      id: 'r23',
      label: 'Container Queries',
      simple: 'Use container queries for component-level responsive design.',
      detailed: 'Implement container queries for component-based responsiveness. Define container with @container CSS rule. Query container size rather than viewport. Useful for components that appear in different contexts (sidebar vs main content). Components adapt to their container, not the page width. Use Tailwind container query plugin (@container variant).',
      advanced: 'Implement container queries for truly modular responsive components. Define container: container-type: inline-size on parent element, give it container name with container-name. Query syntax: @container (min-width: 400px) { ... } for size-based styles. Use cases: cards that work in sidebar and main content, reusable components in different layouts, widgets that adapt to available space. Tailwind: use @tailwindcss/container-queries plugin, apply @container class to parent, use @[size]: variants on children. Benefits: components are self-contained, work regardless of viewport, true component-level responsive design. Fallback: for unsupported browsers, use viewport-based breakpoints as fallback. Naming: use container-name for multiple containers, avoid conflicts. Style isolation: each component responds to its own container. Performance: similar to media queries, browser optimizes. Testing: resize containers independently, verify component adaptation. Real examples: card that switches layout based on card width, navigation that collapses based on available space.'
    },
    {
      id: 'r24',
      label: 'Responsive Sticky Elements',
      simple: 'Handle sticky positioning that works across all screen sizes.',
      detailed: 'Implement responsive sticky elements. Header: sticky top-0, adjust height per breakpoint. Sidebar: sticky top-16 (below header offset). Mobile: consider when sticky makes sense, may need fixed for nav. Handle z-index properly for overlapping sticky elements. Account for safe areas on mobile. Adjust sticky offset for different header heights.',
      advanced: 'Implement responsive sticky positioning across devices. Header: sticky top-0 z-40, responsive height (h-14 md:h-16 lg:h-20), handle transform on scroll (hide on scroll down, show on scroll up). Sidebar: sticky with offset for header (top-16 md:top-20), max-height for scrollable content (h-[calc(100vh-4rem)]). Table headers: sticky with proper background for readability. CTAs: sticky bottom for mobile (fixed bottom-0), inline on desktop. Offset calculation: use CSS calc() or CSS custom properties for header height reference. Z-index layers: header (z-40), sidebar (z-30), sticky elements (z-20), modals (z-50). Mobile: fixed often better than sticky for nav, consider bottom nav. Safe areas: add env(safe-area-inset-top) to top sticky elements on notched devices. Scroll containers: sticky works within scrollable parents, set correct positioning context. Performance: avoid too many sticky elements, can cause repaint issues. Intersection Observer: alternative for dynamic behavior based on scroll position.'
    },
    {
      id: 'r25',
      label: 'Foldable Device Support',
      simple: 'Support foldable devices with appropriate layouts for fold states.',
      detailed: 'Support foldable devices (Samsung Fold, Surface Duo). Detect fold using viewport segments API. Avoid placing critical content on the fold line. Create dual-pane layouts for unfolded state. Single pane for folded. Use CSS spanning media features. Test with foldable device emulators. Handle dynamic viewport changes on fold/unfold.',
      advanced: 'Support foldable devices with appropriate layouts. Detection: use viewport segments API (visualViewport.segments), horizontal-viewport-segments and vertical-viewport-segments media features. Fold awareness: avoid placing interactive elements, text, or images across the fold line. Dual-pane layout: when unfolded, create side-by-side layout (list + detail, navigation + content), use CSS multi-column spanning or Grid with spanning. Single pane: normal layout when folded. Dynamic changes: handle fold/unfold events, smooth transitions between layouts, preserve state. CSS spanning: @media (horizontal-viewport-segments: 2) for side-by-side fold, @media (vertical-viewport-segments: 2) for top-bottom. Environment variables: env(viewport-segment-width), env(viewport-segment-left) for positioning. Posture: detect device posture (folded, flat, laptop) with device-posture media feature. Testing: Chrome DevTools foldable device emulation, actual device testing. Fallback: works as normal responsive layout when folding not detected. Patterns: master-detail (list left, detail right), extended canvas (content spans both screens), companion mode (controls on one screen, content on other).'
    },
    {
      id: 'r26',
      label: 'Print Stylesheet',
      simple: 'Create print-friendly version of the page with responsive print styles.',
      detailed: 'Create print-friendly styles. Use print: variant in Tailwind or @media print. Hide navigation, footers, ads, interactive elements. Remove backgrounds and shadows to save ink. Ensure text contrast is sufficient for print. Expand all accordions and tabs. Convert links to show URLs after text. Break pages appropriately. Size for standard paper dimensions.',
      advanced: 'Create comprehensive print stylesheet. Hide: navigation (print:hidden), footers, ads, interactive elements, decorative images, buttons, form controls. Colors: force high contrast text, remove background images and colors (background: white !important). Typography: increase to print-friendly size (12-14pt), serif fonts often more readable in print. Links: add URL after link text using ::after with attr(href). Expand: show all accordion content, all tab panels, remove overflow:hidden. Page breaks: break-before-page, break-after-page, avoid breaking inside cards (break-inside: avoid). Paper size: set width for standard paper, @page { size: letter; margin: 1in; }. Headers/footers: @page { @top-center { content: "Page title" } }. Table handling: keep headers repeating (thead { display: table-header-group }). Images: ensure important images print, set max-width to avoid overflow. Remove: shadows, rounded corners (optional), gradients. Testing: use browser print preview, test on actual printer. Invoke: add print button that triggers window.print().'
    },
    {
      id: 'r27',
      label: 'Responsive Icons',
      simple: 'Scale icons appropriately across different screen sizes.',
      detailed: 'Scale icons responsively. Use relative sizing where possible (em-based). Standard sizes: w-4 h-4 (16px) for inline, w-5 h-5 (20px) for UI, w-6 h-6 (24px) for touch targets. Increase touch target size on mobile even if icon stays same. Hide icon labels on mobile, show on desktop. Use responsive classes: w-5 h-5 md:w-6 md:h-6.',
      advanced: 'Scale icons with contextual responsiveness. Size scale: w-4 h-4 (inline/small), w-5 h-5 (standard UI), w-6 h-6 (primary actions), w-8 h-8 (feature icons), w-12 h-12+ (hero/feature). Touch targets: even if icon is 20px, touch target should be 48px minimum (add padding). Responsive sizing: w-5 h-5 md:w-6 md:h-6 for icons that grow. Icon + label: flex items-center gap-2, hide text on mobile (span hidden md:inline), keep icon visible. Icon-only buttons: larger on mobile (w-10 h-10 md:w-8 md:h-8). Tooltips: show on hover for icon-only on desktop, consider long-press on mobile. SVG optimization: use currentColor for fill/stroke, inherit text color. Icon libraries: ensure tree-shaking, only import used icons. Consistent stroke width: maintain visual weight across sizes. Loading states: icon buttons show spinner at same size. Accessibility: always include aria-label for icon-only buttons. Emoji: use as icons sparingly, may render differently across platforms.'
    },
    {
      id: 'r28',
      label: 'Responsive Padding Safe Areas',
      simple: 'Handle safe area insets for notched and curved screen devices.',
      detailed: 'Handle safe area insets for modern devices. Use env() CSS function: env(safe-area-inset-top), env(safe-area-inset-bottom), env(safe-area-inset-left), env(safe-area-inset-right). Apply to fixed elements (headers, bottom nav, FAB). Set viewport-fit=cover in viewport meta tag. Use Tailwind plugin for safe area utilities or custom properties.',
      advanced: 'Handle safe area insets for notched, curved, and cutout displays. Viewport meta: <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover"> to allow content behind notch. CSS env() values: safe-area-inset-top (notch), safe-area-inset-bottom (home indicator), safe-area-inset-left/right (landscape rotation). Application: fixed/sticky headers (pt-[env(safe-area-inset-top)]), bottom navigation (pb-[env(safe-area-inset-bottom)]), FAB (mb-[calc(env(safe-area-inset-bottom)+1rem)]), landscape mode (px-[max(1rem,env(safe-area-inset-left))]). Fallback: use max() or fallback values - padding-left: max(1rem, env(safe-area-inset-left)). Tailwind plugin: @tailwindcss/safe-area or custom safelist. Full-bleed: for edge-to-edge content, let content go to edge with proper insets on interactive elements. Modals: ensure close buttons and actions are within safe areas. Landscape: different insets when device rotates. Testing: iOS simulator, notch device emulators, real device testing. Keyboard: safe-area-inset-keyboard for keyboard-aware layouts.'
    },
    {
      id: 'r29',
      label: 'High DPI Responsive',
      simple: 'Handle high-DPI displays with appropriate image and asset scaling.',
      detailed: 'Handle high-DPI (Retina) displays. Provide 2x and 3x image assets using srcset. Use SVG icons for perfect scaling. Consider @2x and @3x background images with media queries. Ensure border widths remain crisp. Test on high-DPI displays for clarity. Use device-pixel-ratio media queries for specific targeting.',
      advanced: 'Handle high-DPI displays for crisp visuals. Images: provide srcset with 1x, 2x, 3x variants, let browser choose - <img srcset="image.jpg 1x, image@2x.jpg 2x, image@3x.jpg 3x">. Responsive images: combine srcset with sizes attribute for responsive + retina. SVG preference: use SVG for icons, logos, illustrations - scale perfectly at any DPI. Background images: use image-set() for CSS backgrounds - background-image: image-set(url(img.jpg) 1x, url(img@2x.jpg) 2x). Media query: @media (-webkit-min-device-pixel-ratio: 2), (min-resolution: 192dpi) for DPI-specific styles. Borders: 1px borders may look too thin on high-DPI, consider adjusting. Shadows: subtle shadows may need adjustment for visibility. Canvas: scale canvas by devicePixelRatio for crisp rendering. Font rendering: high-DPI improves font clarity, can use lighter weights. Performance: balance retina quality with file size, use modern formats (WebP, AVIF). Testing: use Retina/high-DPI displays or simulate in DevTools. Icons: SVG always, or high-res icon fonts.'
    },
    {
      id: 'r30',
      label: 'Responsive Loading',
      simple: 'Adapt loading states and skeletons to match responsive layouts.',
      detailed: 'Create responsive loading states. Skeleton screens should match the layout at current breakpoint. Show fewer skeleton items on mobile. Match skeleton dimensions to actual content. Use responsive skeleton widths and heights. Maintain layout stability during load. Consider simpler loading indicators on mobile to reduce complexity.',
      advanced: 'Create responsive loading states that match content layouts. Skeleton structure: mirror actual responsive layout - grid-cols-1 md:grid-cols-2 lg:grid-cols-3 for card skeletons. Item count: fewer items on mobile (3 items) vs desktop (8+ items). Skeleton dimensions: responsive widths (w-32 md:w-48) matching actual content dimensions. Height matching: match actual content heights to prevent layout shift (CLS). Animation: shimmer animation that works across skeleton grid. Simplification: simpler skeletons on mobile (just basic shapes) vs detailed on desktop. Placeholder images: gray boxes with aspect ratio matching actual images. Text lines: varied widths for natural appearance. Tables: skeleton rows matching visible columns at breakpoint. Progressive: show partial content as it loads, not all-or-nothing. Suspense: React Suspense boundaries with responsive fallbacks. Error states: responsive error displays matching layout. Empty states: responsive empty state illustrations and messaging. Performance: lightweight skeletons, avoid complex animations on mobile.'
    }
  ]
};
