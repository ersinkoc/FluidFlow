import type { PromptCategory } from '../types';

export const featuresCategory: PromptCategory = {
    id: 'features',
    name: 'Features',
    icon: 'Wrench',
    description: 'Functionality additions',
    prompts: [
      {
        id: 'f1',
        label: 'Theme Toggle',
        simple: 'Add dark/light mode toggle button with Sun/Moon icons. Store preference in localStorage.',
        detailed: 'Implement dark/light theme toggle with system preference detection. Create theme context with useState and useEffect. Check prefers-color-scheme media query for initial value. Store preference in localStorage with key "theme". Toggle button: Sun/Moon icons that switch. Apply theme: add/remove "dark" class on document.documentElement. Tailwind dark mode: ensure darkMode: "class" in config, use dark: prefix for dark styles. Smooth transition: add transition-colors duration-200 to body.',
        advanced: 'Implement dark/light theme toggle with system preference detection. Create ThemeContext with useState and useEffect hooks. Check prefers-color-scheme media query for initial value, fallback to localStorage. Store preference with key "theme" (light/dark/system). Toggle button: Sun/Moon icons with smooth rotation transition. Apply theme: add/remove "dark" class on document.documentElement. Tailwind config: darkMode: "class", use dark: prefix extensively. Smooth transition-colors duration-200 on body for seamless switching. System preference option: "auto" that follows OS setting and responds to changes. Update meta theme-color for browser chrome styling. Sync across browser tabs with storage event listener. Provide ThemeProvider component wrapping entire app. Include useTheme hook for accessing theme state anywhere. Handle SSR flash with script in head. Add keyboard shortcut (Cmd/Ctrl+Shift+D). Consider color scheme for system UI elements (scrollbars, form controls). Test both themes thoroughly for contrast compliance.'
      },
      {
        id: 'f2',
        label: 'Filter & Sort',
        simple: 'Add filter checkboxes and sort dropdown to filter and order list items.',
        detailed: 'Add comprehensive filter and sort controls for lists/grids. Filter UI: sidebar with checkboxes for categories, range sliders for prices/dates, search input for text filter. Active filters: show pills/tags above results with remove button each. Clear all filters option. Sort controls: dropdown with options (Newest, Oldest, Price: Low to High, Name A-Z, Popular). Sort direction toggle (ascending/descending arrow). Show result count ("Showing 24 of 156 items"). Loading state during filter application.',
        advanced: 'Add comprehensive filter and sort controls for lists/grids. Filter UI: sidebar with checkboxes for categories, range sliders for prices/dates, search input for text filter, color swatches for color filters. Active filters: show pills/tags above results with remove button each, persist to URL query params for shareable filtered views. Clear all filters option. Sort controls: dropdown with options (Newest, Oldest, Price: Low to High, Name A-Z, Popular, Best Match). Sort direction toggle (ascending/descending arrow icon). Apply filters client-side for small datasets (<500 items) or trigger debounced API call for large datasets. Show result count ("Showing 24 of 156 items"). Loading state: skeleton or spinner during filter application. Reset filters to default. Mobile: collapsible filter panel (Sheet component) or full-screen modal with Apply button. URL sync: update query params on filter change for bookmarking and sharing. Handle empty results with helpful "No items match" message and filter adjustment suggestions. Implement faceted filtering showing available options based on current results. Add "Save filter preset" for power users.'
      },
      {
        id: 'f3',
        label: 'Pagination',
        simple: 'Add page numbers with Previous/Next buttons to navigate through results.',
        detailed: 'Build complete pagination component. Display: current page, total pages, page number buttons. Show subset of pages: first, last, current ¬± 2, ellipsis for gaps (1 ... 4 5 6 ... 20). Previous/Next buttons with ChevronLeft/ChevronRight icons, disabled on first/last. Items per page selector: dropdown with options (10, 25, 50, 100). Results info: "Showing 1-10 of 156 results". URL sync: update ?page= query parameter.',
        advanced: 'Build complete pagination component with full accessibility support. Display: current page, total pages, page number buttons with proper ARIA labels. Show subset of pages: first, last, current ¬± 2, ellipsis for gaps (1 ... 4 5 6 ... 20). Previous/Next buttons with ChevronLeft/ChevronRight icons, disabled (aria-disabled) on first/last page. Items per page selector: dropdown with options (10, 25, 50, 100), remember preference in localStorage. Results info: "Showing 1-10 of 156 results". Keyboard support: arrow keys when focused, Enter to select page. URL sync: update ?page= and ?perPage= query parameters for bookmarkable URLs. Handle edge cases: single page (hide pagination entirely), empty results (show appropriate message), invalid page number (redirect to page 1). Loading state: show spinner while fetching new page, disable controls. Scroll to top on page change (smooth scroll). Mobile: simplified view with prev/next buttons and "Page X of Y" text. Accessible: nav role="navigation" with aria-label="Pagination", current page marked with aria-current="page". Support both controlled and uncontrolled modes. Add jump-to-page input for datasets with many pages.'
      },
      {
        id: 'f4',
        label: 'Like/Favorite',
        simple: 'Add heart icon button that toggles between outline and filled state when clicked.',
        detailed: 'Implement like/favorite functionality with engaging interactions. Heart icon: Heart from lucide-react, filled when active. Toggle states: outline heart (not liked), filled red heart (liked). Animation: scale bounce on like (scale-125 then back). Counter: show like count next to icon, update optimistically. Store liked state: localStorage for anonymous users, API call for authenticated. Error handling: revert on failed save, show toast.',
        advanced: 'Implement like/favorite functionality with engaging interactions. Heart icon: Heart from lucide-react, filled when active. Toggle states: outline heart (stroke-current), filled red heart (fill-red-500) when liked. Animation: scale bounce on like (scale-125 then scale-100) with duration-200, optional CSS particle burst effect using ::before/::after pseudo-elements. Counter: show like count next to icon, update optimistically for instant feedback. Double-tap to like on mobile (for images/cards using touch events with timing check). Store liked state: localStorage with Set of liked IDs for anonymous users, API POST/DELETE for authenticated users. Undo: can unlike immediately without confirmation. Batch likes: support liking multiple items quickly with debounced API calls. Loading state: subtle pulse animation while saving. Error handling: revert UI on failed save, show error toast with retry option. List of favorites page showing all saved items in grid/list view. Add to favorites from multiple contexts (card hover, detail page action bar, quick action menu). Sync across devices for logged-in users. Include unlike confirmation for accidental taps (optional setting). Announce like/unlike action to screen readers with aria-live region.'
      },
      {
        id: 'f5',
        label: 'Share Buttons',
        simple: 'Add share button that opens options for Twitter, Facebook, and copy link.',
        detailed: 'Add social sharing functionality. Share button: Share2 icon triggers share options. Native Web Share API: if navigator.share supported, use for mobile-friendly sheet. Fallback: custom dropdown with platform options. Platforms: Twitter/X, Facebook, LinkedIn, WhatsApp, Email, Copy Link. Share URLs: construct proper share URLs with encodeURIComponent. Success feedback: "Link copied!" toast.',
        advanced: 'Add social sharing functionality with comprehensive platform support. Share button: Share2 icon triggers share options. Native Web Share API: if navigator.share && navigator.canShare supported, use for mobile-friendly native sheet with title, text, url parameters. Fallback: custom dropdown/modal with platform options. Platforms: Twitter/X (icon, opens intent URL with text and url), Facebook (sharer.php URL), LinkedIn (shareArticle URL with title, summary, source), WhatsApp (wa.me/send?text= with message and URL), Telegram (t.me/share/url), Pinterest (for images), Reddit, Email (mailto: with subject and body), Copy Link (navigator.clipboard.writeText). Share URLs: construct proper share URLs with encodeURIComponent, handle special characters. Include: page title, description meta, canonical URL, optional og:image. Track shares for analytics (fire event on share click). Show share count if available from API. Customize share message per platform respecting character limits. Ensure Open Graph and Twitter Card meta tags are present for rich previews when shared. Success feedback: "Link copied!" or "Opening Twitter..." toast notification. Handle share failures gracefully. Add QR code generation option for easy mobile sharing. Consider branded short URLs for tracking.'
      },
      {
        id: 'f6',
        label: 'Copy to Clipboard',
        simple: 'Add copy button that copies text to clipboard and shows "Copied!" feedback.',
        detailed: 'Implement robust copy-to-clipboard functionality. Use navigator.clipboard.writeText() API. Trigger: button with Copy icon, onClick handler. Visual feedback: icon changes to Check for 2 seconds, then back to Copy. Apply to: code blocks, share links, reference IDs. Handle errors: show "Failed to copy" message. Copy button positioning: absolute top-right corner of copyable content.',
        advanced: 'Implement robust copy-to-clipboard functionality with full browser support. Use navigator.clipboard.writeText() API (modern, async, requires secure context). Fallback for older browsers: create temporary hidden textarea, append to body, select content, document.execCommand("copy"), remove element. Trigger: button with Copy icon (lucide-react), onClick async handler with try/catch. Visual feedback: icon transitions from Copy to Check with fade animation for 2 seconds, then back to Copy. Alternative feedback: tooltip "Copied!" appears briefly using absolute positioned element. Button text variant: "Copy" ‚Üí "Copied!" with text-green-600 color. Apply to: code blocks (multi-line preserving formatting), share links, reference IDs, API keys, configuration snippets. Handle errors: show "Failed to copy" error toast with reason. Keyboard shortcut: Ctrl/Cmd+C when element is focused (if appropriate). Copy button positioning: absolute top-right corner (top-2 right-2) of copyable content container with relative parent. Support copying rich text/HTML when needed using navigator.clipboard.write() with ClipboardItem. Accessibility: aria-label="Copy to clipboard" describes action, announce "Copied to clipboard" success to screen readers using aria-live="polite" region. Prevent double-click issues with disabled state during feedback period. Add haptic feedback on mobile if available.'
      },
      {
        id: 'f7',
        label: 'Infinite Scroll',
        simple: 'Load more items automatically when user scrolls near the bottom of the list.',
        detailed: 'Replace pagination with infinite scroll for seamless browsing. Use Intersection Observer API to detect scroll near bottom. Observer target: sentinel element at end of list. Trigger: when sentinel is 200px from viewport, load more. Loading state: spinner at bottom while fetching. Append new items to existing array. Handle end of data: show "No more items" message. Error handling: show retry button if fetch fails.',
        advanced: 'Replace pagination with infinite scroll for seamless browsing experience. Use Intersection Observer API to detect scroll near bottom with rootMargin: "200px" for early trigger. Observer target: sentinel div element at end of list, observed when component mounts. Trigger: when sentinel intersects viewport, call loadMore function if not already loading and hasMore data. Loading state: spinner or skeleton items at bottom while fetching next page. Append new items to existing array using spread operator, never replace. Track current page/cursor for API pagination. Handle end of data: unobserve sentinel, show "You have seen it all" or "No more items" message with friendly illustration. Error handling: show "Failed to load" message with Retry button, keep observer active. Scroll restoration: maintain scroll position on navigation back using ScrollRestoration or manual sessionStorage tracking. Performance: virtualize list for very long lists (>100 items) using react-window or react-virtualized, only render visible items plus buffer. URL sync: update ?page= as user scrolls for deep linking and SEO. Back button: return to approximate scroll position by jumping to stored page. Mobile: add pull-to-refresh at top using touch events or library. Show floating "Back to top" button after scrolling down 500px. Implement loading="lazy" on images. Add aria-busy during loading.'
      },
      {
        id: 'f8',
        label: 'Drag & Drop',
        simple: 'Allow users to drag items to reorder them in a list.',
        detailed: 'Implement drag and drop for reordering items. Use HTML5 Drag and Drop API. Draggable items: draggable="true" attribute. Visual indicators: grab cursor on hover, grabbing while dragging. Drop zones: highlight valid drop targets. Handle events: onDragStart, onDragOver, onDrop to reorder array. Animation: smooth transition as items shift. Save new order to localStorage or API.',
        advanced: 'Implement drag and drop for reordering items with full accessibility. Use HTML5 Drag and Drop API with fallback to touch events for mobile. Draggable items: draggable="true" attribute, tabIndex for keyboard access. Visual indicators: cursor-grab on hover, cursor-grabbing while dragging. Drag preview: semi-transparent clone follows cursor (default browser behavior or custom using setDragImage). Store dragged item reference in dataTransfer or React state. Drop zones: highlight valid drop targets with dashed border (border-dashed border-2 border-blue-400) or bg change on dragEnter. Drop indicator: horizontal line (h-0.5 bg-blue-500) showing where item will be placed, position based on mouse Y. Handle events: onDragStart (store item index, set effectAllowed), onDragEnter/onDragOver (preventDefault to allow drop, update indicator position), onDragLeave (remove highlight), onDrop (calculate new index, reorder array). State update: immutably move item from source index to target index using array methods. Animation: transition-transform duration-200 as items shift to make room. Mobile support: long-press (300ms) to initiate drag, touch move to drag, handle touch events parallel to drag events. Save new order: debounced API call or localStorage on drop, show saving indicator. Accessibility: keyboard reordering with Space to grab, arrow keys to move, Space/Enter to drop, Escape to cancel. Screen reader announcements using aria-live: "Item grabbed", "Moved to position 3", "Item dropped". Consider dnd-kit or react-beautiful-dnd library for complex cases.'
      },
      {
        id: 'f9',
        label: 'Export Data',
        simple: 'Add export button to download data as CSV or JSON file.',
        detailed: 'Add data export functionality in multiple formats. Export button: Download icon with dropdown for format selection. Formats: CSV, JSON, Excel (XLSX), PDF. CSV export: convert array to CSV string, handle commas and quotes, create Blob and download. JSON export: JSON.stringify with indentation. Apply current filters/sort to export. Filename: include date. Progress indicator for large exports.',
        advanced: 'Add data export functionality in multiple formats with progress tracking. Export button: Download icon with dropdown for format selection (or modal for options). Formats: CSV (comma-separated values with proper escaping), JSON (pretty-printed with 2-space indent), Excel (XLSX with formatting), PDF (formatted table with headers). CSV export: convert array to CSV string, wrap values containing commas/quotes/newlines in quotes, escape internal quotes by doubling, add UTF-8 BOM for Excel compatibility, create Blob("text/csv;charset=utf-8") and trigger download via temporary anchor with download attribute. JSON export: JSON.stringify(data, null, 2) with proper typing. Excel: use SheetJS (xlsx) library to create workbook with styled headers, column widths, number formatting. PDF: use jspdf with jspdf-autotable plugin for formatted tables with pagination. Include column headers/names from configuration. Apply current filters/sort/search to export (export what user sees). Options modal: checkboxes to select columns to include, date range picker, format-specific settings (delimiter for CSV, compression for JSON). Progress indicator: for large exports (>1000 rows), show progress bar with percentage and cancel button. Filename: descriptive name with date and filter summary (e.g., "orders_2024-01-15_completed.csv"). Server-side export option for very large datasets (>10k rows) with email delivery. Implement streaming for large client-side exports to prevent memory issues. Track export events for analytics.'
      },
      {
        id: 'f10',
        label: 'Print View',
        simple: 'Add print button that opens browser print dialog with optimized styles.',
        detailed: 'Create print-optimized view and styles. Add @media print CSS rules. Hide non-essential elements: navigation, sidebar, footer, buttons (display: none in print). Optimize layout: single column, full width. Typography: black text on white background. Tables: add borders for clarity. Print button: window.print() on click. Page breaks: use break-inside: avoid for tables.',
        advanced: 'Create print-optimized view and comprehensive print styles. Add @media print CSS rules in global styles or Tailwind plugin. Hide non-essential elements: navigation, sidebar, footer, interactive buttons, ads, chat widgets using print:hidden utility or display: none in @media print. Show print-only elements: content hidden on screen using screen:hidden print:block, like full URLs or additional context. Optimize layout: single column (print:w-full), no fixed/sticky positioning, remove max-width constraints. Typography: ensure black text on white background (print:text-black print:bg-white), reasonable font sizes (12-14pt body), serif fonts optional for readability. Images: set max-width: 100%, use print:hidden for decorative images, ensure important images have high resolution. Tables: add borders for clarity (print:border), handle page breaks (break-inside: avoid on tbody tr). Links: optionally show URL after link text using print:after:content-[" (" attr(href) ")"] or [href]::after. Page breaks: use break-before-page, break-after-page, break-inside-avoid for content grouping. Headers/footers: use @page rules for margins, page numbers (@page { @bottom-center { content: counter(page); } }). Print button: window.print() onClick, hide button itself in print. Print preview: consider showing preview modal first with react-to-print library. Save as PDF: browser native from print dialog. Include page title and date in header. Remove shadows and unnecessary borders. Test in multiple browsers and actual printers.'
      },
      {
        id: 'f11',
        label: 'Language Selector',
        simple: 'Add dropdown to select language with flag icons and store preference.',
        detailed: 'Add language/locale selector for internationalization. UI: dropdown with current language flag/name, list of available languages. Display: flag icons (emoji or images) with language name. Store selection: localStorage key "locale". Apply: update UI text, date/number formats. React context: provide locale value and setter. Consider browser language detection for initial value.',
        advanced: 'Add language/locale selector for complete internationalization support. UI: dropdown with current language flag emoji and name, list of available languages in scrollable menu. Display: flag icons (emoji flags üá∫üá∏ üá´üá∑ or SVG sprites for consistency) with language name in native script (English, Fran√ßais, Êó•Êú¨Ë™û). Structure: Globe icon trigger button, dropdown with search input for apps with many languages (>10). Store selection: localStorage key "locale" or "language", also set document.documentElement.lang attribute. Apply on selection: update all UI text via i18n system, update date/number formats (Intl.DateTimeFormat, Intl.NumberFormat), handle text direction change for RTL languages (Arabic, Hebrew) with dir="rtl" on html element. React context: create LocaleContext providing locale value, setLocale function, t() translation function, formatDate/formatNumber helpers. Integration: implement with react-i18next, next-intl, or custom solution using JSON translation files. Browser language detection: navigator.language or navigator.languages[0] for initial value, match to supported locales with fallback. URL-based routing: optionally include locale in URL path (/en/about, /fr/about) for SEO using Next.js i18n routing or manual routing. Format helpers: useFormatter hook wrapping Intl APIs for dates, numbers, currencies, relative time. Regional variants: distinguish en-US vs en-GB for date formats (MM/DD vs DD/MM). Mark current language in dropdown with checkmark icon. Handle missing translations gracefully with fallback to default language. Support pluralization and interpolation in translation strings.'
      },
      {
        id: 'f12',
        label: 'Bookmark/Save',
        simple: 'Add bookmark icon button to save items to a favorites list stored locally.',
        detailed: 'Implement save/bookmark functionality for items. Save button: Bookmark icon (outline when unsaved, filled when saved). Toggle action: click to save/unsave. Animation: subtle scale animation on save. Storage: localStorage for anonymous users, API for authenticated. Saved items page: dedicated route showing all bookmarks. Empty state: friendly message. Sort saved items by date saved.',
        advanced: 'Implement save/bookmark functionality for items with organization features. Save button: Bookmark icon from lucide-react (outline stroke when unsaved, filled fill-current when saved). Toggle action: click to save/unsave with immediate visual feedback. Animation: subtle scale-110 pulse animation on save, smooth fill transition. Storage: localStorage with array of saved item IDs for anonymous users (with upgrade prompt at limit), API endpoint POST/DELETE for authenticated users. Saved items page: dedicated /saved route showing all bookmarks in grid/list view toggle. Card display: item preview with saved date, "Remove" button (X icon). Empty state: friendly illustration with "Nothing saved yet" message and browse suggestion CTA. Organize saved items: create folders/collections feature (e.g., "Work", "Read Later", "Inspiration") with drag-drop between collections. Sort saved items: by date saved (newest/oldest), alphabetically by title, custom manual order. Filter by collection or item type. Sync across devices: for logged-in users via API, merge on login. Export saved items: download list as JSON with item details or CSV with IDs and titles. Share collection: generate shareable public link with privacy controls. Limit: max 100 saved items for anonymous users with "Create account to save more" prompt. Handle deleted items gracefully (show "Item no longer available" placeholder). Quick unsave from saved page with undo toast. Add to saved from multiple contexts: card hover button, detail page action bar, long-press on mobile.'
      },
      {
        id: 'f13',
        label: 'Comments Section',
        simple: 'Add comment form with textarea and display comments with username and timestamp.',
        detailed: 'Build full-featured comments section. Comment form: textarea with placeholder, submit button, character counter. Display comments: avatar, username, timestamp (relative: "2 hours ago"), comment text. Threading: reply button opens nested reply form. Actions: reply, edit, delete own comments. Likes on comments with count. Sorting: newest, oldest, most liked. Empty state: "Be the first to comment".',
        advanced: 'Build full-featured comments section with threading and moderation. Comment form: textarea with placeholder "Add a comment...", submit button (primary), character counter showing remaining (e.g., "245/500"). Show logged-in user avatar next to input, or "Sign in to comment" prompt for guests. Display comments: avatar (w-10 h-10 rounded-full), username (font-medium), verified badge if applicable, timestamp (relative: "2h ago", "Yesterday", hover for exact date), comment text (whitespace-pre-wrap for line breaks). Threading: Reply button opens nested reply form inline below comment, indent child comments with pl-8 or pl-12 and connecting vertical line, support 2-3 levels deep then "View more replies" collapse link. Actions row: Reply, Edit (own comments - inline editing mode), Delete (own comments - with confirmation), Report (dropdown with reasons), Share (copy link to comment). Likes on comments: thumbs up icon with count, toggle on click. Load more: "Load X more comments" button or infinite scroll for long threads. Sorting dropdown: Newest first, Oldest first, Most liked, Most discussed. Mention users: @username with autocomplete dropdown showing matching users. Rich text: support basic markdown (bold, italic, links) with preview, or WYSIWYG toolbar. Moderation: flag button reports to moderators, auto-hide comments with many reports. Real-time updates: new comments appear at top with highlight animation using polling (30s) or WebSocket subscription. Empty state: "Be the first to comment" with friendly illustration. Guest commenting: option to comment with name/email without account, show "Guest" badge.'
      },
      {
        id: 'f14',
        label: 'Rating System',
        simple: 'Add 5-star rating display with clickable stars to set user rating.',
        detailed: 'Create interactive star rating component. Display: 5 stars in a row using Star icon from lucide-react. States: empty (outline), filled (solid yellow/gold), half-filled for averages. Interactive rating: hover to preview, click to set. Animation: subtle scale on hover, bounce on select. Show average: "4.5 out of 5" with star icon. Rating distribution: bar chart. Accessibility: keyboard navigation.',
        advanced: 'Create interactive star rating component with comprehensive features. Display: 5 stars in horizontal row using Star icon from lucide-react. States: empty (stroke-gray-300 fill-none), filled (stroke-yellow-400 fill-yellow-400), half-filled for averages using CSS clip-path or gradient. Interactive rating: hover to preview (fill stars up to hovered position with lighter shade), click to set rating. Hover effect: individual star scale-110 on hover. Animation: subtle scale transform on hover, bounce animation (scale-125 to scale-100) on select with duration-300. Read-only mode: for displaying averages, no hover effects, cursor-default, use different component variant. Show average: "4.5 out of 5" text with single filled star icon, or "4.5 ‚òÖ‚òÖ‚òÖ‚òÖ‚òÜ" visual display. Rating distribution: horizontal bar chart showing count per star level (5‚òÖ ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà 156, 4‚òÖ ‚ñà‚ñà‚ñà‚ñà 89, etc.). Total ratings count: "(based on 234 reviews)" clickable to scroll to reviews. Clear rating: X button or click same star to remove, confirm dialog optional. Prevent accidental changes: require slight hold (200ms) or double-click to submit. Accessibility: role="radiogroup" with role="radio" for each star, keyboard navigation with arrow keys, aria-label="Rate 4 out of 5 stars", announce selection changes. Mobile: larger touch targets (min-w-10 min-h-10 per star). Submit rating: POST API call with optimistic update, show "Thanks for rating!" toast. Allow rating change: PUT request to update existing rating, show "Rating updated" feedback. Consider emoji ratings (üòûüòêüòäüòÉü§©) as alternative style. Aggregate stats: show percentage who would recommend.'
      },
      {
        id: 'f15',
        label: 'Live Preview',
        simple: 'Show side-by-side editor and preview that updates as user types.',
        detailed: 'Implement real-time preview that updates as user edits. Split view: editor on left, preview on right. Sync updates: debounced onChange (200-300ms) updates preview. Preview types: rendered markdown, code output, form preview. Syntax highlighting in editor. Error handling: show errors inline in preview. Toggle: option to hide preview. Mobile: tabs to switch between edit and preview.',
        advanced: 'Implement real-time preview that updates as user edits with professional editing experience. Split view: editor on left (flex-1), resizable divider (4px draggable), preview on right (flex-1), or top/bottom split on mobile. Sync updates: debounced onChange (200-300ms delay using useDebounce) updates preview to prevent excessive rendering. Preview types: rendered markdown (using marked or remark), code output (sandboxed iframe for JS), form preview (live form with entered values), design preview (rendered components). Syntax highlighting in editor using Monaco Editor (from @monaco-editor/react) or CodeMirror 6 with appropriate language mode, line numbers, bracket matching, auto-indent. Error handling: show errors inline in preview area with red styling and line numbers, don\'t break preview entirely, keep last valid output visible with error overlay. Scroll sync: scroll preview to match editor cursor position using scroll event handlers and element mapping. Toggle: button to hide preview for more editor space, keyboard shortcut (Cmd/Ctrl+Shift+P). Full-screen preview: expand preview to full viewport temporarily with Escape to exit. Hot reload: for code previews, automatically re-execute without manual refresh, preserve console output. Diff view: optionally show changes highlighted using diff algorithm comparison with previous version. Save draft: autosave to localStorage every 30 seconds during editing with "Draft saved" indicator. Mobile: tabs interface to switch between Edit and Preview views with swipe gestures. Share preview: generate preview-only shareable link (read-only mode). Add word/character count in status bar. Support multiple files with tab interface for complex projects.'
      },
      {
        id: 'f16',
        label: 'Comparison View',
        simple: 'Show items side by side in columns to compare their features.',
        detailed: 'Build side-by-side comparison interface. Layout: two or more columns with items to compare. Header: item titles/images at top with remove button. Comparison rows: feature name on left, values for each item in columns. Highlight differences: background color where values differ. Add to compare: button on cards with compare count badge. Limit: 2-4 items maximum.',
        advanced: 'Build side-by-side comparison interface for informed decision making. Layout: scrollable container with 2-4 columns for compared items plus fixed first column for feature labels. Header row: sticky top-0, item image/thumbnail, title, price, quick action buttons (Remove from compare, View details). Comparison rows: feature name in fixed first column (w-48 bg-gray-50), values for each item in flexible columns with equal widths. Highlight differences: light yellow or blue background (bg-yellow-50) on cells where values differ from others. Identical values: subtle gray text, option to "Hide identical rows" toggle that collapses matching rows. Add to compare: button on product/item cards throughout site, show badge with current compare count (0-4), disable add when at limit with tooltip "Remove an item to add more". Compare drawer: fixed bottom bar (h-16) showing items being compared as small thumbnails with X remove, prominent "Compare Now" button, appears when 2+ items added. Limit: maximum 4 items to compare (mobile: 2), show "Maximum items reached" message. Clear comparison: "Clear all" button to remove all items, confirm dialog. Mobile: horizontally swipeable columns with scroll snap, or stacked accordion view with toggle between layouts. Feature categories: group comparison rows by category (Specifications, Features, Pricing) with collapsible headers. Print comparison: formatted print view with all items on one page, optimized table layout. Share comparison: URL with compared item IDs (?compare=id1,id2,id3) for bookmarking and sharing. Persist comparison: save to localStorage, restore on return visit. Winner highlighting: optional "Best value" or "Best rated" badge on winning item per row. Export comparison as PDF or image.'
      },
      {
        id: 'f17',
        label: 'File Upload',
        simple: 'Add drag and drop file upload with preview and progress.',
        detailed: 'Build file upload component with drag and drop. Drop zone: dashed border area with icon and text prompt. Visual feedback: border color change on drag over. File preview: thumbnails for images, icons for other types. Progress: upload progress bar per file. Multiple files: support selecting multiple files. File info: show name, size, type. Remove: X button to remove before upload. Validation: file type and size limits. Error states: show validation errors per file.',
        advanced: 'Build comprehensive file upload component with drag and drop support. Drop zone: dashed border (border-2 border-dashed border-gray-300), centered icon (Upload or CloudUpload), instructional text ("Drag files here or click to browse"). Visual states: default, hover (border-gray-400), dragover active (border-blue-500 bg-blue-50), error (border-red-500). Input: hidden file input triggered by click on zone, accept attribute for allowed types. Multiple files: multiple attribute, handle FileList. File preview list: below drop zone, each file shows: thumbnail (for images, use URL.createObjectURL), icon (for other types based on extension), filename (truncated with tooltip), file size (formatted KB/MB), remove button (X icon), status indicator. Upload progress: individual progress bar per file (bg-blue-600, transition-all), percentage text, or global progress for batch. States per file: pending, uploading, complete (green check), error (red X with message). Validation: check file type against accept list, max file size (e.g., 10MB), max total size, max file count. Error display: inline error message with specific reason ("File too large", "Invalid type"). Drag and drop events: onDragEnter, onDragOver (preventDefault), onDragLeave, onDrop. Prevent full page drop: add listeners to window to prevent browser default. Upload handling: FormData for multipart, or base64 encoding, chunked upload for large files. Cancel upload: abort controller for in-progress uploads. Accessibility: keyboard accessible, aria-label on drop zone, announce upload status.'
      },
      {
        id: 'f18',
        label: 'Real-time Sync',
        simple: 'Add real-time data synchronization across browser tabs.',
        detailed: 'Implement real-time sync across browser tabs and windows. Use BroadcastChannel API for same-origin communication. Sync state: changes in one tab reflect immediately in others. Conflict resolution: last-write-wins or merge strategy. Visual indicator: show sync status icon. Offline support: queue changes when offline, sync when back online. Storage: sync to localStorage as backup. Events: listen for storage events as fallback. Debounce: batch rapid changes.',
        advanced: 'Implement real-time synchronization across browser tabs, windows, and potentially devices. Same-origin tab sync: BroadcastChannel API (const channel = new BroadcastChannel("app-sync"); channel.postMessage(data); channel.onmessage), fallback to localStorage storage event for older browsers. State management integration: wrap in context provider, dispatch sync messages on state changes, receive and apply remote changes. Conflict resolution strategies: last-write-wins (timestamp comparison), merge (combine non-conflicting changes), user prompt (show conflict UI for manual resolution). Sync indicator: icon showing sync status (cloud with check, syncing spinner, offline indicator), tooltip with last sync time. Message format: {type, payload, timestamp, tabId, version}. Selective sync: only sync specific state slices, not entire app state. Debouncing: batch rapid changes (100-200ms debounce) to prevent flood. Offline support: detect navigator.onLine, queue changes when offline, process queue on online event. Cross-device sync: WebSocket connection to server, or Firebase Realtime Database/Firestore, handle reconnection with exponential backoff. Optimistic updates: apply locally immediately, roll back on server rejection. Version vectors: track versions per field for accurate conflict detection. Storage persistence: localStorage as local cache, IndexedDB for larger data. Tab leader election: one tab handles server sync, others communicate through it. Reconnection: handle tab sleep/wake, network changes gracefully.'
      },
      {
        id: 'f19',
        label: 'Undo/Redo Stack',
        simple: 'Implement undo and redo functionality for user actions.',
        detailed: 'Build undo/redo system for user actions. Data structure: stack of previous states or command pattern. Keyboard shortcuts: Ctrl/Cmd+Z for undo, Ctrl/Cmd+Shift+Z for redo. Buttons: undo/redo buttons with disabled state when stack empty. History limit: cap at N items to manage memory. Action types: track what changed for display. Grouping: batch rapid changes into single undo step. Visual feedback: show what was undone in toast.',
        advanced: 'Build comprehensive undo/redo system with history management. Architecture options: 1) State snapshots (store complete state at each step, simple but memory heavy), 2) Command pattern (store actions with inverse operations, more complex but efficient). State snapshot implementation: maintain past[], present, future[] arrays, on action push present to past and set new present clear future, undo pops past to present and pushes old present to future. Command pattern: each action has execute() and undo() methods, store action objects in stack, undo calls action.undo(). Keyboard shortcuts: useEffect with keydown listener, check Ctrl/Cmd+Z (undo), Ctrl/Cmd+Shift+Z or Ctrl+Y (redo), prevent default. UI buttons: Undo (RotateCcw icon) and Redo (RotateCw icon), disabled state (opacity-50 cursor-not-allowed) when respective stack empty, show stack count in tooltip. History limit: cap at 50-100 items, drop oldest when exceeded. Action grouping: batch rapid changes (typing) into single undo step using debounce or explicit grouping API. Action metadata: store action type/description for UI display ("Undo: Delete item", "Redo: Format text"). History panel: optional UI showing action history with ability to jump to specific point. Selective history: different undo stacks for different contexts (text editing vs object manipulation). Persistence: optionally save history to sessionStorage for page refresh survival. Memory optimization: for state snapshots, use structural sharing (immer) or store diffs only. Clear history: option to reset undo stack (e.g., on save). Disable for certain actions: some actions should not be undoable (save, publish).'
      },
      {
        id: 'f20',
        label: 'Keyboard Shortcuts',
        simple: 'Add keyboard shortcuts for common actions.',
        detailed: 'Implement keyboard shortcut system. Common shortcuts: Ctrl+S save, Ctrl+K search, Escape close. Registration: central shortcut registry. Display: show shortcuts in tooltips and menus. Help modal: show all available shortcuts. Scope: different shortcuts for different contexts. Conflict prevention: warn on duplicate shortcuts. OS detection: show Cmd for Mac, Ctrl for Windows. Customizable: optionally let users remap shortcuts.',
        advanced: 'Implement comprehensive keyboard shortcut system with discoverability. Shortcut registry: central Map or object storing shortcut definitions {keys, action, description, scope, enabled}. Key parsing: support modifiers (ctrl, alt, shift, meta/cmd), multiple keys (ctrl+shift+k), sequences (g then h for GitHub-style). Event handling: useEffect with keydown listener on document, check modifiers and key, prevent default on match, call action. OS-aware display: detect navigator.platform or userAgent, show "Cmd" for Mac, "Ctrl" for Windows/Linux in UI. Display in UI: show shortcuts in tooltips (title="Save (Ctrl+S)"), menu items (flex justify-between with shortcut right-aligned), and command palette. Help modal: "?" key or menu item opens modal listing all shortcuts, grouped by category (Navigation, Editing, etc.), searchable. Scope management: global shortcuts always active, contextual shortcuts active only in certain UI (e.g., editor shortcuts only when editor focused). Focus-based scoping: use context to track current focus area, filter shortcuts by scope. Conflict detection: warn in dev mode when duplicate shortcuts registered. Sequence shortcuts: track key sequence with timeout reset (g pressed, within 500ms i pressed = go to inbox). Reserved shortcuts: do not override browser shortcuts (Ctrl+T, Ctrl+W) or screen reader shortcuts. Customization: store user-customized shortcuts in localStorage, settings UI for remapping with conflict check. Visual hint mode: hold modifier key to show available shortcut hints overlaid on UI (like Mac Cheatsheet). Disable shortcuts: respect input focus (do not trigger shortcuts when typing in input/textarea unless explicitly handling). Integration: expose useKeyboardShortcut hook for easy registration in components.'
      },
      {
        id: 'f21',
        label: 'Multi-language',
        simple: 'Add internationalization (i18n) support for multiple languages.',
        detailed: 'Implement internationalization for multiple languages. Library: use i18next with react-i18next. Translation files: JSON files per language. Language switcher: dropdown in header/settings. Persistence: save preference to localStorage. Detection: detect browser language as default. Interpolation: support variables in translations. Pluralization: handle plural forms per language. RTL support: detect and apply RTL styles for Arabic/Hebrew. Date/number formatting: locale-aware formatting.',
        advanced: 'Implement comprehensive internationalization (i18n) system. Library setup: i18next with react-i18next, initialize with defaultNS, fallbackLng, interpolation settings. Translation files structure: locales/en/common.json, locales/en/errors.json, namespace organization. Loading: lazy load language files on demand, show loading state during switch. useTranslation hook: const { t } = useTranslation(); t("welcome.title"). Interpolation: t("greeting", { name: "John" }) for "Hello {{name}}". Pluralization: t("items", { count: 5 }) with _one, _other, _zero keys, ICU format for complex plural rules. Language switcher: dropdown or button group in header, flag icons optional but use language names primarily. Detection: browser language (navigator.language), accept-language header, or stored preference. Persistence: save to localStorage, sync across tabs. RTL support: detect RTL languages (ar, he, fa), add dir="rtl" to html element, use logical CSS properties (margin-inline-start vs margin-left), or Tailwind RTL plugin. Date formatting: Intl.DateTimeFormat with locale, or date-fns locale imports. Number formatting: Intl.NumberFormat for currencies and numbers. Translation management: consider Crowdin, Lokalise, or similar for translator workflow. Missing translations: show key in dev mode, log warnings, fallback to default language in prod. Context: provide language context with current lang, change function, available languages. Dynamic content: handle user-generated content (may not be translated). Namespaces: separate translations by feature (auth, dashboard, settings) for code splitting. Type safety: generate TypeScript types from translation keys.'
      },
      {
        id: 'f22',
        label: 'Print Styles',
        simple: 'Optimize pages for printing with clean layout.',
        detailed: 'Add print-optimized styles. Media query: @media print for print-specific CSS. Hide elements: navigation, footers, ads, interactive elements. Show elements: reveal full content hidden behind truncation. Typography: black text on white, appropriate sizes. Page breaks: avoid breaking inside important content. Links: show URLs after link text. Tables: repeat headers on each page. Headers/footers: page numbers, document title. Margins: appropriate print margins.',
        advanced: 'Add comprehensive print-optimized styles for professional output. Media query: @media print { } or Tailwind print: variant for print-specific styles. Hide elements: hide navigation, sidebar, modals, tooltips, interactive buttons, video embeds, chat widgets, cookie banners (print:hidden or display: none). Show elements: expand truncated text (print:line-clamp-none), show content behind "show more", display hidden metadata. Typography: force black text (print:text-black), white background (print:bg-white), remove shadows and gradients, increase body text to 12pt minimum, reduce heading sizes proportionally. Links: show URLs after anchor text using ::after pseudo-element (content: " (" attr(href) ")"), or remove underlines and show inline. Images: ensure images print (some browsers hide background images), add border for clarity. Page breaks: page-break-inside: avoid on cards, tables, important sections; page-break-before: always on major sections; widows/orphans control for text. Tables: thead { display: table-header-group } to repeat headers on each page, avoid page breaks inside rows. Headers/footers: @page { @top-center { content: "Document Title" }; @bottom-right { content: counter(page) } } for page numbers and running headers (limited browser support). Margins: @page { margin: 2cm } for appropriate print margins. Color: respect prefers-color-scheme: light or force light theme for print. Remove: animations, transitions, fixed/sticky positioning. Test: browser print preview, actual print to PDF.'
      },
      {
        id: 'f23',
        label: 'PDF Export',
        simple: 'Generate PDF exports of content or data.',
        detailed: 'Implement PDF export functionality. Library: use jsPDF or react-pdf. Content: capture DOM element or generate from data. Styling: maintain visual fidelity. Tables: proper table formatting in PDF. Images: embed images correctly. Multi-page: handle content spanning multiple pages. Headers/footers: page numbers, document title. Download: trigger browser download. Filename: descriptive filename with date. Progress: show generation progress for large documents.',
        advanced: 'Implement comprehensive PDF export functionality. Library options: jsPDF (client-side, full control), html2pdf.js (HTML to PDF), @react-pdf/renderer (React components to PDF), Puppeteer server-side (best fidelity). Client-side with jsPDF: const doc = new jsPDF(); add text, tables, images programmatically, doc.save("filename.pdf"). HTML capture: html2canvas to capture DOM element as image, then add to jsPDF, or use html2pdf wrapper. React-PDF: define PDF document with React components (Document, Page, View, Text, Image), render to blob, trigger download. Styling: match visual design as closely as possible, use explicit dimensions and colors, handle font embedding for custom fonts. Tables: use jspdf-autotable plugin for complex tables with headers, footers, styling. Images: convert to base64 if from external URLs, handle CORS, resize appropriately. Multi-page: automatic page breaks based on content height, or explicit page break elements. Headers/footers: add to each page with page numbers, document title, date, company logo. Metadata: set PDF metadata (title, author, subject, keywords). Download trigger: create blob URL, create anchor element with download attribute, click programmatically. Filename: descriptive with content type and date ("Report_2024-12-15.pdf"). Progress: for large documents show progress indicator, use async generation. Server-side option: for best fidelity, use Puppeteer or Playwright to render page and print to PDF (handles CSS perfectly). Security: sanitize user content in PDFs to prevent PDF injection attacks. Compression: optimize images and enable PDF compression.'
      },
      {
        id: 'f24',
        label: 'CSV Export',
        simple: 'Export data tables to CSV format.',
        detailed: 'Implement CSV export for tabular data. Data formatting: convert objects to rows. Headers: include column headers. Escaping: handle commas, quotes, newlines in values. Encoding: UTF-8 with BOM for Excel compatibility. Download: trigger browser download. Filename: descriptive with date. Selected rows: option to export selected only. All data: export full dataset not just visible page. Custom columns: choose which columns to include.',
        advanced: 'Implement comprehensive CSV export for tabular data. Data preparation: flatten nested objects, format dates consistently, convert booleans to Yes/No or 1/0, handle null/undefined (empty string or "N/A"). CSV generation: map data to rows, join with commas, add header row. Escaping rules (RFC 4180): wrap values containing comma, quote, or newline in double quotes, escape double quotes by doubling them (""). Character encoding: UTF-8 with BOM (\\uFEFF prefix) for proper Excel compatibility with special characters. Download implementation: create Blob with text/csv type, create object URL, create anchor element with download attribute and filename, trigger click. Filename: descriptive with content and date ("users_export_2024-12-15.csv"). Export options: selected rows only (checkbox selection), current page vs all data (paginated data), filtered data (apply current filters), custom column selection (checklist modal). Large datasets: chunked processing with progress bar, Web Worker for non-blocking generation, streaming for very large files. Date formatting: ISO 8601 or locale-specific format, consistent across rows. Number formatting: preserve precision, handle locale differences in decimal separator. Boolean and enum: convert to human-readable values. Special fields: handle arrays (JSON string or repeated columns), exclude internal IDs or sensitive fields. Alternative formats: JSON export option alongside CSV. Server-side: for very large exports, generate on server and provide download link. Error handling: catch and report any generation errors.'
      },
      {
        id: 'f25',
        label: 'Data Import',
        simple: 'Import data from CSV or JSON files.',
        detailed: 'Build file import functionality. File selection: file input or drag and drop. Parsing: parse CSV with proper delimiter and quote handling. Validation: check required fields, data types. Preview: show parsed data before confirming. Mapping: map file columns to database fields. Error handling: show row-level errors. Batch import: handle large files in batches. Progress: show import progress. Duplicate handling: skip, update, or error on duplicates. Rollback: ability to undo import.',
        advanced: 'Build comprehensive file import functionality for CSV and JSON. File selection: file input with accept=".csv,.json", drag and drop zone, paste from clipboard. Parsing: PapaParse library for robust CSV parsing (handles quotes, delimiters, newlines), JSON.parse for JSON with error catching. Validation framework: schema definition (required fields, data types, formats, constraints), validate each row, collect all errors before aborting. Preview UI: modal or page showing parsed data in table, highlight validation errors per cell, show row count and error count. Column mapping: if headers don not match exactly, show mapping UI connecting file columns to target fields, save mapping for future imports. Type coercion: convert strings to numbers, parse dates (support multiple formats), normalize booleans (yes/no, true/false, 1/0). Error handling: row-level errors with specific messages, allow excluding invalid rows, show error log downloadable as CSV. Batch processing: chunk large files (1000 rows at a time), show progress bar, yield to main thread between chunks. Async import: for large datasets, import in background with status polling. Duplicate handling options: skip (don not import), update (merge with existing), error (abort on duplicate), detect duplicates by key field. Dry run: validate without actually importing, show what would happen. Transaction/rollback: wrap import in database transaction, rollback on error or user cancel. Import history: log successful imports with timestamp, row count, user, undo option. Templates: downloadable template file showing expected format with example data.'
      },
      {
        id: 'f26',
        label: 'Batch Actions',
        simple: 'Apply actions to multiple selected items at once.',
        detailed: 'Implement batch actions for multi-selection. Selection: checkboxes per item, select all checkbox. Selection count: show "N items selected" indicator. Action bar: appears when items selected with action buttons. Actions: delete, archive, tag, move, export selected. Confirmation: confirm destructive batch actions. Progress: show progress for batch operations. Partial failure: handle some items succeeding and others failing. Clear selection: after action completion.',
        advanced: 'Implement comprehensive batch actions system for multi-item operations. Selection mechanism: checkbox per row (controlled state in parent), "Select all" checkbox in header (tri-state: none, some, all), shift+click for range selection. Selection state: Set or Map of selected IDs, clear on page change or optionally retain across pages. Selection indicator: floating bar or header bar appears when items selected, shows "N items selected" count. Available actions: Delete, Archive, Restore, Add tags, Remove tags, Move to folder, Change status, Export, Assign to user. Action bar UI: flex row with buttons, dropdown for secondary actions, "Clear selection" button. Confirmation dialog: for destructive actions (delete), show count and warning, require explicit confirmation, optional "do not ask again" for session. API implementation: batch endpoint accepting array of IDs, or loop with rate limiting if no batch endpoint. Progress: for large batches show progress modal with percentage, processed count, cancel button. Partial failure handling: if some items fail (permissions, conflicts), show summary (45 succeeded, 5 failed), provide details of failures, option to retry failed items. Optimistic UI: update UI immediately, roll back on failure, or wait for confirmation. After completion: show success toast with count, clear selection, optionally keep selection for further actions. Keyboard shortcuts: Ctrl/Cmd+A select all (visible or all), Delete key for batch delete. Accessibility: announce selection changes, action results to screen readers. Audit log: record batch actions with user, timestamp, affected items.'
      },
      {
        id: 'f27',
        label: 'Auto-save',
        simple: 'Automatically save changes as user edits.',
        detailed: 'Implement auto-save functionality. Trigger: save on change after debounce delay (1-2 seconds). Status indicator: show "Saving...", "Saved", "Error" states. Conflict handling: detect concurrent edits. Draft system: save drafts before publishing. Offline: queue saves when offline. Manual save: still allow manual save option. Last saved time: show "Last saved 2 min ago". Unsaved warning: warn on page leave with unsaved changes.',
        advanced: 'Implement comprehensive auto-save system for seamless editing experience. Save triggers: debounced save on change (1-2 second delay), save on blur/focus loss, save before page unload. Status indicator: subtle indicator showing state - idle (hidden or muted), saving (Loader2 spinner, "Saving..."), saved (Check icon, "Saved" fades after 2s), error (AlertCircle icon, "Save failed" with retry). Debounce implementation: useCallback with debounce wrapper, cancel pending save on unmount. Draft system: save to localStorage or server draft endpoint, separate from published version, "You have unsaved draft" indicator on return. Version history: store revisions with timestamps, allow viewing and restoring previous versions. Conflict detection: store version number or timestamp, compare on save, show conflict UI if changed elsewhere. Conflict resolution: show both versions, allow merge or choose one. Offline support: detect navigator.onLine, queue saves when offline, process queue on reconnect, show offline indicator. API retry: exponential backoff on failure (1s, 2s, 4s), max retries before showing error. Manual save: Ctrl/Cmd+S still works, immediate save bypassing debounce. Last saved time: "All changes saved" or "Last saved 2 minutes ago", update relative time. Unsaved changes warning: beforeunload event handler, only warn if changes since last save. Save scope: save entire form or granular field-level saves. Optimistic updates: assume save succeeds, show error and revert if fails. Disable during critical operations: pause auto-save during bulk imports, deletes.'
      },
      {
        id: 'f28',
        label: 'Offline Mode',
        simple: 'Enable app to work offline with cached data.',
        detailed: 'Implement offline functionality. Service Worker: cache app shell and static assets. Data caching: IndexedDB for application data. Offline detection: navigator.onLine and event listeners. UI indicator: show offline status banner. Queue actions: store mutations to sync when online. Sync on reconnect: process queued actions. Conflict handling: resolve sync conflicts. Cache strategy: network-first or cache-first based on resource type.',
        advanced: 'Implement comprehensive offline support for progressive web app experience. Service Worker setup: Workbox for simplified SW development, precache app shell (HTML, CSS, JS, fonts), runtime caching for API responses and images. Cache strategies: CacheFirst for static assets (immutable), NetworkFirst for API data (fresh when possible), StaleWhileRevalidate for semi-static content. Data persistence: IndexedDB for structured data (use idb wrapper or Dexie.js), localStorage for small settings, Cache API for responses. Offline detection: navigator.onLine for initial state, online/offline events for changes, actual fetch failure as confirmation (navigator.onLine can be unreliable). UI indicators: banner or icon showing offline status, different styling for cached vs fresh data, "Changes saved locally" vs "Synced". Mutation queue: store pending writes in IndexedDB with timestamp and retry count, structured as {type, payload, created, attempts}. Background sync: Background Sync API for reliable sync when online (limited browser support), fallback to sync on visibility change or manual trigger. Sync process: process queue in order, handle failures with retry, update local state on success. Conflict resolution: timestamp-based (last write wins), field-level merge, or prompt user to resolve. Cache invalidation: version-based cache busting, periodic revalidation of cached data. Push notifications: notify user of sync completion or conflicts when returning online. App manifest: configure for installable PWA. Testing: Chrome DevTools offline mode, slow network throttling.'
      },
      {
        id: 'f29',
        label: 'Rate Limiting',
        simple: 'Prevent abuse by limiting action frequency.',
        detailed: 'Implement client-side rate limiting. Track attempts: count actions within time window. Throttle: prevent rapid repeated actions. Debounce: combine rapid inputs into single action. Cooldown: enforce waiting period after action. Visual feedback: show remaining cooldown time. Exponential backoff: increase delays after repeated attempts. Per-action limits: different limits for different actions. Reset: clear limits after success or timeout.',
        advanced: 'Implement comprehensive rate limiting for abuse prevention and UX improvement. Client-side throttling: prevent rapid button clicks (onClick disabled for 500ms after click), form submission (disable submit during request), API calls (max N per minute). Debounce for inputs: search input waits 300ms after typing stops before querying, rapid filters batch into single update. Implementation: throttle/debounce from lodash or custom hooks (useThrottle, useDebounce). Cooldown display: if action blocked, show countdown timer ("Try again in 15s"), countdown updates live, re-enable button when expired. Token bucket algorithm: allow burst up to limit, refill tokens over time, provides smooth limiting. Per-action configuration: different limits for different actions (comments: 5/min, likes: 30/min, file uploads: 10/hour). Exponential backoff: on repeated failures increase wait time (1s, 2s, 4s, 8s, max 30s), reset on success. Storage: track limits in memory (page session), localStorage (cross-session), or server-side (cross-device). Server coordination: client limits for UX, server limits for actual enforcement, handle 429 responses gracefully. Visual feedback: subtle indicator before limit reached ("Slow down"), clear error after limit hit, progress bar showing recovery. Captcha integration: after N failed attempts, require captcha verification. Limit by resource: per-user, per-IP, per-action type. Admin bypass: optional override for admin users or testing.'
      },
      {
        id: 'f30',
        label: 'Command Palette',
        simple: 'Add searchable command palette for quick actions.',
        detailed: 'Build command palette interface. Trigger: Ctrl/Cmd+K opens modal. Search: filter commands as user types. Categories: group commands by type. Fuzzy matching: find commands despite typos. Recent: show recently used commands. Keyboard nav: arrow keys to navigate, Enter to execute. Icons: icon per command. Shortcuts: show keyboard shortcut alongside command. Nested: support sub-menus for complex commands.',
        advanced: 'Build comprehensive command palette (like VS Code or Notion). Trigger: Ctrl/Cmd+K opens palette, Escape closes. Structure: modal with search input auto-focused, scrollable results list below. Search implementation: fuzzy matching for typo tolerance (use fuse.js or similar), search command names, descriptions, and keywords, highlight matching characters in results. Categories: group commands by type (Navigation, Actions, Settings, Recent), category headers in results, filter by category prefix (>Settings). Command definition: {id, label, description, icon, shortcut, action, keywords, category, enabled}. Results display: icon, label, description, keyboard shortcut aligned right, hover highlight, selected highlight with keyboard nav. Keyboard navigation: arrow up/down moves selection (wrap around), Enter executes selected, Tab might switch category, type continues searching. Recent commands: track usage in localStorage, show recent section at top when search empty. Contextual commands: filter available commands based on current page/state, disable unavailable commands with reason tooltip. Sub-menus: some commands open nested palette (e.g., "Go to file" opens file search), back button or Escape to return. Actions: navigate to page, trigger action, open modal, insert content. Animations: smooth open/close (scale + fade), results animate in on search. No results: helpful message ("No commands found"), suggest alternatives. Extensible: allow features to register commands dynamically. Analytics: track command usage for optimization.'
      },
      {
        id: 'f31',
        label: 'Quick Actions',
        simple: 'Add floating action button with quick action menu.',
        detailed: 'Build floating action button (FAB) with quick actions. Button: circular button fixed position bottom-right. Icon: Plus icon, rotates to X when open. Menu: fan out action buttons on click. Actions: contextual quick actions for current page. Labels: tooltip labels for each action. Animation: staggered animation on open/close. Close: click outside or press Escape. Mobile: larger touch targets. Accessibility: keyboard navigation, aria labels.',
        advanced: 'Build floating action button with expandable quick actions menu. Main button: fixed position (bottom-6 right-6), circular (w-14 h-14), primary color, shadow-lg, Plus icon. Open state: icon rotates 45deg to X, background may darken (overlay-sm). Action menu: smaller buttons fanning upward from main button, each with icon and label. Animation: main button rotates on toggle, action buttons animate in with staggered delay (100ms each), scale from 0 and translate from main button position, smooth spring easing. Action button style: w-12 h-12, varied colors per action type, icon centered, label appears on hover (right-aligned tooltip). Common actions: Create new (primary), Upload file, Send message, context-specific actions. Labels: visible tooltips or appear on hover, positioned to not overlap. Close triggers: click main button, click outside, Escape key, select action. Accessibility: main button aria-expanded, aria-haspopup="menu", action buttons in role="menu", keyboard focus traps in open menu, arrow keys navigate, announce open/close state. Mobile optimization: larger touch targets (w-16 h-16), label always visible or on long-press, consider bottom sheet alternative for many actions. Speed dial variant: labeled actions in vertical list rather than fan. Conditional visibility: hide FAB on certain pages or during scroll (scroll down to hide, scroll up to show). Extended FAB: pill shape with icon + text label for primary action.'
      },
      {
        id: 'f32',
        label: 'Clipboard Actions',
        simple: 'Add copy, cut, and paste functionality.',
        detailed: 'Implement clipboard operations. Copy: copy text/data to clipboard. Feedback: show "Copied!" toast. Rich copy: support copying formatted content. Paste: handle paste from clipboard. Paste preview: show preview before applying paste. Keyboard shortcuts: Ctrl/Cmd+C/X/V. Context menu: right-click menu with clipboard options. History: optional clipboard history. Format handling: plain text, HTML, or custom formats.',
        advanced: 'Implement comprehensive clipboard operations with rich content support. Copy implementation: navigator.clipboard.writeText for plain text, navigator.clipboard.write for rich content (ClipboardItem with multiple types). Async handling: clipboard API is async, handle promise. Feedback: toast notification "Copied to clipboard", brief confirmation icon animation on trigger button. Copy sources: text selection, button to copy element content, copy code blocks with dedicated button. Rich copy: HTML content for formatted text, include both text/plain and text/html for paste compatibility. Custom data: use application-specific MIME type for internal copy (application/x-myapp-item). Paste implementation: navigator.clipboard.read or readText, check permissions (Clipboard API requires user permission). Paste handling: onPaste event intercept, process clipboard data based on target (plain text input vs rich editor). Paste preview: for complex data (images, formatted content) show preview modal before inserting. Format detection: check clipboardData.types for available formats, handle each appropriately. Keyboard shortcuts: Ctrl/Cmd+C (copy), Ctrl/Cmd+X (cut), Ctrl/Cmd+V (paste), native browser behavior for inputs, custom handling for canvas/custom editors. Context menu: custom right-click menu with Copy/Cut/Paste options, native context menu as fallback. Image handling: copy images as blob, paste images from clipboard. Code blocks: copy button on code snippets, preserve formatting. Error handling: clipboard access denied, handle gracefully with fallback (select text, prompt to copy manually).'
      },
      {
        id: 'f33',
        label: 'Version History',
        simple: 'Track and restore previous versions of content.',
        detailed: 'Build version history system. Tracking: save versions on significant changes. Version list: show history with timestamps and authors. Compare: diff view between versions. Preview: preview any version without restoring. Restore: restore to previous version. Labels: name important versions (e.g., "Before refactor"). Auto-save: versioning integrated with auto-save. Limits: retention policy for old versions. Export: download specific version.',
        advanced: 'Build comprehensive version history system for content management. Version triggers: save on explicit save, auto-save at intervals, before major operations (publish, delete). Version storage: store complete snapshots or incremental diffs, use server storage or IndexedDB for local-only. Version metadata: timestamp, author/user, change summary (auto-generated or user-provided), version number or hash. Version list UI: chronological list showing timestamp, author avatar/name, change summary, maybe diff stats (+5/-2 lines). Compare versions: side-by-side diff view, inline diff with highlighting, show additions (green), deletions (red), unchanged (gray). Diff implementation: text diff algorithm (jsdiff library), or visual diff for documents. Preview: view any version in read-only mode without affecting current version, "Preview" vs "Restore" buttons. Restore options: restore to this version (creates new version), branch from this version, view only. Version labels/tags: ability to name important versions ("v1.0 Release", "Before redesign"), filter by labeled versions. Auto-cleanup: retention policy (keep all for 30 days, then weekly for 90 days, then monthly), or keep N most recent. Storage optimization: store diffs after initial period, compress old versions. Export: download any version as file, include version metadata. Branching: optional branching support for parallel versions. Audit trail: link versions to user actions, changes for compliance. Restoration notification: toast confirming restore, undo option.'
      },
      {
        id: 'f34',
        label: 'Activity Feed',
        simple: 'Show real-time feed of user and system activities.',
        detailed: 'Build activity feed component. Items: show actions with timestamp and actor. Types: user actions, system events, notifications. Icons: different icons per activity type. Real-time: update feed as events occur. Grouping: collapse similar activities. Filtering: filter by activity type or user. Pagination: infinite scroll or load more. Unread indicator: highlight new activities. Links: click to navigate to related item.',
        advanced: 'Build comprehensive activity feed system showing user and system events. Activity data structure: {id, type, actor (user/system), target (what was affected), timestamp, metadata}. Activity types: user actions (created, updated, deleted, commented, assigned), system events (scheduled job, automated process), status changes, integrations. Display format: avatar/icon, actor name, verb, target, timestamp, optional details. Timeline layout: vertical list, connector line, grouped by day. Real-time updates: WebSocket connection or polling for new activities, new items animate in at top, optionally show "N new activities" banner to click-to-load. Activity icons: different icons and colors per type (Plus for create, Edit for update, Trash for delete, MessageSquare for comment). Grouping: collapse similar activities ("John updated 5 files" instead of 5 separate items), expandable to see details. Rich content: preview of what changed, diff snippets, attached images. Filtering: by activity type (checkboxes), by user/team, by date range, by target type. Search: search activities by keyword. Pagination: infinite scroll with intersection observer, or "Load more" button, load 20-50 at a time. Unread state: track last seen timestamp per user, show new indicator (dot or "New" badge) on unread, mark as read on view. Navigation: click activity to go to related item (the document, comment, user). Actor click: navigate to user profile. Timestamps: relative time with absolute on hover. Notifications: activity feed can power notification system.'
      },
      {
        id: 'f35',
        label: 'Bookmarks/Favorites',
        simple: 'Let users bookmark items for quick access.',
        detailed: 'Implement bookmarking system. Bookmark action: star/bookmark button on items. Toggle: click to add or remove. Bookmarks page: list all bookmarked items. Persistence: save to user account or localStorage. Organization: folders or tags for bookmarks. Quick access: bookmarks in sidebar or dropdown. Search: filter bookmarks. Sync: sync across devices for logged-in users. Sorting: by date added, name, or custom order.',
        advanced: 'Implement comprehensive bookmarking/favorites system. Bookmark toggle: Star or Bookmark icon on items, click to toggle, filled/unfilled state, optimistic UI update. Storage: logged-in users save to database (user_bookmarks table with user_id, item_type, item_id, created_at), anonymous users save to localStorage. Bookmarks page: dedicated page listing all bookmarks, grid or list view toggle, item preview cards with quick actions. Organization: folders or collections to group bookmarks, drag and drop to organize, tags for cross-cutting categorization. Quick access: bookmarks dropdown in header, recent bookmarks in sidebar, keyboard shortcut to access (Ctrl/Cmd+B). Search and filter: search bookmarks by name/content, filter by type, folder, or tags, sort by date added, name, or custom. Item types: support bookmarking various item types (documents, products, users, searches), polymorphic design. Metadata: store when bookmarked, optional notes per bookmark, usage count (times accessed from bookmarks). Sync: real-time sync across devices for logged-in users, conflict resolution for simultaneous changes. Sharing: optionally share bookmark collections with others, public bookmark lists. Import/export: export bookmarks as JSON or browser bookmark format, import from other services. Limits: optional limit on bookmark count for free users. Analytics: track bookmark usage to surface popular items. Notifications: optionally notify when bookmarked items update.'
      },
      {
        id: 'f36',
        label: 'Quick Preview',
        simple: 'Preview content without leaving the current page.',
        detailed: 'Build quick preview functionality. Trigger: hover, long-press, or preview button. Modal: show content preview in overlay. Content types: support text, images, documents. Navigation: navigate within preview without leaving. Actions: quick actions from preview (edit, share). Close: click outside or Escape. Loading: skeleton while loading preview content. Mobile: full-screen preview on mobile. Link preview: preview external links within app.',
        advanced: 'Build comprehensive quick preview system for content inspection without navigation. Trigger options: hover with delay (500ms to prevent accidental triggers), dedicated preview button (Eye icon), keyboard shortcut while focused, long-press on touch. Preview modal: centered overlay with backdrop, animate in (scale + fade), max-width based on content type. Content loading: skeleton placeholder while loading, fetch preview data from API or use cached data. Content types: documents (rendered preview or PDF), images (full size with zoom), code (syntax highlighted), data records (formatted card), external links (fetch og:tags for preview). Preview content: condensed but complete view, key information visible, scroll for longer content. Navigation within preview: tabs or sections if content has multiple parts, do not navigate away from parent page. Quick actions: buttons in preview footer (Open, Edit, Share, Delete), primary action opens full view. Close triggers: click backdrop, Escape key, X button, click primary action. Keyboard navigation: Tab through preview content, arrow keys for items. Mobile optimization: full-screen modal on mobile (sheet from bottom), swipe down to close, larger touch targets. External link preview: for URLs, fetch open graph metadata, show title, description, image, site icon. Performance: lazy load preview content, cache recent previews, limit concurrent previews. Accessibility: focus management, trap focus in preview, announce preview open/close.'
      }
    ]
  };
